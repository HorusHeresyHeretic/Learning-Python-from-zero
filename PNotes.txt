Этой мой первый опыт - учебник Шапошникова, с ним связан файл hatBook.py

Машинный код" завершилась с кодом 0 (0x0).    Эта строка, говорит, что у вас всё прекрасно, а на остальное наплевать и забыть!! ! 1000 раз!!!

ИМЯ ПЕРЕМЕННОЙ ОПЕРАЦИЯ ПРИСВАИВАНИЯ ДАННЫЕ

Цифры  (все цифры - операнды)
> целые числа (integer) – положительные и отрицательные целые числа, а также 0 (например, 4, 687, -45, 0) 
> числа с плавающей точкой (float point) – дробные числа (например, 1.45,-3.789654, 0.00453). Примечание: разделителем целой и дробной части служит точка, а не запятая.
> строки (string) — набор символов, заключенных в кавычки (например, "ball", "What is your name?", 'dkfjUUv', '6589'). Примечание: кавычки в Python могут быть одинарными или двойными
С этим артефактом связан файл HatBook.py

Операторы (все знаки - операторы)
> Например, символ "+" по отношению к числам выполняет операцию сложения, а по отношению к строкам — конкатенацию (соединение). Парный знак ** возводит первое число в степень второго.
> при складывании целого числа и числа с плавающей точкой, получается число с плавающей точкой 1 + 0.65 = 1.64999999999
> "Hi, " + 15 = ошибка ( разный тип данных) 

Случаи, когда программа получает данные в виде строк, а оперировать должна числами
> В таком случае используются специальные функции (особые операторы), позволяющие преобразовать один тип данных в другой.
> Так функция int() преобразует переданную ей строку (или число сплавающей точкой) в целое
> int (5.95) = 5
> int ("comp 486") = ошибка (неверный тип данных в строке - попытка сложить цифры и строки)
> функция str() преобразует переданный ей аргумент в строку str(5.06) = '5.06'
> float() - в дробное число float (56) = 56.0

# STR # подробности

Ghost = 2
str(Ghost)

>>> Ghost = 2
>>> str(Ghost)
'2'
>>> 

> я преобразовал число в строку, число 2 стало строкой "2" - на что указывают кавычки
> однако если её попринтить всё равно будет двойка

>>> Ghost = 2
>>> print(Ghost)
2
>>> str(Ghost)
'2'
>>> print(Ghost)
2
>>> 

# STR # практика... запомни товарищ! str - это строки и фукнция коннетации

>>> Ghost_str = "Ghost"
>>> print(Ghost_str)
Ghost
>>>

>>> Ghost_str = "Ghost" * 2
>>> print(Ghost_str)
GhostGhost
>>> 

# INT # практика... запомни товарищ! int в подсказе студии означает число.

Ghost_int = 2
Ghost_int = Ghost_int * 2
print(Ghost_int)

Хранение данных через переменные
> Данные хранятся в ячейках памяти компьютера, при обращении к данным стали использовать так называемые переменные. 
> Механизм связи между переменными и данными может различаться в зависимости от языка программирования и типа данных. Пока достаточно запомнить,что 
> данные связываются с каким-либо именем и в дальнейшем обращение к ним возможно по этому имени.
> В программе на языке Python связь между данными и переменными устанавливается с помощью знака = 
( когда я пишу знак = я присваиваню данным имя с помощью которого я обращаюсь в ячейку хранения)
> Такая операция называется присваиванием. Например, выражение sq = 4 означает, что на объект (данные) в определенной области памяти ссылается имя sq и обращаться к ним теперь следует по этому имени.

Имена переменных могут быть любыми. Однако есть несколько общих правил их написания:
> давать переменным осмысленные имена, говорящие о назначенииданных, на которые они ссылаются.
> Имя переменной не должно совпадать с командами языка (зарезервированными ключевыми словами).
> Имя переменной должно начинаться с буквы или символа подчеркивания (_).

Чтобы узнать значение, на которое ссылается переменная, находясь в режиме интерпретатора, достаточно ее вызвать (написать имя и нажать Enter).

Пример кода
ghost = 404
kill_day = 4
day = 17
ghost = ghost - kill_day * day
ghost
336

Логические выражения
> если результатом вычисления выражения может быть лишь истина или ложь, то такое выражение называется логическим.

Логический тип данных
> два возможных значения: True (правда) — 1 и False (ложь) — 0. Только эти значения могут быть результатом логических выражений.

Логические операторы
>  специальные знаки, подобные тем, которые используются в математических выражениях: >(больше), < (меньше), >= (больше или равно), <= (меньше или равно).
>  Новыми для вас могут оказаться обозначение равенства: == (два знака "равно"); а также неравенства !=. Присваивание и сравнение — совершенно разные операции.

Символ команды комментарий (#) Пример 
# x равен 4 (комментарий в коде выделен залёным цветом)

Пример работы логического оператора (сначала приваиваем переменной значение - потом проверяем в логическом операторе) (после # написаны комментарии)
x = 12 – 5 # это не логическая операция, # а операция присваивания переменной x результата выражения 12 — 5
x == 4 # x равен 4
x == 7 # x равен 7
x != 7 # x не равен 7
x != 4 # x не равен 4
x > 5 # x больше 5
x < 5 # x меньше 5
x >= 6 # x больше или равен 6
x <= 6 # x меньше или равен 6

Сложные логические выражения
> Логические выражения типа verymuch >= 1023 является простым ЕСЛИ НУЖНО "Да" или "Нет" в зависимости от результата выполнения двух простых выражений, тогда
> Используются специальные операторы, объединяющие два и более простых логических выражения; есть два способа объединения: через, так называемые, логические И (and) и ИЛИ (or).

> Чтобы получить истину (True) при использовании оператора and, необходимо, чтобы результаты обоих простых выражений, которые связывает данный оператор, были истинными. 
> Если хотя бы в одном случае результатом будет False (ложь), то и все сложное выражение будет ложным.

> Чтобы получить истину (True) при использовании оператора or, необходимо, чтобы результаты хотя бы одного простого выражения, входящего в состав сложного, был истинным.
> В случае оператора or сложное выражение становится ложным лишь тогда, когда ложны все составляющие его простые выражения.

Пример.
x = 8
y = 13
x == 8 and y < 15 # x равен 8 и y меньше 15
x > 8 and y < 15 # x больше 8 и y меньше 15
x != 0 or y >15 # x не равен 0 или y меньше 15
x < 0 or y >15 # x меньше 0 или y меньше 15

>>> x = 8
>>> y = 13
>>> x == 8 and y < 15 # x равен 8 и y меньше 15
True
>>> x > 8 and y < 15 # x больше 8 и y меньше 15
False
>>> x != 0 or y >15 # x не равен 0 или y меньше 15
True
>>> x < 0 or y >15 # x меньше 0 или y меньше 15
False
>>> 

Условный оператор - инструкция (IF)
> всё то что делали до этого называется: линейное выполнение программы - когда выражения выполняются, начиная с первого и заканчивая последним, по порядку, не пропуская ни одной строки кода. 
> теперь делаем нелинейность действий в компьютерной программе: когда, часть кода должна выполняться лишь при определенном значении конкретной переменной.
> используем инструкцию (IF) - if чегото то там двоеточие (:) без (:) не работает
if Ghost < 100: # если значение переменной Ghost меньше 100, то ...
	c = a**b # возвести значение переменной a в степень b,
			# результат присвоить c.
> Первая строка конструкции if — это заголовок, в котором проверяется условие выполнения строк кода после двоеточия (тела конструкции)
> В примере выше тело содержит всего лишь одно выражение, однако чаще их бывает куда больше.
> Python это язык программирования с достаточно ясным и легко читаемым кодом. Это связано с тем, что в нем для разделения синтаксических конструкций используются отступы от начала строки. # Дзен Питона
> в конструкции if код, который выполняется при соблюдении условия, должен обязательно иметь отступ вправо
> Остальной код (основная программа) должен иметь тот же отступ, что и слово if.
> отступ делается с помощью клавиши Tab.
основной код
	вложенный код
основной код

освной код
IF
	False
True

> Встречается и более сложная форма ветвления: if–else. Если условие при инструкции if оказывается ложным, то выполняется блок кода при инструкции else. 

Пример
print ('HI')
tovar1 = 50
tovar2 = 52
if tovar1 + tovar2 > 99 :
	print ('Low Money')
else:
	print ('You buy it')
print ('CIA')

>>> print ('HI')
HI
>>> tovar1 = 50
>>> tovar2 = 52
>>> if tovar1 + tovar2 > 99 :
... 	print ('Low Money')
... else:
... 	print ('You buy it')
... 
Low Money
>>> print ('CIA')
CIA

Множественные ветвления
> Логика выполняющейся программы может быть сложнее, чем выбор одной из двух ветвей.
> в зависимости от значения той или иной переменной, может выполняться одна из трех (или более) ветвей программы.
> в Python предусмотрено специальное расширение инструкции if, позволяющее направить поток выполнения программы по одной из множества ветвей.
> расширенная инструкция, помимо необязательной части else, содержит ряд ветвей elif (сокращение от "else if" - "еще если") - elif это команда-оператор множественного ветвления

Частей elif может быть сколь угодно много 
> В отличии от использования множества одиночных инструкций if, инструкция if-elif-else прекращает просмотр последующих ветвей, как только логическое выражение в текущей ветке вернет true
> Например, если выражение при if (первая ветка) будет истинным, то после выполнения вложенного блока выражений, программа вернется в основную ветку
> Идея в том что бы обойти логическое органичение оператора if

Логическое ограничение оператора if
> Для множественного ветвления можно  использовать несколько инструкций if: 
> сначала проверяется условное выражение в первой инструкции if (если оно возвращает истину, то будет выполняться вложенный в нее блок кода), затем во второй инструкции if и т.д.
> Однако при таком подходе проверка последующих инструкций будет продолжаться даже тогда, когда первое условие было истинным, и блок кода при данной ветке был выполнен. 
> Проверка последующих условий может оказаться бессмысленной. 

В теории проблему можно решить с помощью вложенных конструкций if-else.
> Однако при этом часто появляется проблема правильной трактовки кода: непонятно, к какому if относится else (хотя в Python такая путаница не возможна из-за обязательных отступов)

 elif автоматизирует процесс поиска решений. 

 Примеры
x = -10
if x > 0 : 
    print ('1')
elif x < 0 :
    print ('-1')
else :
    print ('0')

>>> x = -10
>>> if x > 0 :
...     print ('1')
... elif x < 0 :       # true
...     print ('-1')
... else :             # не работает потому что работает elif ( elif работает через true ) 
...     print ('0')
-1
>>> x = -10
>>> if x > 0 : # false
...     print ('1')
... elif x > 0 :      # False
...     print ('-1')
... else :            # работает потому что elif проваили проверку со значением ( elif не работает при false )
...     print ('0')
0

Не забываем ставить скобочки и кавычки после принт, ещё пример.

result = "no result"
Ghost = 3
if Ghost == 0 :
    result = 0
elif Ghost == 1 :
    result = 1
elif Ghost == 2 :
    result = 2
elif Ghost == 13 : # False
    result = 3    
elif Ghost == 4 :
    result = 5
elif Ghost == 5 :
    result = 5
else :
    print ("Error")
print(result)

на выходе получаем Error потому что в elif есть False

result = "no result"
Ghost = 3
if Ghost == 0 :
    result = 0
elif Ghost == 1 :
    result = 1
elif Ghost == 2 :
    result = 2
elif Ghost == 3 :
    result = 3    # True
elif Ghost == 4 :
    result = 5
elif Ghost == 5 :
    result = 5
else :
    print ("Error")
print(result)

на выходе получаем Result потому что в elif нет False

Замечение по фукнции print
Ghost = 33
Shell = 10
if Ghost > Shell:
    x = Ghost - Shell
elif Ghost < Shell:
    x = Ghost + Shell
else:
    x = Ghost
x
print(x) # как отпринтить Х не как Х а как 23??? - нужно использоваться фукнцию print() : функция print() принтит что угоадно

Определить тип объекта можно при помощи функции type:

>>> type(2) 
 <class 'int'> # int - число
 >>> type('2') # str - строка
 <class 'str'>
 >>> type(2.0)
 <class 'float'> # число с плавающей точкой - дробь
 
x = 1
y = 2
z = 3
Ghost = x + y + z
if Ghost < 0:
    print('Shell')
elif Ghost > 10:
    print(x)
    if Ghost < 10:
        print(y)
elif Ghost != 6:
    print(x)
else:
    print(z)

функция (условие):	# это первичный алгоритм - интепритатор будет выполнять его и все встроенные алгоритмы до ошибки или до завершения алгоритма.
	действие
	функция (условие):
		действие
		фукнция (условие):
			фукнция (условие):
			действие
			действие
			действие
				фукнция (условие):
				действие
функция (условие): # это фунция которая завершает первичный алгоритм, в большинстве случаев это else 
	действие

Множественное ветвление.
> if, elif, else задают условия для проверки по принципам true\false
> "действие" - команда, которая выполняется при условии что вышестоящая строка true
> условие не может быть операцией типа "сложить, умножить и .д" - все условия оперируют знаками равенства: больше (>), меньше (<), неравно (!=), равно (==), больше или равно (=>), меньше или равно(<=) 
> действие не может быть опреацией по типу равенства - все действия это команды, начиная от print и заканчивая вычислениями с помощью знаков: плюс (+), минус (-), умножить (*), степень (**), делить (\)

> инструкция if-elif-else прекращает просмотр последующих ветвей, как только логическое выражение в текущей ветке вернет true

a = 1
b = 2
if a > b :  # false - ничего не делает: не принтит(а), переходит к следующей строке с функцией elif
    print(a)
elif a != b : # true - исполняет команду: принтит (a + b), завершает алгорит - ниже ничего не читает. 
    print(a + b)
elif a < b : # true - ничего не делает потому что в алгоритме if-elif уже есть true; алгоритм завершился.
    print(a)
if a < b :  # true - исполняет комнаду, на if-elif выше не смотрит потому что наверху работает ветвление.  
    print(b)

>>> a = 1
>>> b = 2
>>> if a > b :  # false - ничего не делает: не принтит(а), переходит к следующей строке с функцией elif
...     print(a)
... elif a != b : # true - исполняет команду: принтит (a + b), завершает алгорит - ниже ничего не читает. 
...     print(a + b)
... elif a < b : # true - ничего не делает потому что в алгоритме if-elif уже есть true; алгоритм завершился.
...     print(a)
... 
3
>>> if a < b :  # true - исполняет комнаду, на if-elif выше не смотрит потому что наверху работает ветвление, а эта строка относиться к исходному коду.  
...     print(b)
2
>>> 

Цикл While
> Циклы — это инструкции, выполняющие одну и туже последовательность действий, пока действует заданное условие. 
> В компьютерных программах наряду с инструкциями ветвлениями (т.е. выбором пути действия) также существуют инструкции циклов (повторения действия). 
> While - универсальный организатор цикла в языке программирования Python (как и во многих других языках) 
> While == "пока логическое выражение возвращает истину, выполнять определенные операции".

While (a) логичечкий оператор (b):
действия
изменения (а)

> логическое выражение в заголовке цикла while может быть более сложным, а изменяться может переменная (или выражение) b. 

"Зачем изменять a или b?" # ?
> Когда выполнение программного кода доходит до цикла while, выполняется логическое выражение в заголовке, и, если было получено True (истина), выполняются вложенные выражения.
> После поток выполнения программы снова возвращается в заголовок цикла while, и снова проверяется условие. # судя по всему с помощью вложений я смогу заставить комп посмотреть на процесс по разному
> Если условие никогда не будет ложным, то не будет причин остановки цикла и программа зациклится. # интересно, можно ли использовать зациклившиеся программы?
> Чтобы этого не произошло, необходимо предусмотреть возможность выхода из цикла — ложность выражения в заголовке. 

> Таким образом, изменяя значение переменной в теле цикла, можно довести логическое выражение до ложности. # нахрена?
> # ага это вещь - изменяемую переменную, которая используется в заголовке цикла while, обычноназывают счетчиком.
> Как и всякой переменной ей можно давать произвольные имена, однако очень часто используют буквы i и j. 

Простейший цикл на языке программирования Python может выглядеть так:

str1 = '+'
i = 0
while i < 10:
    print(str1)
    i = i + 1 # как я и думал - скрипт отпринтит + 10 раз и завершиться.

>>> str1 = '+'
>>> i = 0
>>> while i < 10:
...     print(str1)
...     i = i + 1
+
+
+
+
+
+
+
+
+
+
>>> 

# В последней строчке кода происходит увеличение значения переменной i на единицу, поэтому с каждым оборотом цикла ее значение увеличивается. Когда будет достигнуто число 10, логическое выражение 
i < 10 даст ложный результат, выполнение тела цикла будет прекращено, а поток выполнения программы перейдет на команды следующие за всей конструкцией цикла. Результатом выполнения скрипта 
приведенного выше является вывод на экран десяти знаков + в столбик. Если увеличивать счетчик в теле цикла не на единицу, а на 2, то будет выведено только пять знаков, т.к 
цикл сделает лишь пять оборотов.

Сложная фигня с фукнцией sum

> sum # Суммирует элементы указанного объекта с указанным начальным значением и возвращает результат. 
> была ли в этой задачи использована это укнция - непонятно, скорее всего нет, скорее всего опытный кодер просто приписал к операнду окончание _sum что бы своим опытным взглядом знать что это сумма.
> в теории логика команды соотвествует прототипу sum(iterable[, start])

-  iterable : Объект, поддерживающий итерацию по его элементам. Ожидается, что элементы этого объекта являются числами, но не строками. Если объект пуст, функция вернёт значение из start.
-  start=0 : Число, с которого следует начать суммирование.

подробности здесь https://pythonz.net/references/named/sum/

Ghost1 = 0
Ghost2 = 1
print(Ghost1)
print(Ghost2)
n = 10
i = 0
while i < n:
    Ghost_sum = Ghost1 + Ghost2
    print(Ghost_sum)
    Ghost1 = Ghost2
    Ghost2 = Ghost_sum
    i = i + 2

# Выводит 
1
2
3
5
8
>>> 

# я был прав- фукнцию sum никто в этом цикле не использовал, потому что и без _sum всё равботает, значит это просто "фича" автора учёбника, в принципе полезно - добавлять операндам _sum в конце,
> если по сути операнд является выражением суммы в логическом процессе, типа считаем  X + Y через Z - тогда можно написать Z_sum = X + Y и т.п, в принипе можно просто писать Ghost1,2,3 и т.д.

>>> Ghost1 = 0
>>> Ghost2 = 1
>>> print(Ghost1)
0
>>> print(Ghost2)
1
>>> n = 10
>>> i = 0
>>> while i < n:
...     Ghost3 = Ghost1 + Ghost2
...     print(Ghost3)
...     Ghost1 = Ghost2
...     Ghost2 = Ghost3
...     i = i + 2
1
2
3
5
8
>>> 

# Логика скрипта
> Этот пример выводит числа Фибоначчи — ряд чисел, в котором каждое последующее число равно сумме двух предыдущих: 0, 1, 1, 2, 3, 5, 8, 13 и т.д.
> Скрипт выводит двенадцать членов ряда: два (0 и 1) выводятся вне цикла и десять выводятся в результате выполнения цикла. 

# Смыысл происходящего
>  Вводятся две переменные (Ghost1 и Ghost2), которым присваиваются начальные значения. 
>  Присваиваются значения переменной n и счетчику i, между которыми те или иные математические отношения формируют желаемое число витков цикла.
>  Внутри цикла создается переменная Ghost_sum, которой присваивается сумма двух предыдущих членов ряда, и ее же значение выводится на экран. 
>  Далее изменяются значения Ghost1 и Ghost2 (первому присваивается второе, а второму - сумма), а также увеличивается значение счетчика. 

# Решение практической задачи из учебника

>>> Ghost1 = 0
>>> Ghost2 = 1
>>> print(Ghost1)
0
>>> print(Ghost2)
1
>>> n = 40
>>> i = 0
>>> while i < n:
...     Ghost_sum = Ghost1 + Ghost2
...     Ghost1 = Ghost2
...     Ghost2 = Ghost_sum
...     i = i + 2
...     if i > 10 and i < n:    # задаю критерии вывода переменных через if
...         print(Ghost_sum, end = " ")
13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 
>>>

# Функция Break в цикле While
 
> Цикл while становится бесконечным в случае, когда условие цикла никогда не становится ложным.
> Команда break в Python прекращает выполнение цикла и переводит выполнение программы на строку следующую после цикла.

# Множественное ветвление в цикле while в сочетании с фукнцией break и умением использовать расширенный функционал фукнции print - даёт отличные результаты.

> добавляет в скобочки любой индекс, получаем возможность визуально читать большой массив цифр, если например print(ghost) - это длинный ряд цифр, который нужно выделить,то 
> пишим print(ghost, "beta") - благадоря чему получаем длинный ряд цифр с индексом бета, который при выводе результатов алгоритма позволит отличить этот результат от другого.

>>> Ghost1 = 0
>>> Ghost2 = 1
>>> print(Ghost1)
0
>>> print(Ghost2)
1
>>> n = 40
>>> i = 0
>>> while i < n:
...     Ghost_sum = Ghost1 + Ghost2
...     Ghost1 = Ghost2
...     Ghost2 = Ghost_sum
...     i = i + 2
...     print(Ghost_sum, "start")          # нагло использую фукнцию принт для того что бы иметь возможность визуально оценивать результаты  - очень полезно.
...     if i > 10 and i < n:    # задаю критерии вывода переменных через if - это правильное решение!
...         print(Ghost_sum, "finish" , end = " ")
...     elif i > 10:     # нагло использую ещё один if через elif
...          print("stop", end = " ")
...          break
1 start
2 start
3 start
5 start
8 start
13 start
13 finish 21 start
21 finish 34 start
34 finish 55 start
55 finish 89 start
89 finish 144 start
144 finish 233 start
233 finish 377 start
377 finish 610 start
610 finish 987 start
987 finish 1597 start
1597 finish 2584 start
2584 finish 4181 start
4181 finish 6765 start
6765 finish 10946 start
stop 
>>> 

# Расширенный функционал фукнции Print

> горизонатльная печать
> с помощью команды end = " " в функции принт изменяеться характер вывода данных, print(ghost) - вертикальный вывод, print(Ghost, end = " ") - вертикальный вывод.
> также возможно использовать фукнцию коннетации за скобками команды print ( внутри скобок может быть любая самая лютая ересь Хоруса и неделимый Хаос)

>>> Ghost1 = 1
>>> Ghost2 = 2
>>> Ghost_sum = Ghost1 + Ghost2
>>> print(Ghost_sum + Ghost_sum, end = " ")
6 
>>> 

>>> Ghost1 = 0
>>> Ghost2 = 1
>>> print(Ghost1)
0
>>> print(Ghost2)
1
>>> n = 10
>>> i = 0
>>> while i < n:
...     Ghost_sum = Ghost1 + Ghost2
...     print(Ghost_sum + Ghost_sum, end = " ") # + Ghost_sum дал совершенно иной результат на выходе. (!) можно использовать для шлифовки решений на принте, подумать. 
...     Ghost1 = Ghost2
...     Ghost2 = Ghost_sum
...     i = i + 2
2 4 6 10 16 
>>> 


# Функция range в цикле while ( я пока не знак как правильно использовать range - но я узнаю это в будущем, подробности о фукнции тут http://pythonicway.com/education/basics/5-range )

# Фукнция range - команда для создания прогрессий, имеет вид : (range(start_or_stop, stop, step))
> start_or_stop=0 : Целое число, которое должно явиться началом последовательности. 
> Если тип инициализируется с одним аргументом, то значение трактуется как stop, 
> а начало последовательности при этом — 0.
> прогресси можно сравнивать:

>>> (range(10,100,5)) == (range(10,90,5))
False
>>> 

type(range(3))  # class 'range'

list(range(5))  # [0, 1, 2, 3, 4]
list(range(1, 5))  # [1, 2, 3, 4]
list(range(0, 10, 3))  # [0, 3, 6, 9]
list(range(0, -5, -1))  # [0, -1, -2, -3, -4]
list(range(0))  # []
list(range(1, 0))  # []

Фича фукнции print()

> print(Ghost_sum, [5,20]) - отпринтить не только госта, но и всё что в скобочках...
> Подумать воn над чем # я добавил in range в скобочки к фукнции print, получилось весело.

>>> Ghost1 = 0
>>> Ghost2 = 1
>>> print(Ghost1)
0
>>> print(Ghost2)
1
>>> n = 20
>>> i = 0
>>> while i < n:
...     Ghost_sum = Ghost1 + Ghost2
...     print(Ghost_sum in range (8,40,2))
...     Ghost1 = Ghost2
...     Ghost2 = Ghost_sum
...     i = i + 2
False
False
False
False
True
False
False
True
False
False
>>> 

> в теории это работает так:

>>> Ghost = 1
>>> Shell = 2
>>> if Ghost > Shell:
...     print(Ghost in range(1,10,2))
... elif Ghost < Shell:
...     print(Ghost in range(1,10,1))
True
>>> 

# на практике - я ничего непонимаю, завтра перейду к следующей главе учебника.

Ввод данных с клавиатуры
> написание программ которые способны обрабатывать данные поступающие из внешних источников: из файлов или с клавиатуры # из БД например.
> Когда информация вводится с клавиатуры, а результаты выводятся на экран монитора, то можно говорить об интерактивном режиме работы программы.
> В интерактивном режиме программа обменивается информацией с внешней для нее средой: может выводить и получать данные в процессе выполнения, и не является замкнутой сама на себе.

> С выводом данных мы уже отчасти знакомы: выводом на экран (и не только) в языке программирования Python занимается функция print().
> Ввод данных с клавиатуры в программу (начиная с версии Python 3.0) осуществляется с помощью функции input()

# Когда данная функция выполняется, то поток выполнения программы останавливается в ожидании данных, которые пользователь должен ввести с помощью клавиатуры.
# После ввода данных и нажатия Enter, функция input() завершает свое выполнение и возвращает результат, который представляет собой строку символов, введенных пользователем.

>>> input() # пишу input() - комп переходи в режим ожидания данных, которые я должен ввести с клавиатуры
12345		# ввожу данные

'12345'		# вывод данных
>>> 

# функция input() может принимать необязательный аргумент-приглашение строкового типа; при выполнении функции сообщение будет появляться на экране и информировать человека о запрашиваемых данных

>>> input("Ghost") # добавляет необязательный строчный параметр ( вроде подсказки за скобочка в принт - когда к длинному ряду чисел добавили индекс )
Ghost
Shell

'Shell'
>>> 

# данные возвращаются в виде строки, даже если было введено число.
>  если требуется получить число, то результат выполнения функции input() изменяют с помощью функций int() или float().

>>> int(input('сколько жизней у кошки?'))
сколько жизней у кошки?
9

9
>>> 

>>> float(input('сколько жизней у кошки?'))
сколько жизней у кошки?
9

9.0
>>> 

> Результат, возвращаемый функцией input(), обычно присваивают переменной для дальнейшего использования в программе.

>>> Ghost = input()
11

>>> Shell = Ghost
>>> print(Shell)
11
>>> 

#  результаты практической работы см. модуль 2.

>>> thisis = input("What is your name")
What is your name
alex

>>> itis = int(input("How old are you"))
How old are you
31

>>> helivein = input("where are you live")
where are you live
moscow

>>> print(thisis, itis, helivein)
alex 31 moscow

# как красиво сделать бесконеный цикл while, который постоянно спрашивают юзера правильный ответ до тех пор пока юзер его не введёт.
> 3я задача из практической работы с 28 страницы http://younglinux.info/sites/default/files/python_structured_programming.pdf

>>> x = int(input("4*100-54"))
4*100-54
122212								  # неправильный ответ который ввёл юзер

>>> y = 346
>>> while x != y:                   
...     print ('bad')
...     x = int(input("4*100-54"))    # чувствую себя паравозиком, который смог - это очень важная строка, она сработала как break но при этом запросила юзера ввести данные с клавы и повторила цикл while.
... else:                        
...     print ('good')
... 
bad									  # за это алгоритм вернул ему bad и предложил задачу ещё раз
4*100-54
346									  # правильный ответ которыё ввёл юезр	

good								  # за это аглгоритм вернул ему good
>>> 

Последовательности символов и строки
> Строка — это сложный тип данных, представляющий собой последовательность символов.
> Существует специальная функция len(), позволяющая измерить длину строки. Результатом выполнения данной функции является число, показывающее количество символов в строке.

>>> len('ghost in the shell')
18
>>> 

# Также для строк существуют операции конкатенации (+) и дублирования (*).

>>> "Ghost" + "Shell" + "Ghost"         # коннетация
'GhostShellGhost'
>>> 

>>> "Shell" * 20    # дублирование, выполняет только в случае,  * int  -  дублирует на число указанное после фукнции *
'ShellShellShellShellShellShellShellShellShellShellShellShellShellShellShellShellShellShellShellShell'
>>> 

> В последовательностях важен порядок символов, у каждого символа в строке есть уникальный порядковый номер — индекс.
> Можно обращаться к конкретному символу в строке и извлекать его с помощью оператора индексирования, который представляет собой квадратные скобки с номером символа в них.

>>> "Ghost"[0]     # [x] - оператор индексирования строки, обращается к строке и извлекает символ указанный в скобках
'G'
>>> "Ghost"[1]
'h'
>>> "Ghost"[2]
'o'
>>> 

>>> Ghost = "Anime and Major"    #    оператор можноиспользовать после записи данных через переменную в отношении переменной, т.е
>>> Ghost[4]                     #    комп знает что переменная Ghost - это строка "Anime and major" и может её проиндексировать.
'e'
>>> 

# Также позволительно извлекать символы, начиная отсчет с конца. В этом случае отсчет начинается с -1 (последний символ).

>>> Ghost = "Anime and Major"    #    оператор можноиспользовать после записи данных через переменную в отношении переменной, т.е
>>> Ghost[-1]                    #    комп знает что переменная Ghost - это строка "Anime and major" и может её проиндексировать.
'r'
>>> Ghost[-5]                    #    можно работать с конца через минус (начиная с [-1] и делать это можно сколько душе угодно.
'M'
>>> 

# Результат выполнения выражения индексирования можно присвоить другой переменной. 

>>> x = "Ghost in the Shell"     #    т.е х = "Ghost in the shell" где  x это данные в формате G[0]H[1]O[2]S[3]T[4] [5]I[6]N[7] [8]T[9]H[10]E[11] [12]S[13]H[14]E[l5]L[16]L[17] итого 18 начиная с 0
>>> y = x[0]                     #    поскольку эти данные уже существуют - им можно присваивать любые переменные через оператор индексирования.
>>> print(y)
G
>>> z = x[4]
>>> print(z)
t
>>> 

# Можно извлекать из строки не один символ, а несколько, т.е. получать срез (подстроку). Оператор извлечения среза из строки выглядит так: [X:Y]. 
> X – это индекс начала среза, а Y – его окончания; причем символ с номером Y в срез уже невходит. 
> Если отсутствует первый индекс, то срез берется от начала до второго индекса; 
> при отсутствии второго индекса, срез берется от первого индекса до конца строки.

>>> "Ghost in the Shell"[0:4]   #    срез с 0 до 4 символа строки, не включая 4ый символ
'Ghos'
>>> 

>>> "Ghost in the Shell"[0:]    #    срез без указания заключительной позиции - до конца строки
'Ghost in the Shell'
>>> 

# можно извлекать символы не подряд, а через определенное количество символов

> В таком случае оператор индексирования выглядит так: [X:Y:Z);
> Z – это шаг, через который осуществляется выбор элементов. 

>>> "Ghost in the Shell"[::2]  #    срез без указания стартовой и заключительной позиции с шагом 2
'Goti h hl'
>>> 

>>> "Ghost in the Shell"[0:11:2] #    срез c указанием стартовой и заключительной позиции с шагом  - стартовая позиция 0, заключительная позиция 11, шаг 2.
'Goti h'
>>> 

>>> Ghost = "Warhammer40K"
>>> Ghost[0]                    #     первый с начала
'W'
>>> Ghost[-1]                   #     первый с конца
'K'
>>> print(Ghost)
Warhammer40K
>>> Ghost[2]                    #     третий с начала
'r'
>>> Ghost[-3]                   #     третий с конца
'4'
>>> len("Warhammer40K")         #     длинна строки
12
>>> 

>>> Heresy = "God Emperor Was Banned By The Horus Banhammer"
>>> Heresy[0:8]
'God Empe'
>>> len(Heresy)                #      оператор len() также можно использовать по отношению к переменной, возвращает длинную строки (в данном случае 45 символов, 39 букв и 6 пробелов)
45
>>> Heresy[21:25]
'd By'
>>> Heresy[2:45:3]             #      индексы кратные 3 с начала, 3ий индекс.... 45индекс
'dmr saeBT r nmr'
>>> 

Списки - изменяемые последовательности
> Списки в языке программирования Python, как и строки, являются упорядоченными последовательностями. 
> в отличии от строк, списки состоят не из символов, а из различных объектов (значений, данных), и заключаются не в кавычки, а в квадратные скобки [ ].

# Объекты отделяются друг от друга с помощью запятой.

> Списки могут состоять из различных объектов: чисел, строк и даже других списков. В последнем случае, списки называют вложенными.

[23, 656, -20, 67, -45]             # список целых чисел
[4.15, 5.93, 6.45, 9.3, 10.0, 11.6] # список из дробных чисел
["Katy", "Sergei", "Oleg", "Dasha"] # список из строк
["Москва", "Титова", 12, 148]       # смешанный список
[[0, 0, 0], [0, 0, 1], [0, 1, 0]]   # список, состоящий из списков

# Как и над строками над списками можно выполнять операции соединения и повторения, а также присваивать спику переменную (ведь список это данные) и проводеить с этой переменной операции.

>>> x = 1
>>> y = [404, "anime", 303, "Ghost"] * x
>>> print(y)
[404, 'anime', 303, 'Ghost']
>>> 

# По аналогии с символами строк, можно получать доступ к объектам списка по их индексам, извлекать срезы, измерять длину списка:

>>> anime = ["Ghost", "In", "The", "Shell"]
>>> major = [["Stand"], ["Alone"], ["Complex"]]
>>> story = anime + major
>>> print(story)
['Ghost', 'In', 'The', 'Shell', ['Stand'], ['Alone'], ['Complex']]
>>> len(story)
7
>>> story[0:-1:2]                            # срез от начала до последнего индекса конца с шагом 2, -1 не включён в срез также как и 0:4 не включил бы 4 индекс в срез.
['Ghost', 'The', ['Stand']]
>>> 

> В отличии от строк, списки — это изменяемые последовательности. Если представить строку как объект в памяти, то когда над ней выполняются операции конкатенации и повторения - эта строка не меняется
> а в результате операции создается другая строка в другом месте памяти ( операции со строками жрут). В строку нельзя добавить новый символ или удалить существующий, не создав при этом новой строки.

# Со списком дело обстоит иначе. (спики не жрут стока памяти как строки - потому что при работе со списком комп просто перезаписывает единственный объект в памяти - список)

> При выполнении операций другие списки могут не создаваться, а изменяться непосредственно оригинал. Из списков можно удалять элементы, добавлять новые. 
> При этом следует помнить, многое зависит от того, как вы распоряжаетесь переменными. Бывают ситуации, когда списки все-таки копируются.

# Например, результат операции присваивается другой переменной. 

> Символ в строке изменить нельзя, элемент списка — можно: Дзен(!)

>>> animestr = "GhostInTheShell"
>>> animelist = ['Ghost', 'In', 'The', 'Shell']
>>> animestr[3] = 0                                 # попытка перезаписать данные в строке "GhostInTheShell" в части индекса [3] ( буковки - s ) не прокатит
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
>>> animelist[3]
'Shell'
>>> animelist[3] = "Major"                          # а вот заменить индекс в спике - не проблема.
>>> print(animelist)
['Ghost', 'In', 'The', 'Major']
>>> animelist[0:-1] = "Tatikoma"                    # можно заменить срез
>>> print(animelist)
['T', 'a', 't', 'i', 'k', 'o', 'm', 'a', 'Major']
>>> animelist[0:4] = [404,303]                      # всяко можно
>>> print(animelist)
[404, 303, 'k', 'o', 'm', 'a', 'Major']
>>> batolist = animelist * 2 + animelist[0:-1]      # новый список по имени Бато
>>> type(animelist)                                 # посмотрел что из себя представляет animelist - это не строка, это список.
<class 'list'>
>>> type(animelist[0:-1])
<class 'list'>
>>> type(batolist)
<class 'list'>
>>> print(batolist)
[404, 303, 'k', 'o', 'm', 'a', 'Major', 404, 303, 'k', 'o', 'm', 'a', 'Major', 404, 303, 'k', 'o', 'm', 'a']
>>> storylist = animelist                           # новая переменная для списка animelist
>>> print(storylist)
[404, 303, 'k', 'o', 'm', 'a', 'Major']
>>> type(storylist)
<class 'list'>
>>> storylist[0] = 11                               # новые данные для индекса от новой переменной
>>> print(animelist)
[11, 303, 'k', 'o', 'm', 'a', 'Major']
>>> 

>>> # пример попроще
... 
... xlist = [1,2,3,4,5,6,7,8,9,10]                  #    записываю в комп список через переменную x
... 
>>> ylist = xlist + xlist                           #    записываю в комп переменную y - которая воспроизводит результат коннетации списков
>>> zlist = ylist                                   #    присваиваю переменной y , которая отвечает за результат коннетации списков ещё одну переменную z
>>> zlist[0] = 11                                   #    вношу измненеия в индекс переменной z - что автоматически приводит к замене индекса в переменной y
>>> print(ylist)                                    #    все счастливы, все переменные имеют тип list, всё работает
[11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> 

# обнаржуенная фукнция list() - тоже самое что int() и str()

# оюнаружена фича - альтернатива коннетации

>>> anime = [11, "Ghost", "In" , "The", "Shell", "Major", 11]
>>> print(anime)
[11, 'Ghost', 'In', 'The', 'Shell', 'Major', 11]
>>> len(anime)
7
>>> anime[0:3] = ["Story", "Heresy", "Emperor", "Horus"]     # это просто Дзен питона!
>>> print(anime)
['Story', 'Heresy', 'Emperor', 'Horus', 'The', 'Shell', 'Major', 11]
>>> len(anime)
8
>>> anime[8:11] = ["Heresy", "Heresy", "Heresy"]
>>> print(anime)
['Story', 'Heresy', 'Emperor', 'Horus', 'The', 'Shell', 'Major', 11, 'Heresy', 'Heresy', 'Heresy']
>>> 

ВВедение в словари

> Одним из сложных типов данных (наряду со строками и списками) в языке программирования Python являются словари. 
> Словарь - это изменяемый (как список) неупорядоченный (в отличие от строк и списков) набор пар "ключ:значение".

# строки и списки упорядоченные типы данных - словари нет.
# аналогия с англо-руссикм словарём

> На каждое английское слово в таком словаре есть русское слово-перевод: cat – кошка, dog – собака, table – стол и т.д
> Если англо-русский словарь описывать с помощью Python, то английские слова будут ключами, а русские — их значениями:

{'cat':'кошка', 'dog':'собака', 'bird':'птица', 'mouse':'мышь'}		# фигурные скобки - словарь {}

> Синтаксис словаря на Питоне можно описать такой схемой:

{ключ:значение,ключ:значение,ключ:значение,ключ:значение,...}

> Если создать словарь в интерпретаторе Python, то после нажатия Enter можно наблюдать, что последовательность вывода пар "ключ:значение" не совпадает с тем, как было введено:

>>> {'anime':'аниме',"ghost":"призрак","shell":"образ"}
{'shell': 'образ', 'ghost': 'призрак', 'anime': 'аниме'}
>>> 

# Дело в том, что в словаре абсолютно не важен порядок пар, и интерпретатор выводит их в случайном порядке.
# Тогда как же получить доступ к определенному элементу, если индексация не возможна в принципе? 

> Ответ: в словаре доступ к значениям осуществляется по ключам, которые заключаются в квадратные скобки (по аналогии с индексами строк и списков).

>>> dic = {'anime':'аниме',"ghost":"призрак","shell":"образ"}         # переменная[ключ]  - оператор обращения к данным словаря
>>> dic["anime"]
'аниме'
>>> dic["shell"]
'образ'
>>> 

# Словари, как и списки, являются изменяемым типом данных: можно изменять, добавлять и удалять элементы (пары "ключ:значение").
> Изначально словарь можно создать пустым (например, d = {}) и лишь потом заполнить его элементами. dic = {} - пустой словарь.

# Добавление и изменение имеет одинаковый синтаксис: словарь[ключ] = значение.

> Ключ может быть как уже существующим (тогда происходит изменение значения), так и новым (происходит добавление элемента словаря). Удаление элемента словаря осуществляется с помощью функции del().

>>> dic = {'anime':'аниме',"ghost":"призрак","shell":"образ"}         # переменная[ключ]  - оператор обращения к данным словаря
>>> dic["anime"]
'аниме'
>>> dic["shell"]
'образ'
>>> dic["major"] = "Призрак в доспехах"                               # операция записи новых данных - переменная[ключ] = "данные"
>>> print(dic)
{'shell': 'образ', 'major': 'Призрак в доспехах', 'ghost': 'призрак', 'anime': 'аниме'}
>>> len(dic)                                                          # длинна слова - 4
4
>>> type(dic)                                                         # тип - "dict"
<class 'dict'>
>>> del(dic["shell"])                                                 # удаление данныех из словаря - del(переменная["ключ"])
>>> print(dic)
{'major': 'Призрак в доспехах', 'ghost': 'призрак', 'anime': 'аниме'}
>>> 

> Тип данных ключей и значений словарей не обязательно должны быть строками. Значения словарей могут быть более сложными (содержать структуры данных, например, другие словари или списки).

>>> dic_anime = {'anime':'аниме',"ghost":"призрак","shell":"образ"}
>>> dic_shell = {"1": "One"}
>>> print(dic_anime)
{'shell': 'образ', 'ghost': 'призрак', 'anime': 'аниме'}
>>> dic_shell == dic_anime                                                      # можно проверять переменные словарей логическими операциями
False
>>> dic_shell["11"] = [["Bato", "Major", 11], ["Stand", "Alone", "Complex"]]    # в словарь модно добавлять разные объекты.
>>> print(dic_shell)
{'1': 'One', '11': [['Bato', 'Major', 11], ['Stand', 'Alone', 'Complex']]}
>>> type(dic_shell)                                                             # dic_shell - объект типа dict
<class 'dict'>
>>> type(["11"])                                                                # ключ 11 - объект типа list
<class 'list'>
>>> type([["Bato", "Major", 11], ["Stand", "Alone", "Complex"]])                # Дзен в том что объект типа dict это строка или список неупорядоченного типа, а объекты тип list,str - упорядоченные.
<class 'list'>
>>> 

Циклы For в Питоне 

> while не единственный способ организации повторения группы выражений.
> цикл for представляет собой цикл обхода заданного множества элементов (символов строки, объектов списка или словаря) и выполнения в своем теле различных операций над ними.
> Например, если имеется список чисел, и необходимо увеличить значение каждого элемента на две единицы
> то можно перебрать список с помощью цикла for, выполнив над каждым его элементом соответствующее действие. 

>>> anime = [101,202,303,404,505,606,707,808,909]
>>> i = 0
>>> for element in anime:
...     anime[i] = element + 2
...     i = i + 1
... 
>>> print(anime)
[103, 204, 305, 406, 507, 608, 709, 810, 911]
>>> 

# В примере переменная i нужна для того, чтобы записать изменившееся значение элемента в список. В ней хранится значение индекса очередного элемента списка.
> В то время, как переменная element связывается со значением очередного элемента данных. В заголовке цикла for происходит обращение очередному элементу списка.
> В теле цикла элементу с индексом i присваивается сумма значения текущего (обрабатываемого) элемента и двойки

>>> anime = [101,202,303,404,505,606,707,808,909]       # это список - у списка есть индексы с 0 по 8
>>> len(anime)                                          # 9 ( 0,1,2,3,4,5,6,7,8)
9
>>> i = 0                                               # не любит варианты больше 0, возвращает list assignment index out of range и билиберду вида [101, 202, 103, 204, 105, 206, 107, 208, 109]
>>> for element in anime:                        # условия алгоритма: " для элементов в списке anime"
...     anime[i] = element + 2                   # операция редактирования списка по индексу: " перезаписать данные в списке anime в части индекса [i] " - "присвоить данным в индексе [i] новые значения"
...     i = i + 1                                # операция переборы индексов: "перебрать индексы с 0 до конца списка" ( в отличии от while - не теряет берега и не выпадает в бесконечный алгоритм ) 
... 
>>> print(anime)
[103, 204, 305, 406, 507, 608, 709, 810, 911]
>>> 

> Далее индекс увеличивается на единицу, а поток выполнения программы переходит снова в заголовок цикла for, где происходит обращение к следующему элементу списка. 
> Когда все элементы обработаны цикл for заканчивает свою работу. Отсутствие очередного элемента является условием завершения работы цикла for

# (для сравнения: в цикле while условием завершения служит результат false логического выражения в заголовке).

Дзен

# Если счетчик не увеличивать на единицу (выражение i = i + 1), то не смотря на то, что все элементы списка будут обработаны, 
> результат все время будет присваиваться первому элементу списка (с индексом 0).

...     i = i + 0                                # операция переборы индексов: "перебрать индексы с 0 до конца списка" ( в отличии от while - не теряет берега и не выпадает в бесконечный алгоритм ) 
... 
>>> print(anime)
[911, 202, 303, 404, 505, 606, 707, 808, 909]
>>> 

# кроме того ругаеться на двойку в счётчике

...     i = i + 2                                # операция переборы индексов: "перебрать индексы с 0 до конца списка" ( в отличии от while - не теряет берега и не выпадает в бесконечный алгоритм ) 
... 
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
IndexError: list assignment index out of range
>>> print(anime)
[103, 202, 204, 404, 206, 606, 406, 808, 208]
>>> 

> С таким же успехом перебирать можно и строки, если не пытаться их при этом изменять:

Major = "Ghost In The Shell"
for bukva in Major:                         # видимо питон знает понятие element  и  bukva
    print(bukva, end = "*")

> Цикл for используется и для работы со словарями:

>>> anime = {"Ghost":"Major","Bato":"Major Friend","11":"Crazy Major Friends","Godo":"Evil Enemy"}
>>> for key in anime:                           # видимо питон знает понятие key в словаре
...     anime[key] = anime[key] + "_Me"
... 
>>> print(anime)
{'11': 'Crazy Major Friends_Me', 'Godo': 'Evil Enemy_Me', 'Bato': 'Major Friend_Me', 'Ghost': 'Major_Me'}
>>> 

# Цикл for широко используется в языке программирования Python, т.к. является важным инструментом при обработки структур данных.

Дзен(!)

> цикл for в Питоне особенный. 
> Он не является аналогом циклов for во многих других языках программирования, где представляет собой, так называемый, цикл со счетчиком.

>>> Major = ["Ghost","Shell","Anime","Bato"]              # список из 4х строк
>>> for i in Major:                                       # для индексов в списке
...     for j in i:                                       # для букв в списке
...         print(j,end = "-")                            # отпринтить через дефис
G-h-o-s-t-S-h-e-l-l-A-n-i-m-e-B-a-t-o-
>>> 

>>> Major = ["Ghost","Shell","Anime","Bato"]
>>> for i in Major:
...     print(i)                               # сильная сторона цикла for в питон в том, что он всё делает последовательно. см . результат.
...     for j in i:
...         print(j)
Ghost											
G												
h
o
s
t
Shell
S
h
e
l
l
Anime
A
n
i
m
e
Bato
B
a
t
o
>>> 

>>> Shell = [11,22,33,44,501]
>>> i = 0
>>> for j in Shell:                                      # вместо j может быть любая фигня - в языке питон это не важно, важно что есть команда "для данных в переменной". 
...     Shell[i] = float(j)                              
...     i = i + 1
... 
>>> print(Shell)
[11.0, 22.0, 33.0, 44.0, 501.0]
>>> 

Супер Дзен(!)

# логическая команда цикал for звучит так " для данных в чем либо(например в переменной)" for data in anime 
> поскольку в переменной, указаной в команде всегда есть данные и их тип известн - питон всё сделает сам.
> а нам в свою очередь не нужно заморачиваться над тем как именно эти данные обозвать внутри алгоритма.

for j in anime...for x in anime...for qw in anime... - одна фигня, если конечно j,x или qw не являються специальными символами и не несут в себе командой нагрузки для интерпитатора.

Супер Дзен(!)

# for j in Shell:                                      
    Shell[i] = строкой, числом с плавающей точкой, словарём, списком и т.д - эти две строчки "для данных в переменной" и "для индексов в переменной" = супер оружие по модификации данных
	
- с этим дзеном ещё нужно будет разбираться, как и с помощью каких команд можно так лихо хуевертить данными внутри алгоримта for по индексу этих данных, нужно посмотреть в продвинутом учебнике (!)	 

Функции в программировании.

> Функции в программировании можно представить как изолированный блок кода, обращение к которому в процессе выполнения программы может быть многократным.

 Зачем нужны такие блоки инструкций? 
 
 > В первую очередь, чтобы сократить объем исходного кода: рационально вынести часто повторяющиеся выражения в отдельный блок и, затем, по мере надобности, обращаться к нему. 
 > Представим себе следующую ситуацию. Требуется написать скрипт, который при выполнении должен три раза запрашивать у пользователя разные данные, но выполнять с ними одни и те же действия.

 a = int(input("Введите первое число"))
b = int(input("Введите второе число"))
if a > b:
    print(a-b)
else:
    print(b-a)

c = int(input("Введите первое число"))
d = int(input("Введите второе число"))
if c > d:
    print(c-d)
else:
    print(d-c)

e = int(input("Введите первое число"))
f = int(input("Введите второе число"))
if e > f:
    print(e-f)
else:
    print(f-e)  

# Данная программа находит модуль разницы двух чисел. Очевидно, что такая запись исходного кода не рациональна: получаются три почти одинаковых блока кода.
> Почему бы не использовать цикл while для организации повторения?

>>> i = 0
>>> while i < 3:
...     a = int(input("Введите первое число"))               # исходная задача црока 13, оптимизация через while, делает 6 операций по вводу, но переменных всего 2 
...     b = int(input("Введите второе число"))               # при каждом витке цикла преддыдущие данные переменных a b утрачиваеться в процессе перезаписи данных
...     if a > b:
...         print(a-b)
...     else:
...         print(b-a)
...     i = i + 1                                            # цикл повторяется три раза
Введите первое число
122112

Введите второе число
2112

120000
Введите первое число
2112

Введите второе число
1212

900
Введите первое число
1212

Введите второе число
1212

0
>>> 

> Что же делать, если все шесть чисел, введенных пользователем надо сохранить для дальнейшего использования в программе? Рассмотрим решение этой задачи с использованием функции. 

>>> def diff():
...     m = int(input("Введите первое число"))
...     n = int(input("Введите второе число"))
...     if m > n:
...         print(m-n)
...     else:
...         print(m-n)
...         return m,n
... 
>>> a,b = diff()
Введите первое число
12121

Введите второе число
121212

-121091
>>> c,d = diff()
Введите первое число
1212

Введите второе число
3232

-2020
>>> e,f = diff()
Введите первое число
1212

Введите второе число
3323

-2111
>>> 

# Дзен

> def – это инструкция (команда) языка программирования Python, позволяющая создавать функцию.
> diff – это имя функции, которое (так же как и имена переменных) может быть почти любым, но желательно осмысленным.
> После в скобках перечисляются параметры функции. Если их нет, то скобки остаются пустыми. Далее идет двоеточие, обозначающее окончание заголовка функции (аналогично с условиями и циклами).
> После заголовка с новой строки и с отступом следуют выражения тела функции. 
> В конце тела функции присутствует инструкция return (может и не быть), которая возвращает значение(я) в основную ветку программы. 
> В данном случае, если бы в функции не было инструкции return, то в основную программу ничего бы не возвращалось, и переменным a и b (c и d, а также e и f) числовые значения не присваивались бы.

> После функции идет, так называемая, основная ветка программы, в которой переменным попарно присваивается результат выполнения вызываемой функции.
# В иных ситуациях, когда функция не возвращает значений, ее вызов не связывается с переменной. (return опеределяет логику обмена данными в программе)
# если return - то данные из фукнции выводятся в основной алгоритм, если нет - то нет, это вопрос логики - нужны ли мне данные из фукнции в алгоритме или нет.

> Выражения тела функции выполняются лишь тогда, когда она вызывается в основной ветке программы
> если функция присутствует в исходном коде, но нигде не вызывается в нем, то содержащиеся в ней инструкции не будут выполнены ни разу. ( подумать над этим )

>>> def summ():                                            # def - команда создания функции  summ() - имя фукнции, () - дополнительных условий нет.
...     Ghost = 1                                          # здесь и далее - переменные и данные которая обрабатывает фукнция
...     Shell = 2
...     Anime = 11
...     x = Ghost + Shell + Anime                          # алгоритм, который проводит фукнция с данными содержащимся в поле фукнции, результату алгоритма назначенна переменная "x"
...     return x                                           # вывод данных содержащихся в переменной "x" в поле основного алгоритма 
... 
>>> x = summ()                                             # присваивание данным содержащимся в фукнции summ() переменной "x"
>>> print(x)                                               # вывод результата на экран.
14
>>> 

Дзен

# Дзен в том, что строка х = summ() соотвествует понятию: "переменная = данные", когда я пишу def summ() - я даю команду "питон, запиши данные в ячейку памяти summ() - переменую этим данным дам потом"
> умный питон пишет и ждёт, когда я присвою этим данным переменную, что бы на выходе получить: " данным в ячейки памяти summ() назначенна переменная Х ".
> при этом я могу использовать комнаду return что бы выводить данные из поля фукнции в поле алгоритма.

# при этом: процесс присваивания данным, содержащимся в фукнции, переменной происходит в основном поле алгоритма - поскольку команда на запись этих данных в фукнцию также дана в основном поле.
> а команда на вывод дынных из поля фукнции лежит внутри фукнции поскольку питон оперирует ими внутри.

Пример

>>> def anime():   
...     ghost = 404     
...     kill_day = 5
...     day = 22
...     ghost = ghost - kill_day * day
...     return ghost
... 
>>> x = anime()
>>> print(x)
294
>>> def anime():   
...     ghost = 404     
...     kill_day = 5
...     day = 22
...     ghost = ghost - kill_day * day
... 
>>> x = anime()
>>> print(x)
None
>>> 

# если не возвращать данные из фукнции - питон возвращает "None", это не является ошибкой - скрипт работает, просто у него нет данных для вывода.

Дзен

# все данные в фукнциях называются локальными, все данные вне фукнций - глобальными

# Правила выбора имен функций полностью аналогичны правилам выбора имен переменных, описанным в предыдущей главе. 
# Список параметров определяет набор значений, которые могут быть переданы функции в качестве исходных данных – параметры перечисляются через запятую.

>>> def one():
...     def two():
...         a = int(input("Введите число"))
...         return a              # a - локальная переменная функции  two(), возвращаю её в стек фукнции one()
...     a = two()                 # присваиваю данным фукнции two() локальную переменную  "a" ( если заменить а на х - работать не будет )
...     i = a + 5                 # произвожу действия с переменной "а" в стеке фукнции one()
...     print(i)
... 
>>> one()                         # вызываю функцию one() в глобальном алгоритме, она запращивает ввод числа с клавиатуру и добавляет к нему 5.
Введите число
11

16
>>> 

>>> def anime():
...     """ Anime story"""        # строка домкументации фукнции, задаёться в тройных кавычках, предназначенная для описания фукнции, может быть прочитана комнадой __doc__ Пример "print anime_div.__doc__"
...     story = 11
...     Major = 1
...     def shell():
...         x = story - Major                # = 10
...         return x
...     x = shell()
...     Ghost = Major * story - x            # Ghost = 11 * 1 - 10
...     print(Ghost)    
... 
>>> anime()                                  # возвращает еденицу
1
>>> 

>>> def anime():
...     """ Anime story"""        # строка домкументации фукнции, задаёться в тройных кавычках, предназначенная для описания фукнции, может быть прочитана комнадой __doc__ Пример "print anime_div.__doc__"
...     story = 11
...     Major = 2
...     Ghost = Major * 11                 # = 22
...     print(Ghost, "anime1")
...     def shell():
...         x = story - Major                # = 9
...         return x                         # возвращаю х в стек фукнции anime()
...     x = shell()
...     Ghost = Major * story - x            #  11 * 2 - 9 = 13
...     print(Ghost, "anime2")
...     print(x, "shell")                    # без этой строки, строка animе() не выведет результат на экран 
... 
>>> anime()                                  # крутой Дзен - фукнция shell() смога прочитать локальные переменные 'story' и 'major' из фукнции anime(), произвести с ними действия и получить переменную "x"
22 anime1
13 anime2
9 shell
>>> 

Параметры и аргументу функций, локальные и глобальные переменные.

> Часто функция используется для обработки данных, полученных из внешней для нее среды (из основной ветки программы). 
> Данные передаются функции при ее вызове в скобках и называются аргументами. 

# Однако, чтобы функция могла "взять"передаваемые ей данные, необходимо при ее создании описать параметры (в скобках после имени функции), представляющие собой переменные. 

def имя функции(параметры )
	тело функции
функция(аргументы)

> Когда функция вызывается, конкретные аргументы подставляются вместо параметров-переменных
> Почти всегда количество аргументов и параметров должно совпадать (хотя можно запрограммировать переменное количество принимаемых аргументов). 
> В качестве аргументов могут выступать как непосредственно значения, так и переменные, ссылающиеся на них.

>>> def calc(a, b):                          # параметр "а" соответствует аргументу num1, параметр "b" соответствует аргументу num2  
...     a = a / 2                            # 10 = 10 / 2
...     b = b + 10                           # 5 = 5 + 10
...     print(a*b)                           # 5*15 =15
... 
>>> num1 = 10
>>> num2 = 5
>>> calc(num1, num2)
75.0
>>> 

# Если записать в IDLE приведенную ниже функцию, и затем попробовать вывести значения переменных, то обнаружится, что некоторые из них почему-то не существуют:


>>> a
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'a' is not defined
>>> b
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'b' is not defined
>>> 

Дзен

> Переменные num1 и num2 не изменили своих первоначальных значений. В функцию передаются копии их значений. Прежние значения из основной ветки программы остались по прежнему связанны с их переменными.

>>> num1
10
>>> num2
5

> А вот переменных a и b оказывается нет и в помине (ошибка "name 'b' is not defined" переводится как "переменная b не определена").
> Эти переменные существуют лишь в момент выполнения функции и называются локальными. В противовес им, переменные num1 и num2 видны не только во внешней ветке, но и внутри функции:

Пример функционала # при наличии двух глобальных переменных алгоритм воспроизводит результат последовательно через вызов функции, переменная может быть и int и str и list (dict -?)  

>>> def anime(shell):
...     n = shell * 5
...     print(n)
... 
>>> shell = 11                              # глобальная переменная: число
>>> anime(shell)
55
>>> shell = "Ghost"                         # глобальная переменная: строка
>>> anime(shell)
GhostGhostGhostGhostGhost
>>> shell = [11,22,33]                      # глобальная переменная: список
>>> anime(shell)
[11, 22, 33, 11, 22, 33, 11, 22, 33, 11, 22, 33, 11, 22, 33]
>>> 

Дзен

>>> def anime(n):                          # n - параметр
...     if n < 3:                          # если параметр "n" - который соотвествует аргументу "a" меньше 3 
...         n = 10*3                       # тогда: параметр "n" - равен 30
...     return n                           # вернуть переменную "n" - в стек ( без ретурна b и связанная с ним фукнция anime(a) - "nontype" )
... 
>>> a = 1                                  # a - аргумент
>>> b = anime(a)
>>> a                                      # обратиться к переменной а
1
>>> b                                      # обратиться к переменной b
30
>>> 

Дзен в истине: " переменная - данные"

# в начале алгоритма у фукнции def anime(n) - нет имени, ей не присвоенная переменная, потому что питон умный
# в случае когда питон обрабатывает алгоритм с фукнцией в которой есть параметры, питон сначала
> прочитает фукнцию
> прочитает параметр в свойствах функции
> прочитает аргумент в основном алгоритме
> вернётся назад к функции, выполнит тело функции по аргументу
> вернётся назад к алгоритму и продолжит его чтение после аргумента
> что питон принесёт с собой из функции - определяет наличие return и логики.

В примере выше:  

# в теле фукнции есть логика, которая формирует данные илогикаа вывода этих данных в глобальный стек
# параметр 'n' принимает значение аргумента 'a' - питон сначала читает пустую фукнцию, потом читает аргумент в глобальном стеке, потом воспроизводит фукнцию по этому аргументу и возвращает "n" в поток
# и только после этого начинает читать глобальный стек дальше в части того, что было написано после аргумента, при этом питон использует данные из функции которые были возвращены в основной поток  

def anime(n):                          # n - параметр
	return n
a = 1                                  # a - аргумент
b = n 

В примере выше я скормил питону через переменную b  новые данные - "anime(a)" и получил конструкцию " переменная b = данные anime(a)"
Дзен в том, что данные глобальной переменной b являются копией данных локальной переменной n - которые были возвращены через return.
При этом имя глобальной переменной может быть любым, локальные переменная "n" - по сути данные, которые нуждаються в переменной
>>> в рамках правила " переменная = данные"
# Через return возвращаются данные, следовательно им можно присваивать любую переменную, однако необходимо помнить о исключении:

Исключение (!) во вложенных фукнциях без параметров нельзя изменять имя переменной возвращаемой через return в поток функции, а в фукнциях с переменными можно.

Пример:

>>> def one():
...     def two():
...         a = int(input("Введите число"))
...         return a              # a - локальная переменная функции  two(), возвращаю её в стек фукнции one()
...     a = two()                 # присваиваю данным фукнции two() локальную переменную  "a" ( если заменить а на х - работать не будет )
...     i = a + 5                 # произвожу действия с переменной "а" в стеке фукнции one()
...     print(i)
... 
>>> one()                         # вызываю функцию one() в глобальном алгоритме, она запращивает ввод числа с клавиатуру и добавляет к нему 5.
Введите число
11

Потому что по сути речь идёт о данных, если представить себе тело фукнций в примере выше, в части " переменная = данные" мы получим следующую картину:

запуск функции:
	запуск подфукнции:
		переменная "а" = " введите данные с клавиатуры"
		выгрузить локальнык данные в поток основной фукнции
	модифицировать локальные данные согласно правила функции
	правила модификации данных
	вывод данных
вызов функции

В этом примере функция оперирует локальными данными, которые фактически не имеют собственных переменных назначенных им писателем, данные просто обрабатываются по потоку.

Моя смог в базовый учебник 

http://younglinux.info/sites/default/files/python_structured_programming.pdf
http://younglinux.info/python/arguments.php

