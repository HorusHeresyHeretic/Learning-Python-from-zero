Глава 6 - с этим артефактом связан файл PyPartVI
1 - 34 не имеют отношения к 6 главе - я пофанился.

Интерлюдия о динамической типизации.

Когда выполняется операция присваивания, такая как a = 3, интерпретатор выполняет ее, хотя перед
этим ему нигде не сообщалось, что a – это имя переменной, или что она представляет объект
целочисленного типа.

Технически это выглядит так:

# Создание переменной.

Переменная (то есть имя), такая как a, создается автоматически, когда в программном коде ей впервые
присваивается некоторое значение. Все последующие операции присваивания просто изменяют значение,
ассоциированное с уже созданным именем. Строго говоря, интерпретатор Python определяет некоторые
имена до запуска программного кода, но вполне допустимо думать, что переменные создаются
первой операцией присваивания.

# Типы переменных.

Переменные не имеют никакой информации о типе или ограничениях, связанных с ним. Понятие типа
присуще объектам, а не именам. Переменные универсальны по своей природе – они всегда являются
всего лишь ссылками на конкретные объекты в конкретные моменты времени.

# Использование переменной.

Когда переменная участвует в выражении, ее имя замещается объектом, на который она в настоящий
момент ссылается, независимо от того, что это за объект. Кроме того, прежде чем переменную
можно будет использовать, ей должно быть присвоено значение – использование
неинициализированной переменной приведет к ошибке.

В итоге складывается следующая картина: переменные создаются при выполнении операции присваивания,
могут ссылаться на объекты любых типов и им должны быть присвоены некоторые значения, прежде чем
к ним можно будет обратиться. Это означает, что от вас не требуется заранее объявлять переменные
в сценарии, но вы должны инициализировать их перед использованием - счетчик, например, должен
быть инициализирован нулевым значением, прежде чем его можно будет наращивать.

>>> a = 3

1. Создается объект, представляющий число 3.

2. Создается переменная a, если она еще отсутствует.

3. В переменную a записывается ссылка на вновь созданный объект, представляющий число 3.

# Переменные и объекты хранятся в разных частях памяти и связаны между собой ссылкой.
# Переменные всегда ссылаются на объекты и никогда – на другие переменные, но крупные объекты могут
 ссылаться на другие объекты (например, объект списка содержит ссылки на объекты, которые включены
 в список).

Эти ссылки на объекты в языке Python так и называются ссылки, то есть ссылки – это своего рода
ассоциативная связь, реализованная в виде указателя на область памяти.Когда бы ни использовалась 
переменная (то есть ссылка), интерпретатор Python автоматически переходит по ссылке от переменной
к объекту. Все на самом деле гораздо проще, чем кажется. В конкретных терминах:

# (По факту a = 3 следует читать так: на объект (3) ссылаеться ссылка по имени (а).)

• Переменные 
– это записи в системной таблице, где предусмотрено место для хранения ссылок на объекты.

• Объекты 
– это области памяти с объемом, достаточным для представления значений этих объектов.

• Ссылки
 – это автоматически разыменовываемые указатели на объекты.

 ## так как ссылки при использовании всегда автоматически разыменовываются, вы никак не сможете
    использовать саму ссылку – эта особенность ликвидирует огром ный пласт ошибок, которые
	можно допустить в языке C.

Всякий раз, по крайней мере концептуально, когда в сценарии в результате выполнения выражения
создается новое значение, интерпретатор Python создает новый объект (то есть выделяет область
памяти), представляющий это значение. 

Внутренняя реализация интерпретатора с целью оптимизации кэширует и повторно использует некоторые
типы неизменяемых объектов, такие как малые целые числа и строки (каждый 0 в действительности не
является новой областью в памяти;)

### С технической точки зрения объекты имеют более сложную структуру, чем просто пространство в
памяти, необходимое для хранения значения. Каждый объект имеет два стандартных поля: описатель
типа, используемый для хранения информации о типе объекта, и счетчик ссылок, используемый для
определения момента, когда память, занимаемая объектом, может быть освобождена.

# Дзен.

А вот тут Лутц действительно силен и хорошо объяснет - общая идея ясна: Питон быстрый - потому что
а) разименовывает ссылки (по факту в коде минимум ссылок на объекты)
б) кеширует объекты (по факту в коде минимум объектов)

Теперь понятно как это всё работает через байт-код: Питон пишет в системную таблицу ссылки и как
только счётчик ссылок какого либо объекта показывает 0 - Питон разименовывает ссылку на него и
кеширует системную таблицу. 

# Едем дальше - Информация о типе хранится в объекте, но не в переменной (потому что переменная
 это ссылка на объет, которую Питон стремиться разименовать и не использовать больше).

>>> a = 3      # Это целое число
>>> a = "spam" # Теперь это строка
>>> a = 1.23   # Теперь это вещественное число

Тип – это свойство объекта, а не имени. В предыдущем листинге просто изменяется ссылка на объект.
Так как переменные не имеют типов, мы в действительности не изменяем типы переменных – мы просто
записываем в переменные ссылки на объекты других типов. На самом деле, все, что можно сказать о
переменных в языке Python – это то, что они ссылаются на конкретные объекты в конкретные 
моменты времени.

С другой стороны, объекты знают, к какому типу они относятся, – каждый объект содержит поле, в 
котором хранится информация о его типе. Целочисленный объект 3, например будет содержать
значение 3 плюс информацию, которая сообщит интерпретатору Python, что объект является
целым числом (строго говоря – это указатель на объект с названием int, которое играет
роль имени целочисленного типа). Описатель типа для строки ‘spam’ указывает на
строковый тип (с именем str). Поскольку информация о типе хранится в объектах,
ее не нужно хранить в переменных.

# Едем дальше, Объекты уничтожаются автоматически (!) (потому что ссылки на них разименовываються)

>>> a = 3
>>> a = "spam"

Дело в том, что всякий раз, когда имя ассоциируется с новым объектом, интерпретатор освобождает
память, занимаемую предыдущим объектом (если на него не ссылается какое-либо другое имя или
объект). Такое автоматическое освобождение памяти, занимаемой объектами, называется сборкой
мусора (garbage collection).

>>> x = 42
>>> x = ‘shrubbery’ # Освобождается объект 42 (если нет других ссылок)
>>> x = 3.1415		# Теперь освобождается объект ‘shrubbery’
>>> x = [1,2,3]	    # Теперь освобождается объект 3.1415

Первое, что следует отметить, – каждый раз с именем x связывается объект другого типа. Снова, хотя
в действительности это не так, возникает ощущение изменения типа переменной x с течением времени.
Это не так - так как имена – это всеголишь ссылки на объекты.

### Во-вторых, следует помнить, что попутно уничтожаются ссылки на объекты.

Каждый раз, когда имя x ассоциируется с новым объектом, интерпретатор освобождает пространство,
занятое прежним объектом. Например, когда с именем x связывается строка ‘shrubbery’, объект 42
немедленно уничтожается (при условии, что на него не ссылается никакое другое имя), а 
пространство памяти, занимаемое объектом, возвращается в пул свободной памяти для по-
вторного использования в дальнейшем.

Достигается это за счет того, что в каждом объекте имеется счетчик ссылок, с помощью которого 
интерпретатор следит за количеством ссылок, указывающих на объект в настоящий момент времени.
Как только (и именно в этот момент) значение счетчика достигает нуля, память, занимаемая
объектом, автоматически освобождается. В предыдущем листинге мы исходили из предполо
жения, что всякий раз, когда имя x ассоциируется с новым объектом, счетчик
предыдущего объекта уменьшается до нуля, заставляя интерпретатор осво-
бождать память.

(я был прав)

# Дзен.

Строго говоря, механизм сборки мусора в основном опирается на счетчики ссылок, как было описано
выше, однако он способентакже обнаруживать и удалять объекты с циклическими ссылками. Эту
особенность можно отключить, если вы уверены, что в программе не создаются объекты с
циклическими ссылками, но по умолчанию она включена.

Поскольку ссылки реализованы в виде указателей, существует возможность создать в объекте ссылку
на самого себя или на другой объект, который ссылается сам на себя. Дополнительную информацию 
об обнаружении циклических ссылок можно найти в описании модуля gc, в справочном руководстве 
по стандартной библиотеке языка Python.

# Разделяемые ссылки

>>> a = 3
>>> b = a 

Вторая инструкция вынуждает интерпретатор создать переменную b и использовать для инициализации
переменную a, при этом она замещается объектом, на который ссылается (3), и b превращается в
ссылку на этот объект. В результате переменные a и b ссылаются на одини тот же объект (то
есть указывают на одну и ту же область в памяти). В языке Python это называется 
разделяемая ссылка – несколько имен ссылаются на один и тот же объект.

По факут читать: (a) является ссылкой на объект (3) и (b) является ссылкой на объект (3)

>>> a = 3
>>> b = a
>>> a = "spam"

Как во всех случаях присваивания в языке Python, в результате выполнения этой инструкции создается
новый объект, представляющий строку "spam", а ссылка на него записывается в переменную a. Однако
эти действия не оказы вают влияния на переменную b – она по-прежнему ссылается на первый объект,
целое число 3.

# По факут читать: (a) является ссылкой на объект ("spam") и (b) является ссылкой на объект (3)
# Плюс - согласно правилу разименования ссылок - (a) не является ссылкой на объект (3)

>>> a = 3
>>> b = a
>>> a = a + 2
>>> a
5
>>> b
3
>>> 

В этой последовательности происходят те же самые события: интерпретатор Python создает переменную
a и записывает в нее ссылку на объект 3. После этого он создает переменную b и записывает в нее
ту же ссылку, что хранится в переменной a, как показано на рис.  Наконец, последняя инструкция
создает совершенно новый объект (в данном случае – целое число 5, которое является результатом
выполнения операции сложения). Это не приводит к изменению переменной b. В действительности 
нет никакого способа перезаписать значение объекта 3 – как говорилось в главе 4, целые 
числа относятся к категории неизменяемых, и потому эти объекты невозможно изменить.

Переменные в языке Python, в отличие от других языков программирования, всегда являются указателями
на объекты, а не метками областей памяти, доступных для изменения: запись нового значения в
переменную не приводит к изменению первоначального объекта, но приводит к тому, что 
переменная начинает ссылаться на совершенно другой объект. В результате инструкция
присваивания может воздействовать только на одну переменную. Однако когда в 
уравнении появляются изменяемые объекты и операции, их изменяющие,
картина несколько меняется

# Едем дальше: Разделяемые ссылки и изменяемые объекты

>>> L1 = [1,2,3]
>>> L2 = L1
>>> L1[0] = 24
>>> L1
[24, 2, 3]
>>> L2
[24, 2, 3]
>>> 

Здесь мы не изменяем сам объект L1, изменяется компонент объекта, на который ссылается L1. Данное
изменение затронуло часть самого объекта списка. Поскольку объект списка разделяется разными
переменными (ссылки на него находятся в разных переменных), то изменения в самом списке
затрагивают не только L1, изменения обнаруживаются также в переменной L2, потому что 
она ссылается на тот же самый объект, что и L1. Здесь мы фактически не изменяли L2,
но значение этой переменной изменилось.

# Лутц вещает про то, что изменение объекта не затрагивает ссылку - она либо есть в системной 
таблице, либо счётчик объекта достиг 0 и ссылка была разименована. В примере есть 2 ссылки на 
один и тотже объект в одной и тойже области памяти - [1,2,3] , измненеие части этого объекта 
никак не повлияло на счётчик ссылок - существование 2х ссылок по объекту попрежнему в памяти.

# Дзен.

Это – поведение по умолчанию: если вас оно не устраивает, можно потребовать от интерпретатора, 
чтобы вместо создания ссылок он выполнял копирование объектов. Скопировать список можно
несколькими способами, включая встроенную функцию list и модуль copy из стандартной
библиотеки. Однако самым стандартным способом копирования является получение среза
от начала и до конца списка.

# Лутц вещает, что теперь - когда вы понимаете логическую модель языка в части фукнционирования
системной таблицы, вы подозреваете, что для сохранения объекта L2 при изменении L1 необходимо 
озаботиться сохранением ссылкина L2.

>>> L1 = [1,2,3]
>>> L2 = L1[:]		# создаёться копия списка L1 и как следствие копия сслыки на объект L1
>>> L1[0] = 24
>>> L1
[24, 2, 3]
>>> L2
[1, 2, 3]
>>> 

Здесь изменения в L1 никак не отражаются на L2, потому что L2 ссылается на копию объекта, на
который ссылается переменная L1. То есть эти переменные указывают на различные области памяти.

# Дзен - сохраняй ссылку через copy()

Способ, основанный на получении среза, неприменим в случае с другим изменяемым базовым типом – со
словарями, потому что словари не являются последовательностями. Чтобы скопировать словарь, необхо-
димо воспользоваться методом X.copy(). Следует также отметить, что модуль copy из стандартной
библиотеки имеет в своем составе универсальную функцию, позволяющую копировать объекты любых
типов, включая вложенные структуры (например, словари с вложенными списками):

>>> anime = {"Ghost":"Major","Bato":"Major Friend","11":"Crazy Major Friends","Godo":"Evil Enemy"}
>>> import copy
>>> a = copy.copy(anime)
>>> b = copy.deepcopy(anime)
>>> a
{'Bato': 'Major Friend', '11': 'Crazy Major Friends', 'Godo': 'Evil Enemy', 'Ghost': 'Major'}
>>> b
{'Bato': 'Major Friend', '11': 'Crazy Major Friends', 'Godo': 'Evil Enemy', 'Ghost': 'Major'}
>>> 

# в чём глубокий Дзен поверхностой копии от полной - пока не ясно. см.главы 8-9

КМК Дзен описан достаточно ёмко - не нравиться что возвращает интерпритатор: копируй ссылки сам.

# Разделяемые ссылки и равенство (срыв покровов с процесса сборки мусора)

>>> x = 42
>>> x = "shrubbery" # Объект 42 теперь уничтожен?

Так как интерпретатор Python кэширует и повторно использует малые целые числа и небольшие строки,
о чем уже упоминалось ранее, объект 42 скорее всего не будет уничтожен. Он,вероятнее всего,
останется в системной таблице для повторного использования, когда вы вновь сгенерируете 
число 42 в программном коде. Однако большинство объектов уничтожаются немедленно, как
только будет потеряна последняя ссылка, особенно те, к которым применение механизма
кэширования не имеет смысла.

>>> L = [1,2,3]
>>> M = L                         # M и L – ссылки на один и тот же объект
>>> L == M                        # True - одно и тоже значение
True
>>> L is M                        # True - один и тот же объект
True
>>> 

Первый способ, основанный на использовании оператора ==, проверяет, равны ли значения объектов. В
языке Python практически всегда используется именно этот способ. Второй способ, основанный на
использовании оператора is, проверяет идентичность объектов. Он возвращает значение True, 
только если оба имени ссылаются на один и тот же объект, вследствие этого он является
более строгой формой проверки равенства.

# кмк is - проверяет ссылки

На самом деле оператор is просто сравнивает указатели, которые реализуют ссылки, и тем самым может
использоваться для выявления разделяемых ссылок в программном коде. Он возвращает значение False,
даже если имена ссылаются на эквивалентные, но разные объекты, как, например, в следующем
случае, когда выполняются два различных литеральных выражения:

>>> L = [1,2,3]
>>> M = [1,2,3]                   # M и L – ссылаються на разные объекты
>>> L == M                        # True - одно и тоже значение
True
>>> L is M                        # False - разные объекты
False
>>> 

>>> L = 42
>>> M = 42                       #  M и L – ссылаються на разные объекты, но здесь работает кеширование
>>> L == M                       #  True
True
>>> L is M                       #  True  - кеширование в действии
True
>>> 

В этом примере переменные X и Y должны быть равны (==, одно и то же значение), но не эквивалентны
(is, один и тот же объект), потому что было выполнено два разных литеральных выражения. Однако
из-за того, что малые целые числа и строки кэшируются и используются повторно, оператор is 
сообщает, что переменные ссылаются на один и тот же объект.


# Дзен в том что список это НЕ кешируемый объект а объекты класса INT и STR кешируются.

###

Фактически если вы действительно хотите взглянуть на работу внутренних механизмов, вы всегда можете
запросить у интерпретатора количество ссылок на объект: функция getrefcount из стандартного модуля
sys возвращает значение поля счетчика ссылок в объекте. Когда я, например, запросил количество
ссылок на целочисленный объект 1 в среде разработки IDLE, я получил число 837 (большая 
ссылок была создана системным программным кодом самой IDLE, а не мною):

>>> L = 42
>>> M = 42                       #  M и L – ссылаються на разные объекты, но здесь работает кеширование
>>> L == M                       #  True
True
>>> L is M                       #  True  - кеширование в действии
True
>>> import sys
>>> sys.getrefcount(L)
14
>>> sys.getrefcount(M)
14
>>> sys.getrefcount(42)
15
>>> 

# Дзен

Такое кэширование объектов и повторное их использование не будет иметь большого значения для вашего
программного кода (если вы не используете оператор is!). Так как числа и строки не могут изменяться,
совершенно неважно, сколько ссылок указывает на один и тот же объект. Однако такое поведение
наглядно демонстрирует один из реализуемых Python способов оптимизации, направленной на
повышение скорости выполнения.

### А ещё я подозреваю что при кеширование объектов - кешируються и ссылки на них, это было бы 
логичной схемой оптимизации системной таблицы.

PartVII с207.

# STR - Лутц вешает про строки.

Строки в языке Python играют ту же роль, что и массивы символов в языке C, но являются инструментом
более высокого уровня, нежели простой массив символов. В отличие от C, строки в языке Python об-
ладают мощным набором средств для их обработки. Кроме того, в отличие от таких языков, как C, в
языке Python отсутствует специальный тип для представления единственного символа, поэтому
в случае необходимости используются односимвольные строки.

В состав Python входит множество инструментов для работы со строками – полное описание приводится
в справочном руководстве по стандартной библиотеке Python.

# Учим основы основ, радуемся что ранее читали учебник Шапошникова.

Если вам действительно потребуется знание расширенных концепций рабо ты со строками, таких как 
альтернативные наборы символов или упакованные двоичные данные и файлы, после знакомства с
 материалом, который приводится здесь, обращайтесь к главе 36.

# Литералы строк

• Строки в апострофах: ‘spa”m’

• Строки в кавычках: “spa’m”

• Строки в тройных кавычках: ‘’’... spam ...’’’, “””... spam ...”””

• Экранированные последовательности: “s\tp\na\0m”

• Неформатированные строки: r”C:\new\test.spm”

• Строки байтов в версии 3.0 (глава 36): b’sp\x01am’

• Строки символов Юникода, только в версии 2.6 (глава 36): u’eggs\u0020spam’

Варианты представления строк в апострофах и кавычках являются наиболее типичными, остальные играют
особую роль.

# Дзен - Строки в апострофах и в кавычках – это одно и то же.

Кавычки и апострофы, окружающие строки, в языке Python являются взаимозаменяемыми. Строковые 
литералы можно заключать как в апострофы, так и в кавычки – эти две формы представления 
строк ничем не отличаются, и обе они возвращают объект того же самого типа.

>>> "anime" 'anime'
'animeanime'
>>> 

Причина наличия двух вариантов состоит в том, чтобы позволить вставлять в литералы символы кавычек
и апострофов, не используя для этого символ обратного слеша. Вы можете вставлять апострофы в
строки, заключенные в кавычки, и наоборот:

>>> ‘knight”s’, “knight’s”
(‘knight”s’, “knight’s”)

Между прочим, Python автоматически объединяет последовательности строковых литералов внутри 
выражения, хотя нет ничего сложного в том, чтобы добавить оператор + между литералами и
вызвать операцию конкатенации явно:

>>> title = “Meaning “ ‘of’ “ Life” # Неявная конкатенация
>>> title
‘Meaning of Life’

Обратите внимание, если добавить запятые между этими строками, будет получен кортеж, а не строка.
Кроме того, заметьте, что во всех этих примерах интерпретатор предпочитает выводить строки в 
апострофах, если их нет внутри строки. Кавычки и апострофы можно вставлять в строки, 
экранируя их символом обратного слеша:

>>> ‘knight\’s’, “knight\”s”
(“knight’s”, ‘knight”s’)

с 211 - экранирование.

Экранированные последовательности представляют служебные символы.

Экранированные последовательности позволяют вставлять в строки символы, которые сложно ввести с
клавиатуры. В конечном строковом объекте символ \ и один или более следующих за ним символов
замещаются единственным символом, который имеет двоичное значение, определяемое экранированной
последовательностью.

>>> s = ‘a\nb\tc’

Последовательность \n образует единственный символ – байт, содержащий двоичное значение кода
символа новой строки в используемом наборе символов (обычно ASCII-код 10). Аналогично
последовательность \t замещается символом табуляции. 

Как будет выглядеть такая строка при печати, зависит от того, как она выводится. Функция
автоматического вывода в интерактивной оболочке отобразит служебные символы как
экранированные последовательности, а инструкция print будет интерпретировать их:

>>> s
‘a\nb\tc’
>>> print(s)
a

b c

Чтобы окончательно убедиться, сколько байтов входит в эту строку, можно воспользоваться встроенной
функцией len – она возвращает фактическое число байтов в строке независимо от того, как строка
отображается на экране:

>>> len(s)
5

Длина этой строки составляет пять байтов: она содержит байт ASCII-символа a, байт символа новой 
строки, байт ASCII-символа b и так далее (байт символа b, байт символа пробела, байт символа c).
Обратите внимание, что символы обратного слеша не сохраняются в памяти строкового объекта – они
используются лишь для того, чтобы вынудить интерпретатор сохранить значения байтов в строке.

>>> anime = "Ghost\nb\tc"
>>> anime                                 # возвращает  'Ghost\nb\tc'
'Ghost\nb\tc'
>>> print(anime)                          # Ghost
Ghost
b	c
>>>                                       # b	c
... len(anime)
9
>>> 

# 9 байтов потому что 3 пробела и 7 символов (2 символа b - это один и тотже байт)

# Хинт: Некоторые экранированные последовательности позволяют указывать абсолютные двоичные
значения в байтах строк. Пример строки из пяти символов, содержащей два нулевых байта:

>>> s = ‘a\0b\0c’
>>> s
‘a\x00b\x00c’
>>> len(s)
5
>>> print(s)
a b c

В языке Python нулевой байт (символ null) не является признаком завершения строки, как в языке C.
Интерпретатор просто сохраняет в памяти как текст самой строки, так и ее длину. Фактически в
языке Python вообще нет символа, который служил бы признаком завершения строки.

anime = "Ghost\0in\0the\0shell"       # \0 это null 
>>> anime
'Ghost\x00in\x00the\x00shell'
>>> print(anime)
Ghost                                 

Ниже приводится строка, полностью состоящая из экранированных кодов, – двоичные значения 1 и 2
(записаны в восьмеричной форме), за которыми следует двоичное значение 3 (записано в 
шестнадцатеричной форме):

>>> s = "\001\002\x03"
>>> s
'\x01\x02\x03'
>>> len(s)
3
>>> print(s)

>>> 

# и которая возвращает пустоту по команде print(s)

Интерпретатор Python отображает непечатаемые символы в шестнадцатеричном представлении, независимо
от того, в каком виде они были указаны внутри литерала. Вы без ограничений можете комбинировать
абсолютные экранированные значения с другими типами экранированных последовательностей.

>>> S = “s\tp\na\x00m”
>>> S
‘s\tp\na\x00m’
>>> len(S)
7
>>> print(S)
s p
a m

# строка содержит символы “spam”, символ табуляции и символ новой строки, а также нулевой символ,
заданный в шестнадцатеричном представлении.

Это обстоятельство (отсуствие ограничений на комбнации) приобретает особую важность, когда возникает 
необходимость обрабатывать на языке Python файлы с двоичными данными. Поскольку содержимое таких
файлов в сценариях на языке Python представлено строками, вы без труда сможете обрабатывать
двоичные файлы, содержащие байты с любыми двоичными значениями.

# Дзен

Если вам требуется работать с файлами, содержащими двоичные данные, главное отличие в работе с ними
заключается в том, что открывать их нужно в режиме двоичного доступа (добавляя к флагу режима
открытия флаг b, например “rb”, “wb” и такдалее). В Python 3.0 содержимое двоичных файлов
интерпретируется как коллекция строк типа bytes, которые по своим возможностям
напоминают обычные строки.

Кроме того, обратите внимание на модуль struct, который будет описан в главе 9, с помощью которого
можно выполнять интерпретацию двоичных данных, загруженных из файла. Расширенное описание
принципов работы с двоичными файлами и строками байтов приводится в главе 36.

# Хинт

Если интерпретатор не распознает символ после \ как корректный служебный символ, он просто 
оставляет символ обратного слеша в строке:

>>> x = “C:\py\code” # Символ \ сохраняется в строке
>>> x
‘C:\\py\\code’
>>> len(x)
10

Однако если вы не способны держать в памяти всю табл. 7.2, вам не следует полагаться на описанное
поведение.1 Чтобы явно добавить символ обратного слеша в строку, нужно указать два символа
обратного слеша, идущие подряд (\\ – экранированный вариант представления символа \), или
использовать неформатированные строки, которые описываются в следующем разделе.

# Лутц троллит:

Мне доводилось встречать людей, которые помнили всю таблицу или большую ее часть. Я мог бы
посчитать их ненормальными, но тогда мне пришлось бы себя тоже включить в их число. 
>>> "таблица" описана кодом в PartVI 167 - 222.

# Неформатированные строки подавляют экранирование.

Иногда зарезервированная экранированная последовательность может порождать неприятности. Очень
часто, например, можно увидеть, как начинающие программисты пытаются открыть файл, передавая
аргумент с именем файла, который имеет примерно следующий вид:

myfile = open("C:\new\text.dat", "w")

Проблема здесь заключается в том, что последовательность \n интерпретируется как символ новой 
строки, а последовательность \t замещается символом табуляции. В результате функция open 
будет пытаться открыть файл с именем C:(newline) ew(tab)ext.dat, причем безуспешно.

Здесь как бы 2 символа экранирования: \n \t

Именно в таких случаях удобно использовать неформатированные строки. Если перед кавычкой,
открывающей строку, стоит символ r (в верхнем или в нижнем регистре), он отключает
механизм экранирования.

>>> myfile = open("C:\new\text.dat", "w") # не правильно 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
OSError: [Errno 22] Invalid argument: 'C:\new\text.dat'

>>> myfile = open(r"C:\new\text.dat", "w") # правильно
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
FileNotFoundError: [Errno 2] No such file or directory: 'C:\\new\\text.dat'
>>> 

Как вариант, учитывая, что два идущих подряд символа обратного слеша интерпретируются как один
символ, можно просто продублировать символы обратного слеша:

myfile = open("C:\\new\\text.dat", "w")

>>> myfile = open("C:\\new\\text.dat", "w")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
FileNotFoundError: [Errno 2] No such file or directory: 'C:\\new\\text.dat'

# Интерпретатор оперирует двойными \\ - так что и нам сам бог велел так делать.

Сам интерпретатор Python в определенных случаях использует удваивание обратного слеша при выводе 
строк, содержащих обратный слеш:

>>> path = r"C:\new\text.dat"
>>> path
'C:\\new\\text.dat'
>>> print(path)
C:\new\text.dat
>>> len(path)
15

Так же как и в случае с числами, при выводе результатов в интерактивной оболочке по умолчанию
используется такой формат представления, как если быэто был программный код, отсюда и
экранирование символов обратного слеша.

Инструкция print обеспечивает более дружественный формат, в котором каждая пара символов
обратного слеша выводится как один символ. Чтобы проверить, что дело обстоит именно так,
можно проверить результат с помощью встроенной функции len, которая возвращает число
байтов в строке независимо от формата отображения. Если посчитать символы в выводе
инструкции print(path), можно увидеть, что каждому символу обратного слеша соответ-
ствует один байт, а всего строка содержит 15 символов.

# Предупреждение

Несмотря на свое предназначение, даже неформатированная строка не может заканчиваться единственным
символом обратного слеша, потому что обратный слеш в этом случае будет экранировать следующий за
ним символ кавычки – вы по-прежнему должны экранировать кавычки внутри строки.

Конструкция r”...\” не является допустимым строковым литералом – неформатированная строка не может
заканчиваться нечетным количеством символов обратного слеша.

Если необходимо, чтобы неформатированная строка заканчивалась символом обратного слеша, можно
добавить два символа и затем удалить второй из них (r"1\nb\tc\\"[:-1]), добавить один
символ вручную (r"1\nb\tc" + "\\") или использовать обычный синтаксис строковых
литералов и дублировать все символы обратного слеша ("1\\nb\\tc\\").

Во всех трех случаях получается одна и та же строка из восьми символов, содержащая три обратных
слеша.

# КМК самое првильное - дублировать слеши.

>>> anime = "\Ghost in the shell\"
  File "<stdin>", line 1
    anime = "\Ghost in the shell\"
                                 ^
SyntaxError: EOL while scanning string literal

>>> anime = "\\Ghost in the shell\\"
>>> anime
'\\Ghost in the shell\\'
>>> print(anime)
\Ghost in the shell\
>>> 

# Тройные кавычки, многострочные блоки текста

Формат "блочной строки"-используется для определения многострочных блоков текста в программном коде.
Литералы в этой форме начинаются с трех идущих подряд кавычек (или апострофов), за которыми может
следовать произвольное число строк текста, который закрывается такими же тремя кавычками. Внутри
такой строки могут присутствовать и кавычки, и апострофы, но экранировать их не требуется – 
строка не считается завершенной, пока интерпретатор не встретит три неэкранированные
кавычки того же типа, которые начинают литерал.

Пример:

>>> anime = """Ghost in the shell
... Stand Alone Complex
... Major"""
... 
>>> anime                               
'Ghost in the shell\nStand Alone Complex\nMajor'
>>> print(anime)
Ghost in the shell
Stand Alone Complex
Major
>>> 

Эта строка состоит из трех строк текста (в некоторых системах строка приглашения к вводу изменяется
на ..., когда ввод продолжается на следующей линии; среда IDLE просто переводит курсор на следующую
линию). Интерпретатор собирает блок текста, заключенный в тройные кавычки, в одну строку,
добавляя символы новой строки (\n) там, где в программном коде выполнялся переход на
новую строку. 

Обратите внимание, что в результате у второй строки имеется ведущий пробел, а у третьей – нет, то
есть, что вы в действительности вводите, то и получаете. Чтобы увидеть, как в реальности
интерпретируется строка с символами новой строки, воспользуйтесь инструкцией print:

# Дзен

Строки в тройных кавычках удобно использовать, когда в программе требуется ввести многострочный
текст, например чтобы определить многострочный текст сообщения об ошибке или код разметки
на языке HTML или XML. Вы можете встраивать такие блоки текста прямо в свои сценарии,
не используя для этого внешние текстовые файлы или явную операцию конкатенации
и символы новой строки.

Наконец, иногда тройные кавычки являются ужасающим, хакерским спосо бом временного отключения строк
программного кода во время разработки (Хорошо, хорошо! На самом деле это совсем не так ужасно, а
просто довольно распространенная практика). Если вам потребуется отключить несколько строк 
программного кода и запустить сценарий снова, просто вставьте по три кавычки до и после
нужного блока кода, как показано ниже:

>>> anime = 1
>>> """
... anime = 2
... """
... 
'\nanime = 2\n'
>>> ghost = anime + 1
>>> print(ghost)
2
>>> 

При работе интерпретатор вынужден создавать строку из строк программного кода, отключенных таким
способом, но, скорее всего, это слабо сказывается на производительности. В данном случае строку

'\nanime = 2\n'

В случае крупных блоков программного кода использовать этот прием гораздо удобнее, чем вставлять
символы решетки в начале каждой строки, а затем убирать их. 

# Строки в действии.

Лутц вещает про операции коннетации и повторения.

>>> "Ghost in the shell" + "stand Alone Complex" 
'Ghost in the shellstand Alone Complex'
>>> "Ghost in the shell" * 4
'Ghost in the shellGhost in the shellGhost in the shellGhost in the shell'
>>> len("Ghost in the shell")
18
>>> print("Major" * 10)
MajorMajorMajorMajorMajorMajorMajorMajorMajorMajor

Операция повторения на первый взгляд выглядит несколько странно, но она очень удобна в очень
широком диапазоне применений. Например, чтобы вывести строку из 10 Майоров можно самому
сосчитать до 10, а можно возложить эту работу на плечи интерпретатора:

Допускается выполнять обход элементов строки в цикле, используя инструкцию for, и проверять
вхождение подстроки в строку с помощью оператора выражения in, который, по сути, выполняет 
операцию поиска. В случае поиска подстрок оператор in напоминает метод str.find(), который
рассматривается ниже, в этой же главе, – с тем отличием, что он возвращает логический
результат, а не позицию подстроки в строке:

>>> anime = "Ghost in the shell"
>>> for c in anime: print(c, end="")             
Ghost in the shell
>>> for c in anime: print(c, end="  ") 
... 
G  h  o  s  t     i  n     t  h  e     s  h  e  l  l  
>>> "l" in anime
True
>>> "a" in anime
False

Оператор цикла for присваивает переменной очередной элемент последовательности (в данном случае – 
строки) и для каждого элемента выполняет одну или более инструкций. В результате переменная (c)
превращается в своего рода курсор, который постепенно перемещается по строке.

# Доступ по индексам и извлечение подстроки

Лутц вещает про индексы и срезы

Так как строки определены как упорядоченные коллекции символов, мы мо жем обращаться к элементам 
строк по номерам позиций. В языке Python символы извлекаются из строк с помощью операции
индексирования – указанием числового смещения требуемого компонента в квадратных скобках
после имени строки. В результате операции вы получаете строку, состоящую из одного
символа, находящегося в указанной позиции.

>>> anime = "Ghost in the shell"
>>> anime[0], anime[-2]                           
('G', 'l')
>>> anime[1:3], anime [1:], anime[:-1]
('ho', 'host in the shell', 'Ghost in the shel')
>>> 

В первой строке определяется строка из 18 символов и связывается с именем anime. В следующей
строке выполняются две операции доступа к элементам по индексам: anime[0] возвращает элемент
со смещением 0 от начала (односимвольную строку ‘G’), а anime[-2] возвращает элемент со 
смещением 2 от конца (что эквивалентно смещению (18 + (-2)) от начала).

Последняя строка в предыдущем примере демонстрирует операцию извлечения среза (slicing). Получение
среза можно считать некоторой формой синтаксического анализа, особенно при работе со строками,
- она позволяет извлекать целые участки (подстроки) за одно действие. Операция получения среза
может использоваться для извлечения столбцов данных, обрезания ведущихи завершающих блоков
текста и тому подобного. 

# Срез по Лутцу

Когда производится индексирование объекта последовательности, такого как строка, парой смещений,
разделенных двоеточием, интерпретатор Python возвращает новый объект, содержащий непрерывную
область, определяемую парой смещений. Значение смещения слева от двоеточия обозначает левую 
границу (включительно), а справа – верхнюю границу (она не входит в срез). Интерпретатор
извлекает все элементы от нижней границы до верхней, но верхняя граница в срез не
включается. Если левая и правая граница опущены, по умолчанию принимаются 
значения, равные 0 и длине объекта соответственно, из которого 
извлекается срез. 

Например, выражение anime[1:3] вернет элементы со смещениями 1 и 2. То есть будут извлечены второй
и третий элементы, и операция остановится перед четвертым элементом со смещением, равным 3.

Выражение anime[1:] вернет все элементы, расположенные за первым, – за значение верхней границы,
которая в выражении опущена, по умолчанию принимается длина строки.

Наконец, выражение anime[:-1] вернет все элементы, кроме последнего, – за значение нижней границы
по умолчанию принимается 0, а индекс –1 соответствует последнему элементу, который 
в срез не включается.

• Операция индексирования (anime[i]) извлекает компоненты по их смещениям:

• Первый элемент имеет смещение 0.

• Отрицательные индексы определяют смещения в обратном порядке – от конца, или справа.

• Выражение anime[0] извлекает первый элемент.

• Выражение anime[-2] извлекает второй с конца элемент (так же, как и выражение anime[len(S)-2]).

• Операция извлечения подстроки (anime[i:j]) извлекает непрерывный раздел последовательности:

• Элемент с индексом, равным верхней границе, не включается в срез.

• Если границы не указаны, по умолчанию они принимаются равными 0 и длине последовательности.

• Выражение anime[1:3] извлекает элементы со смещениями от 1 до 3 (не включая элемент со смещением 3).

• Выражение animeS[1:] извлекает элементы, начиная со смещения 1 и до конца (длина последовательности).

• Выражение anime[:3] извлекает элементы, начиная со смещения 0 и до 3 (не включая его).

• Выражение anime[:-1] извлекает элементы, начиная со смещения 0 и до последнего (не включая его).

• Выражение anime[:] извлекает элементы, начиная со смещения 0 и до кон ца, – это эффективный способ
создать поверхностную копию последовательности anime.

Последний пункт списка – это самый обычный трюк: с его помощью создается полная поверхностная копия
объекта последовательности, то есть объект с тем же значением, но расположенный в другой области
памяти.

>>> anime[:3], anime[:]
('Gho', 'Ghost in the shell')

# Не зря учил Шапошникова.

# Расширенная операция извлечения подстроки: третий предел (Лутц вешает про шаг среза)

Величина шага добавляется к индексу каждого извлекаемого элемента. Полная форма записи операции
извлечения подстроки теперь выглядит так: X[I:J:K]. Она означает: «Извлечь все элементы после-
довательности X, начиная со смещения I, вплоть до смещения J-1, с шагом K».

Третий предел, K, по умолчанию имеет значение 1, именно по этой причине в обычной ситуации
извлекаются все элементы среза, слева направо. Однако если явно указать значение третьего
предела, его можно использовать, чтобы пропустить некоторые элементы или полностью
изменить их порядок.

Например, выражение X[1:10:2] вернет каждый второй элемент последовательности X в диапазоне
смещений от 1 до 9 – то есть будут выбраны элементы со смещениями 1, 3, 5, 7 и 9. Как 
правило, по умолчанию первый и второй пределы принимают значения 0 и длину 
последовательности соответственно, поэтому выражение X[::2] вернет каждый
второй элемент от начала и до конца последовательности:

>>> anime = "Ghost in the shell"
>>> anime[1:10:2], anime[::2]
('hs nt', 'Goti h hl')
>>>

Можно также использовать отрицательное значение шага. Например, выражение “hello”[::-1] вернет
новую строку “olleh”. Здесь первые две границы получают значения по умолчанию – 0 и длина 
последовательности, а величина шага, равная -1, указывает, что срез должен быть выбран в
обратном порядке – справа налево, а не слева направо. В результате получается
перевернутая последовательность:

>>> anime = "Ghost in the shell"
>>> anime[::-1]
'llehs eht ni tsohG'
>>> 

При использовании отрицательного шага порядок применения первых двух границ меняется на 
противоположный. То есть выражение S[5:1:-1] извлечет элемент со 2 по 5 в обратном порядке 
(результат будет содержать элементы по- следовательности со смещениями 5, 4, 3 и 2):

>>> anime = "Ghost in the shell"
>>> anime[5:1:-1], anime[5:1:1]
(' tso', '')
>>> 

# Хинт

Далее в этой книге мы также узнаем, что операция извлечения среза эквивалентна операции
индексирования, в которой в качестве индекса используется специальный объект среза,
что очень важно для разработчиков классов, которым требуется реализовать поддержку
обеих операций:

c 223 подумать над slice

# (!) Slice object

А ещё в Питон можно создавать объекты среза с помощью встроенной фукнции str[slice(i:j)]

>>> "Ghost in the shell"[slice(1,3)]
'ho'
>>> 

В теории "ho" - это объект, на который должна существовать ссылка в системной таблице,
на практике это фактически класс объектов который можно (и нужно передавать фукнции):

Выглядит так, когда я пишу:

print("Ghost in the shell"[3:5])

интерпретатор технически пишет:

print "Ghost in the shell".__getitem__(slice(3, 5, None))

т.е slice это объект низкого уровня, который не видно за кадром произходящего.
но поскольку интерпретатор Питон "знает" что существует объект класса slice -
то это означает что внутри Питона есть класс объектов slice который уже задан.
соотвественно этому утверждению можно говорить об объекте slice как о классе.

Дальше просто - класс объектов slice уже описан в отношении фукнции __getitem__ 
- следовательно, существует возможность использовать его в рамках этой функции.

>>> class example:
...     def __getitem__ (self, item):
...         if isinstance(item, slice):
...             print("You are slicing me!")
...             print("From", item.start, "to", item.stop, "with step", item.step)
...             return self
...         if isinstance(item, tuple):
...             print("You are multi-slicing me!")
...             for x, y in enumerate(item):
...                 print("Slice #"), x
...                 self[y]
...             return self
...         print("You are indexing me!\nIndex:", repr(item))
...         return self
... 
>>> example()[9:20]
You are slicing me!
From 9 to 20 with step None
<__main__.example object at 0x0000000002E48668>
>>> example()[2:3,9:19:2]
You are multi-slicing me!
Slice #
You are slicing me!
From 2 to 3 with step None
Slice #
You are slicing me!
From 9 to 19 with step 2
<__main__.example object at 0x0000000002E48630>
>>> example()[50]
You are indexing me!
Index: 50
<__main__.example object at 0x0000000002E48668>
>>> example()["String index i.e. the key!"]
You are indexing me!
Index: 'String index i.e. the key!'
<__main__.example object at 0x0000000002E48630>
>>> example()["start of slice":"end of slice"]
You are slicing me!
From start of slice to end of slice with step None
<__main__.example object at 0x0000000002E48668>
>>> 

# поэтому в результате танцев с бубном можно научиться делать так:

>>> class anime:
...     def __getitem__ (self, item):
...         if isinstance(item, list):
...             print(item, "no item")
...         if isinstance(item, str):
...             print(item)
...         if isinstance(item, slice):
...             print(slice)                          
... 
>>> anime()["Ghost in the shell"]
Ghost in the shell
>>> anime()["Ghost in the shell"[1:11]]
host in th
>>> 

В финале этой замечательной истории интерпретатор вернул мне объект slice - host in th

# Хинт, Лутц вещает с прицелом на будущее.

Аргументы командной строки, пере данные сценарию на языке Python при запуске, доступны в виде 
атрибута argv встроенного модуля sys:

# File echo.py

>>> import sys
>>> print(sys.argv)
['']
>>> 

% python echo.py -a -b -c
[‘echo.py’, ‘-a’, ‘-b’, ‘-c’]

Обычно вас будут интересовать только параметры, которые следуют за именем программы. Это приводит
нас к типичному использованию операции получения среза: мы можем с помощью единственной инструк
-ции получить все элементы списка, за исключением первого. В данном случае выражение 
sys.argv[1:] вернет требуемый список [‘-a’, ‘-b’, ‘-c’]. После этого список можно 
обрабатывать по своему усмотрению, не забо тясь о присутствии имени программы
в начале.

Кроме того, операция получения среза часто используется для удаления лишних символов из строк, 
считываемых из файлов. Если известно, что строки всегда завершаются символом новой строки
(символ \n), его можно удалить одним-единственным выражением – line[:-1], которое
возвращает все символы строки, кроме последнего (нижняя граница по умолчанию 
принимается равной 0). В обоих случаях операция извлечения подстроки
обеспечивает логику выполнения, которую в низкоуровневых языках
программирования пришлось бы реализовывать явно.

Обратите внимание, что для удаления символа новой строки часто предпочтительнее использовать метод
line.rstrip, потому что он не повреждает строки, в которых отсутствует символ новой строки в конце,
 – типичный случай при создании текстовых файлов некоторыми текстовыми редакторами. Операция
извлечения подстроки применима, только если вы полностью уверены, что строки завершаются
корректным образом.

# Интрумены преобразования строк.

Как быть, если сценарий получает число в виде текстовой строки из файла или от пользовательского
интерфейса? В этом случае следует использовать инструменты преобразования, чтобы можно было
интерпретировать строку как число или наоборот. Например:

>>> x = int("42")
>>> type(x)
<class 'int'>
>>> x = str(42)
>>> type(x)
<class 'str'>
>>> 

Функция int преобразует строку в число, а функция str преобразует число в строковое представление
(по сути – в то, что выводится на экран). Функция repr (и прежний ее эквивалент, обратные 
апострофы, который был удален в Python 3.0) также преобразует объект в строковое 
представление, но возвращает объект в виде строки программного кода, который
можно выполнить, чтобы воссоздать объект.

>>> anime = repr(501)
>>> anime + anime
'501501'
>>> anime = 501
>>> anime + anime
1002
>>> 

В первмо случае repr вернул 501 в качестве объекта, поэтому выполняется операция коннетации
объектов, во втором случае выполняется операция сложения. (как то так - может я не прав).

Если строка - объект, то инструкция print выведет кавычки, окружающие строку:

>>> print(str("anime"), repr("anime"))
anime 'anime'
>>>  

Подробнее о различиях между функциями str и repr можно прочитать во врез ке «Форматы представления
repr и str», в главе 5.

# функции int и str изначально предназначены для выполнения преобразований.

>>> anime = "401"
>>> ghost = 1
>>> anime + ghost
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Can't convert 'int' object to str implicitly
>>> 

>>> anime = "401"
>>> ghost = 1
>>> anime + str(ghost)    # - операция коннетации строк
'4011'
>>> int(anime) + ghost    # - операция сложения чисел
402
>>> 

Существуют похожие встроенные функции для преобразования вещественных чисел в/из строки:

>>> str(3.415), float("1.5")
('3.415', 1.5)
>>> 

>>> anime = "1.234E-10"
>>> float(anime)
1.234e-10
>>> 

# Преобразование кодов символов

Имеется также возможность выполнить преобразование одиночного символа в его целочисленный код ASCII,
для чего нужно передать этот символ функции ord – она возвращает фактическое числовое значение 
соответствующего байта в памяти. Обратное преобразование выполняется с помощью функции chr, 
она получает целочисленный код ASCII и преобразует его в соответствующий символ:

>>> ord("s")               
115
>>> chr(115)
's'
>>> 

# не работает со строками

>>> ord("Ghost in the shell")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: ord() expected a character, but string of length 18 found

# Хинт

Эти функции можно применить ко всем символам строки в цикле. Они могут также использоваться для 
реализации своего рода строковой математики. Например, чтобы получить следующий по алфавиту
символ, его можно преобразовать в число и выполнить математическое действие над ним:

>>> anime = ("s")
>>> anime = chr(ord("s") + 1)
>>> anime
't'
>>> 

Следующий пример преобразования представляет собой альтернативу встроенной функции int, по крайней
мере для односимвольных строк, для преобразования строки в целое число:

>>> int("5")
5
>>> ord("5") - ord("0")
5
>>> ord("5") - ord("1")
4
>>> 

Такие преобразования могут использоваться в сочетании с операторами цикла, представленными в главе
4 и подробно рассматриваемыми в следующей части книги, для получения целочисленных значений из
строковых представлений двоичных чисел. В каждой итерации текущее значение умножается на 2 и
затем к нему прибавляется числовое значение следующей цифры:

>>> anime = "1101"
>>> i = 0
>>> while anime != "":
...     i = i * 2 + (ord(anime[0]) - ord("0"))
...     anime = anime[1:]
>>> i
13
>>>

>>> chr(1101)
'э'

Операция побитового сдвига влево (I << 1) могла бы дать тот же эффект, что и операция умножения на
2. Но так как мы еще не познакомились с циклами и уже видели встроенные функции int и bin в главе
5, которые могут использоваться в задачах преобразования двоичных чисел в Python 2.6 и 3.0, то же
самое можно реализовать, как показано ниже:

>>> int("1101", 2) # Преобразовать двоичное представление в целое число
13
>>> bin(13) # Преобразовать целое число в двоичное представление
‘0b1101’

### i just wanna run https://soundcloud.com/xyande/nightcore-i-just-wanna-run

# Изменение строк (Лутц вещает про то что сроки - это неизменямая последоваательность)

Чтобы изменить строку, необходимо создать новую строку с помощью таких операций, как конкатенация и 
извлечение подстроки, и затем, если это необходимо, присвоить результат первоначальному имени;
кроме того можно использовать строковый метод replace

>>> anime = "anime"
>>> anime = anime + "Ghost"
>>> anime                                    # 'animeGhost'
'animeGhost'
>>> anime = anime[0] + "Shell" + anime[-1]
>>> anime                                    #  'aShellt'
'aShellt'
>>> anime = "Ghost in the shell"
>>> anime = anime.replace("Ghost", "Major")
>>> anime
'Major in the shell'
>>>

существует возможность сборки текстовых значений с помощью выражений форматирования строк. Ниже приводятся
два примера подстановки значений объектов в строку, при этом происходит преобразование объектов в строки и
изменение первоначальной строки в соответствии со спецификаторами формата:

# выражение 

>>> "Ghost in the %d %s shell" % (501, "anime")
'Ghost in the 501 anime shell'
>>> 

%d - для цифр
%s - для строк

Хвала Лутцу он смог объяснить мне как это рабоает!

# метод

>>> "Ghost in the {0} {1} shell".format (501, "anime")
'Ghost in the 501 anime shell'

Несмотря на впечатление, что происходит замена символов в строке, в действительности в результате 
форматирования получаются новые строковые объекты, а оригинальные строки не изменяются. Второй
пример представляет строкой метод (ибо у каждого класса объектов есть встроенные методы).

# строковые методы.

Метод replace является более универсальным, чем предполагает этот программный код. Он принимает в качестве
аргумента оригинальную подстроку (любой длины) и строку (любой длины) замены, и выполняет глобальный поиск
с заменой:

>>> "Stand alone complex". replace("a", "Ghost")
'StGhostnd Ghostlone complex'
>>> 

В этой роли метод replace может использоваться как инструмент реализации поиска с заменой по шаблону 
(например, замены символов формата). Обратите внимание, что на этот раз мы просто выводим результат 
на экран, а не присваиваем его переменной – присваивать результат переменной необходимо только в 
том случае, если потребуется сохранить результат дальнейшего использования.

Если необходимо заменить одну подстроку фиксированного размера, которая может появиться в любом месте, можно
также выполнить операцию замены или отыскать подстроку с помощью метода find и затем воспользоваться опера-
циями извлечения подстроки:

>>> anime = "Ghost in the shell"
>>> where = anime.find("Ghost")                   # поиск позиции
>>> where                                         # 0
0
>>> anime = anime[:where] + "Stand Alone Complex" + anime[(where+4):]
>>> anime
'Stand Alone Complext in the shell'
>>> 

Метод find возвращает смещение, по которому найдена подстрока (по умолчанию поиск начинается с начала строки),
или значение -1, если искомая подстрока не найдена. Другой вариант использования метода replace заключается
в передаче третьего аргумента, который определяет число производимых замен:

>>> anime = "Ghost in the shell"
>>> anime.replace("Ghost", "Stand Alone Complex")
'Stand Alone Complex in the shell'

>>> anime = "Ghost, Ghost in the shell"
>>> anime.replace("Ghost", "Stand Alone Complex", 1)
'Stand Alone Complex, Ghost in the shell'

Обратите внимание: метод replace возвращает новую строку. Так как строки являются неизменяемыми, методы 
никогда в действительности не изменяюторигинальную строку, даже если они называются «replace» (заменить)!

# как бы новая строк == новая ссылка в системной таблице + автоматический сборщик мусора.

Тот факт, что операция конкатенации и метод replace всякий раз создают новые строковые объекты, может
оказаться недостатком их использования дляизменения строк. Если в сценарии производится множество
изменений длинных строк, вы можете повысить производительность сценария, преобразовав строку в 
объект, который допускает внесение изменений:

>>> anime = "Ghost, Ghost in the shell"
>>> a = list(anime)
>>> a
['G', 'h', 'o', 's', 't', ',', ' ', 'G', 'h', 'o', 's', 't', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 's', 'h', 'e', 'l', 'l']
>>> 

Встроенная функция list (или функция-конструктор объекта) создает новый список из элементов любой 
последовательности – в данном случае «разрывая» строку на символы и формируя из них список.
Обладая строкой в таком представлении, можно производить необходимые изменения, не вызывая
создание новой копии строки при каждом изменении:

>>> a[3] = "Ghost"
>>> a[4] = "major"
>>> a
['G', 'h', 'o', 'Ghost', 'major', ',', ' ', 'G', 'h', 'o', 's', 't', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 's', 'h', 'e', 'l', 'l']
>>> 

# Этот прием допустим для списков, но не для строк - ибо строк являються неизменяемыми объектами.

Если после внесения изменений необходимо выполнить обратное преобразование (чтобы, например, записать 
результат в файл), можно использовать метод join, который «собирает» список обратно в строку:

>>> anime = "".join(a)
>>> anime                   
'GhoGhostmajor, Ghost in the shell'

Метод join на первый взгляд может показаться немного странным. Так как он является строковым методом (а не
методом списка), он вызывается через указание желаемой строки-разделителя. Метод join объединяет строки 
из списка, вставляя строку-разделитель между элементами списка. В данном случае при получении строки 
из списка используется пустая строка-разделитель. В более общем случае можно использовать 
произвольную строку-разделитель:

>>> "Ghost, Ghost in the shell".join(["Stand", "Alone", "Complex"])
'StandGhost, Ghost in the shellAloneGhost, Ghost in the shellComplex'
>>> 

# Хинт.

На практике объединение подстрок в одну строку часто выполняется намного быстрее, чем последовательность
операций конкатенации отдельных элементов списка. Обрати потом внимание на строковый тип bytearray, 
глава 36.

# разбор текста.

Для извлечения подстрок из фиксированных смещений можно использовать прием извлечения срезов:

>>> anime = "aaa bbb ccc"
>>> col1 = anime[0:3]
>>> col2 = anime[8:]
>>> col1
'aaa'
>>> col2
'ccc'
>>> 

В этом примере поля данных располагаются в фиксированных позициях и потому могут быть легко извлечены из
оригинальной строки. Этот прием может использоваться, только если анализируемые компоненты располагаются
в известных фиксированных позициях. Если поля отделяются друг от друга некоторым разделителем, можно
воспользоваться методом разбиения строки на компоненты. Этот прием используется, когда искомые
данные могут располагаться в произвольных позициях внутри строки:

>>> anime = "aaa bbb ccc"
>>> cols = anime.split()
>>> cols
['aaa', 'bbb', 'ccc']
>>> 

Строковый метод split преобразует строку в список подстрок, окружающих строки-разделители. В предыдущем
примере мы не указали строку-разделитель, поэтому по умолчанию в качестве разделителей используются
пробельные символы – строка разбивается на группы по символам пробела, табуляции или перевода 
строки, и в результате мы получили список подстрок.

В других случаях данные могут отделяться другими разделителями. В следующем примере производится разбиение
(и, следовательно, разбор) строки по символу запятой, который обычно используется для отделения данных,
 извлеченных из баз данных:

>>> anime = "Ghost, Ghost in the, shell"
>>> anime.split(",")
['Ghost', ' Ghost in the', ' shell']

В теории, разделители могут содержать более одного символа - на парктике мосэнерго 2 раза мигнул светом.

>>> anime = "Ghost, Ghost in the, shell"
>>> anime.split("Ghost")
['', ', ', ' in the, shell']

# имееться ввиду что можно разбивать по тем строкам, которые уже есть в строке.

# Другие часто используемые методы строк в действии:

Другие строковые методы имеют более специфическое предназначение, на-пример удаляют пробельные символы в
конце текстовой строки, выполняют преобразование регистра символов, проверяют характер содержимого строки
и проверяют наличие подстроки в конце строки или в начале:

>>> anime = "Ghost in the shell\n"
>>> anime.rstrip()
'Ghost in the shell'
>>> anime.upper()                      
'GHOST IN THE SHELL\n'
>>> anime.isalpha()                    
False
>>> anime.endswith("ll\n")             
True
>>> anime.startswith("Ghost")
True
>>>  

Для достижения тех же результатов в некоторых случаях могут использоваться альтернативные приемы – с 
использованием оператора проверки вхождения in можно проверить присутствие подстроки, а функция
получения длины строки и операция извлечения подстроки могут использоваться для имитации
действия функции endswith:

>>> anime = "Ghost in the shell\n"
>>> anime.find("in the") != -1         
True
>>> "shell" in anime                    
True
>>> sub = "shell\n"                   
>>> anime.endswith(sub)                
True
>>> anime[-len(sub):] == sub
True
>>> 

# последние строчки кода, это - проверка наличия подстроки в конце строки с помощью метода или операции 
извлечения подстроки, идея такая: задаём подстроку через переменную sub и предлагаем интерпретатору 
использовать это значение при активации метод len, поскольку len сам по себе перебирает строку по
индексам, чтобы сосчитать её длинну - то методу известно содержание строки и соотвественно этому
- возможно задавать ему параметры для проверки на вхождение тех или иных символов в строке.

# Хинт

Ни один из строковых методов не поддерживает шаблоны, – для обработки текста с использованием шаблонов
необходимо использовать модуль re, входящий в состав стандартной библиотеки языка Python, 
– дополнительный инструмент, начальные сведения о котором приводились в главе 4, а 
полное его обсуждение выходит далеко за рамки этой книги (один пример приводится в
конце главы 36). Тем не менее, несмотря на это ограничение, строковые методы
иногда оказываются эффективнее, чем функции модуля re. 

# а вообще смотри страницу 228 для первичного ознакомления с методами строк. 

# Выражения форматирования строк

В языке Python имеется двухместный оператор %, предназначенный для работы со строками (вы можете вспомнить,
что для чисел он является оператором деления по модулю, или получения остатка от деления). Когда этот
оператор применяется к строкам, он обеспечивает простой способ форматирования значений, согласно 
заданной строке формата. Проще говоря, оператор % обеспечивает возможность компактной записи 
программного кода, выполняющего множественную подстановку строк, позволяя избавиться от 
необходимости конструирования отдельных фрагментов строки по отдельности с последующим
их объединением.

Чтобы отформатировать строку, требуется:

1. Слева от оператора % указать строку формата, содержащую один или более спецификаторов формата, каждый из
которых начинается с символа % (например, %d).

2. Справа от оператора % указать объект (или объекты, в виде кортежа), значение которого должно быть
подставлено на место спецификатора (или специ фикаторов) в левой части выражения.

>>> "Ghost in the %d shell %s" %(501, "Stand Alone Complex")
'Ghost in the 501 shell Stand Alone Complex'
>>> story = "Major story of terrible life in anime story"
>>> title = 'Ghost %s in the 501 shell Stand Alone Complex' % story
>>> title
'Ghost Major story of terrible life in anime story in the 501 shell Stand Alone Complex'
>>> 

# Обратите внимание: когда вставляется более одного значения, в правой части выражения их необходимо
сгруппировать с помощью круглых скобок (то есть создать из них кортеж). Оператор форматирования % 
ожидает получить справа либо один объект, либо кортеж объектов.

>>> "%s -- %s -- %s" % (42, 3.14159, [1, 2, 3])
'42 -- 3.14159 -- [1, 2, 3]'
>>> 

В этом примере также вставляются три значения – целое число, вещественное число и объект списка, обратите 
внимание, что в левой части выражения всем значениям соответствует спецификатор %s, который соответствует
операции преобразования в строку. Объекты любого типа могут быть преобразованы в строку (это происходит,
например, при выводе на экран), поэтому для любого объекта может быть указан спецификатор %s. 
Вследствие этого вам не придется выполнять специальное форматирование, в большинстве случаев
вам достаточно будет знать только о существовании спецификатора %s.

# Дополнительные возможности форматирования строки и спецификаторы.

%s 
Строка (для объекта любого другого типа будет выполненвызов функции str(X), чтобы получить строковое
представление объекта)

%r 
s, но использует функцию repr, а не str

%c 
Символ

%d 
Десятичное (целое) число

%i 
Целое число

%u 
То же, что и d (устарел: больше не является представлением целого без знака)

%o 
Восьмеричное целое число

%x
Шестнадцатеричное целое число

%X 
x, но шестнадцатеричные цифры возвращаются в верхнемрегистре

%e
Вещественное число в экспоненциальной форме

%E
e, но алфавитные символы возвращаются в верхнемрегистре

%f
Вещественное число в десятичном представлении

%F
Вещественное число в десятичном представлении

%g
Вещественное число e или f
  
Фактически спецификаторы формата в левой части выражения поддерживают целый набор операций преобразования с
достаточно сложным собственным синтаксисом. В общем виде синтаксис использования спецификатора формата
выглядит следующим образом:

%[(name)][flags][width][.precision]code

# очень интересно!

Символ спецификатора формата (code) из табл. 7.4 располагается в самом конце. Между символом % и символом
спецификатора можно добавлять следующую информацию: ключ в словаре (name); список флагов (flags), которые
могут определять, например, признак выравнивания (-), знак числа (+), наличие ведущих нулей (0); общую 
ширину поля и число знаков после десятичной точки и многое другое. Параметры формата width и precision
могут также принимать значение *, чтобы показать, что фактические значения этих параметров должны
извлекаться из следующего элемента в списке входных значений.

>>> x = 1234
>>> res = "integers:...%d ...%-6d...%06d" % (x,x,x)
>>> res
'integers:...1234 ...1234  ...001234'
>>> 

В примере сначала применяется форматирование целого числа с параметрами поумолчанию, а затем целое число
выводится в поле шириной в шесть символов, с выравниванием по левому краю и с дополнением ведущими нулями:

Спецификаторы %e, %f и %g отображают вещественные числа разными способами, как демонстрируется в следующем
примере:

>>> x = 1.23456789
>>> x                                 
1.23456789
>>> "%e, %f, %g" % (x,x,x)
'1.234568e+00, 1.234568, 1.23457'
>>> 

Для вещественных чисел можно реализовать дополнительные эффекты форматирования, указав необходимость
выравнивания по левому краю, дополнение ведущими нулями, знак числа, ширину поля и число знаков 
после десятичнойточки. Для простых задач можно было бы использовать простые функции пре-
образования чисел в строки с применением выражения форматирования или встроенной 
функции str, продемонстрированной ранее:

>>> "%-6.2f | %05.2f | %+06.1f" % (x, x, x)
'1.23   | 01.23 | +001.2

# где х = 1.23456789

>>> "%s" % x, str(x)
('1.23456789', '1.23456789')
>>>

Если ширина поля и количество знаков после десятичной точки заранее не известны, их можно вычислять во время
выполнения, а в строке формата вместо фактических значений использовать символ *, чтобы указать 
интерпретатору, что эти значения должны извлекаться из очередного элемента в списке входных
значений, справа от оператора %. Число 4 в кортеже определяет количество знаков после
десятичной точки:

>>> "%f, %.2f, %.*f" % (1/3.0, 1/3.0, 4, 1/3.0)
'0.333333, 0.33, 0.3333'
>>> 

# практика показывает что для замены "чего либо" в строке - нужно использовать replace - ибо форматирование
может добавить в строку что то новое, но похоже не может удалить что то старое.

>>> anime = "Ghost in the shell"
>>> sub1 = "Stand"
>>> sub2 = "alone"
>>> sub3 = "complex"
>>> anime = "%sGhost %sin the %sshell" %(sub1, sub2, sub3)
>>> print(anime)
StandGhost alonein the complexshell
>>> 

# практика показала что форматирование удобно использовать для науки богов - математики! и в циклах.

# автоматическое вычисление количества знаков после запятой с помощью цикла выглядит так:

>>> x = 501
>>> y = 11
>>> anime = x / y
>>> i = 0
>>> while i < anime:
...     story = "%f, %f, %.*f" %(x, y, i, i)
...     i = i + 1
...     print(story)
501.000000, 11.000000, 0
501.000000, 11.000000, 1.0
501.000000, 11.000000, 2.00
501.000000, 11.000000, 3.000
501.000000, 11.000000, 4.0000
501.000000, 11.000000, 5.00000
501.000000, 11.000000, 6.000000
501.000000, 11.000000, 7.0000000
501.000000, 11.000000, 8.00000000
501.000000, 11.000000, 9.000000000
501.000000, 11.000000, 10.0000000000
501.000000, 11.000000, 11.00000000000
501.000000, 11.000000, 12.000000000000
501.000000, 11.000000, 13.0000000000000
501.000000, 11.000000, 14.00000000000000
501.000000, 11.000000, 15.000000000000000
501.000000, 11.000000, 16.0000000000000000
501.000000, 11.000000, 17.00000000000000000
501.000000, 11.000000, 18.000000000000000000
501.000000, 11.000000, 19.0000000000000000000
501.000000, 11.000000, 20.00000000000000000000
501.000000, 11.000000, 21.000000000000000000000
501.000000, 11.000000, 22.0000000000000000000000
501.000000, 11.000000, 23.00000000000000000000000
501.000000, 11.000000, 24.000000000000000000000000
501.000000, 11.000000, 25.0000000000000000000000000
501.000000, 11.000000, 26.00000000000000000000000000
501.000000, 11.000000, 27.000000000000000000000000000
501.000000, 11.000000, 28.0000000000000000000000000000
501.000000, 11.000000, 29.00000000000000000000000000000
501.000000, 11.000000, 30.000000000000000000000000000000
501.000000, 11.000000, 31.0000000000000000000000000000000
501.000000, 11.000000, 32.00000000000000000000000000000000
501.000000, 11.000000, 33.000000000000000000000000000000000
501.000000, 11.000000, 34.0000000000000000000000000000000000
501.000000, 11.000000, 35.00000000000000000000000000000000000
501.000000, 11.000000, 36.000000000000000000000000000000000000
501.000000, 11.000000, 37.0000000000000000000000000000000000000
501.000000, 11.000000, 38.00000000000000000000000000000000000000
501.000000, 11.000000, 39.000000000000000000000000000000000000000
501.000000, 11.000000, 40.0000000000000000000000000000000000000000
501.000000, 11.000000, 41.00000000000000000000000000000000000000000
501.000000, 11.000000, 42.000000000000000000000000000000000000000000
501.000000, 11.000000, 43.0000000000000000000000000000000000000000000
501.000000, 11.000000, 44.00000000000000000000000000000000000000000000
501.000000, 11.000000, 45.000000000000000000000000000000000000000000000
>>> 

# если вооружиться понимаем этой концепции - то форматирование становиться мощным инструментом, знание такое

>>> x = 1
>>> y = 2
>>> "%f, %.10f" % (x, y)     # %.xf - где х число знаков после запятой
'1.000000, 2.0000000000'
>>> "%f, %.10f, %.*f" % (x, y, 20, 11)
'1.000000, 2.0000000000, 11.00000000000000000000'
>>> 

# (!!!) вся суть в правиле: " использовать символ *, чтобы указать интерпретатору, что эти значения должны
извлекаться из очередного элемента в списке входных значений, справа от оператора %." Это значит, что для
работы, выражению необходим ещё один элемент (любой типа int или переменная int type) указанные в 
сбоках после нужного нам значения числа знаков после запятой.

# (x, y, 20, 11) - 20 это число знаков после запятой, 11 это тот самый "обязательный" элемент.

>>> x = 501
>>> y = 11
>>> anime = x / y
>>> i = 0
>>> while i < 11: 
...     anime = "%f, %.2f, %.*f" % (x/y, x/y, y, x/y)      # 
...     i = i + 1
...     y = y - 1
...     print(i, anime)
1 45.545455, 45.55, 45.54545454545
2 50.100000, 50.10, 50.1000000000
3 55.666667, 55.67, 55.666666667
4 62.625000, 62.62, 62.62500000
5 71.571429, 71.57, 71.5714286
6 83.500000, 83.50, 83.500000
7 100.200000, 100.20, 100.20000
8 125.250000, 125.25, 125.2500
9 167.000000, 167.00, 167.000
10 250.500000, 250.50, 250.50
11 501.000000, 501.00, 501.0
>>> 

# Форматирование строк из словаря.

Операция форматирования позволяет также использовать в спецификаторах формата ссылки на ключи словаря, 
который указывается в правой части выражения, для извлечения соответствующих значений.

>>> "%(n)d %(x)s" % {"n":1, "x":"spam"}
'1 spam'

В данном случае (n) и (x) в строке формата ссылаются на ключи в словаре в правой части выражения и служат
для извлечения соответствующих им значений.%d - потому что число, %s - потому что строка.

>>> history = {"Ghost":"Major","Bato":"Major Friend","11":"Crazy Major Friends","Godo":"Evil Enemy"}
>>> story = "%(Ghost)s %(Bato)s" % {"Ghost":"Major","Bato":"Major Friend","11":"Crazy Major Friends","Godo":"Evil Enemy"}
>>> story
'Major Major Friend'
>>> 

Этот прием часто используется в программах, создающих код разметки HTML или XML, – вы можете построить словарь
значений и затем подставить их все одним выражением форматирования, которое использует ключи:

>>> reply = """
... Greetings...
... Hello %(name)s!
... Your anime character type is %(type)s
... """
... 
>>> characters = {"name": "Major", "type": "Ghost in the shell"}
>>> print(reply % characters)

Greetings...
Hello Major!
Your anime character type is Ghost in the shell

>>> 

Этот способ также часто используется в комбинации со встроенной функцией vars, которая возвращает словарь,
содержащий все переменные, существующие на момент ее вызова:

>>> history = "Ghost"
>>> story = "Shell"
>>> "%(history)s %(story)s" % vars()
'Ghost Shell'
>>> 

Если задействовать эту функцию в правой части оператора форматирования, можно отформатировать значения,
обращаясь к ним по именам переменных (то есть по ключам словаря), вообще фукнция vars() возвращает 
локальную таблицу имён, а если указать объёт - то вернёт таблицу имён объекта.

Но я пока так и не понял как по человечески его использовать вне операции форматирования...
>>> учиться учиться учиться учиться учиться (с) Голден Бой!













