С этим артефактом связаный файлы P4E и module1.py

Лутц "Изучаем Питон 4ое издание" - основа основ
«Программирование на Python»1 (O’Reilly) - продолжение
«Pyton Pocket Reference» (O’Reilly), - справочник по основам
«Python Cookbook» (O’Reilly) - сборник решений, тем - кто знаком с приемами прикладного программирования

Дзен: "явное - лучше неявного, а простое лучше сложного."
Дзен: код питона в одном файле - сценарий, в нескольких - программа.

Очень запутанное вступление - ему нужно поработать над первыми 100 страницами книги.

Питон это байт-код.

В современной реализации Python компилирует (то есть транслирует) инструкции исходного программного кода
в промежуточное представление, известное как байт-код, и затем интерпретирует этот байт-код. 
Байт-код обеспечивает переносимость программ, поскольку это платформоне-зависимый формат.
Однако из-за того что Python не создает двоичный машинный код 
(например, машинные инструкции для микропроцессора Intel),
иногда программы на языке Python могут работают медленнее 
чем аналогинаписанных на компилирующих языках, таких как C.

Кроме того, когда в сценарии Python делается что-нибудь «значительное», например обрабатывается файл
или конструируется графический интерфейс, ваша программа фактически выполняется со скоростью,
которую способен дать язык C, потому что такого рода задачи решаются компилированным
с языка С программным кодом, лежащим в недрах интерпретатора Python. Гораздо важнее,
что преимущество в скорости разработки порой важнее потери скорости выполнения,
особенно если учесть быстродействие современных компьютеров.

Тем не менее даже при высоком быстродействии современных процессоров остаются такие области, где
требуется максимальная скорость выполнения. Реализация математических вычислений и анимационных
эффектов, например, часто требует наличия базовых вычислительных компонентов, которые решают 
свои задачи со скоростью языка C (или еще быстрее). Если вы работаете в такой области вы 
все равно сможете использовать Python, достаточно лишь выделить из приложения компоненты, 
требующие максимальной скорости работы, в виде компилированных расширений и связать их с
системой сценариев на языке Python.

NumPy

Типичным примером такой двуязычной стратегии может служить расширение NumPy, содержащее реализацию
математических вычислений для Python благодаря комбинированию компилированных и оптимизированных
библиотек расширения с языком Python, NumPy превращает Python в мощный, эффективный и удобный
инструмент математических вычислений.

Питон умеет в...

# в системное программирование через стандартную библиотеку, которая соотвествует стандартам POSIX.
# в графический интерфейс через стандартный объектно-ориентированный интерфейс к Tk GUI API - Tkinter 
# в графический интерфейс через пакет расширения PMW (дополнительные визуальные компоненты) для Tkinter
# в графический интерфейс через wxPython GUI API, основанный на библиотеке C++ (альтернатива от Tkinter)
# в инструменты высокого уровня PythonCard и Dabo, построены на основе таких API, как wxPython и tkinter.
# в библиотеки для разработки графических интерфейсов, такие как
Qt (с помощью PyQt),
GTK (с помощью PyGtk),
MFC (с помощью PyWin32),
.NET (с помощью IronPython),
Swing (с помощью Jython – реализации языка Python на Java, или JPype).
# в простоту и приложения с веб-интрефейсом через Jython - веб-фреймворки на языке Python и CGI-сценарии.

# веб-сценарии через интерпретатор Python, который поставляется вместе со стандартными интернет-модулями,
которые позволяют программам выполнять разнообразные сетевые операции как в режиме клиента, так и сервера.
# в создание HTML-страниц на основе описаний классов Python через систему HTMLGen
# в кучу годноты.


Сценарий в Питон это
Файлы модулей, которые запускаются на выполнение непосредственно - файлы программ верхнего уровня.

Модуль в Питон это
Термин «модуль» зарезервирован для обозначения файлов, которые могут импортироваться другими файлами.

Программа в Питон это
Роследовательность заранее написанных инструкций, сохра ненных в файле для многократного использования.

"Программа в Питон это"
Сценарий верхнего уровня
	модуль 
		модуль
			модуль

Сценарий верхнего уровня обращается к другим модулям с помощью инструкции import

Сценарий верехнего уровня
	import script1
		import script2
			import script 3

(здесь и далее - отступы по tab не являються частью синтаксиса - это просто дизайн)

import - инструкция
reload - функция

После выполнения этой функции Питон об этом расскажет в верхней строке интерпретатора
<module 'script1' from '.\\script1.py'>
>>> 

В более широком понимании модули играют роль библиотек инструментов модуль – это, главным образом, всего лишь
пакет имен переменных, известный как пространство имен. Имена внутри этого пакета называются атрибутами, то 
есть атрибут – это имя переменной, которая связана с определенным объектом (таким как модуль).

модуль = пакет имён переменных
атрибут = имя переменной в модуле

#Дзен: атрибуты этто имена внутри пакета переменных, которые связаня с объектом (модулем)
#Питон: вызов атрибута через нотацию (модуль,атрибут) - далее вызов атрибута в сценарий верхнего уровня 

>>> import mylife		
>>> print(mylife.title)
The meaning of life
>>>

>>> import module1        # импортировать module1 в сценарий верхнего уровня
>>> print(module1,a)      # отпринтить из "module 1" атрибут "а"
<module 'module1' from '.\\module1.py'> Ghost
>>> a                     # вернуть переменную "a"
'Ghost'
>>> 

При импортировании этого модуля выполняется его программный код, который создает атрибут модуля. Инструкция
присваивания создает атрибут с именем title. Доступ к атрибуту title можно получить из других программных
компонентов двумя разными способами. Первый заключается в том, чтобы загрузить модуль целиком с помощью
инструкции import, а затем обратиться к атрибуту по его имени, уточнив его именем модуля: синтаксис
точечной нотации в виде object.attribute позволяет получить доступ к любому атрибуту в любом объекте.

#Питон: альтернативой служит процедура создания копий имён

>>> from mylife import title  # процедура копирования имён
>>> print(title)              # процедура возврата копий
The meaning of life
>>> 

>>> from module1 import a,b,c   # создать копии имён
Ghost Shell Anime
>>> print(a,b,c)                # отпринтить имена
Ghost Shell Anime
>>> a                           # обратиться к "a"
'Ghost'
>>> 

Инструкция from во многом подобна инструкции import, которая выполняет присваивание имен в импортируемом
компоненте. С технической точки зрения, инструкция from копирует атрибуты модуля так, что они становятся
простыми переменными в программном коде, выполняющем импорт, благодаря чему на этот раз он может
обратиться к импортированной строке уже не по имени myfile.title (ссылка на атрибут), а просто –
title (переменная).

Неважно, как выполняется импортирование модуля, с помощью инструкции import или from, в любом случае это
приводит к выполнению инструкций в файле myfile.py, а импортирующий компонент (в данном случае –
интерактивная оболочка интерпретатора) получает доступ к именам, определенным в файле на верхнем уровне.

В этом простом примере существует только одно такое имя – переменная title, которой присвоена строка, но 
сама концепция приобретает более важное значение, когда речь заходит об определении в модулях таких 
объектов, как функции и классы. Такие объекты становятся программыми компонентами многократного
использования, доступ к которым можно получить из одного или более клиентских модулей.

На практике модули обычно определяют более чем одно имя, которые могут использоваться и внутри, 
и за пределами модуля.

>>> import module1        # импортировать module1 в сценарий ВУ (с выполнением кода module1)
Ghost Shell Anime
>>> module1.a, module1.b  # вернуться атрибут "a, b" согласно нотации object.attribute
('Ghost', 'Shell')
>>> 

import - выполняет код импортируемого модуля для доступа к именам
from - копирует имена из внешнего модуля без выполнения кода.

Результаты выводятся в круглых скобках, потому что в действительности они являются кортежами.

DIR - встроенная функция, использоваться для получения списка имен, доступных внутри модуля.

>>> import module1        # импортировать модуль
>>> dir(module1)          # посмтреть что внутри
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'b', 'c']
>>> 

Дзен(!)
Вообще программы на языке Python состоят из множества файлов модулей, связанных между собой инструкциями import.
Каждый файл модуля – это самостоятельный пакет переменных, или пространство имен. Один модуль не сможет увидеть
переменные, определенные в другом модуле, если явно не импортирует его. Модули позволяют уменьшить вероятность
конфликтов имен в программном коде – так как каждый файл является самостоятельным пространством имен, имена
в одном файле не вступают в конфликт с именами в другом файле, даже если они одинаковые.

# необходимо отметить, что инструкция from в не котором смысле стирает границы пространств имен между модулями, 
потому что она копирует переменные из одного файла в другой. Это может вызывать затирание переменных в импор-
тирующем файле одноименными переменными в импортируе мом файле (при этом никаких предупреждений выводиться не
будет). По сути, эта инструкция выполняет разрушительное объединение пространств имен, по крайней мере, в 
терминах копируемых переменных.

# операция перезагрузки не является транзитивной – перезагружается только модуль, указанный в вызове функции 
reload, но не перезагружаются модули, которые он импортирует, поэтому может возникнуть потребность 
перезагрузить несколько файлов.

# Если ваш программный код не работает в IDLE, попробуйте запустить его за пределами среды разработки.

# Ошибки – это четко определенный механизм, известный как исключения, которые можно перехватывать и обрабатывать

Заканчиваем на странице 118 - переходим в IntroIV.
