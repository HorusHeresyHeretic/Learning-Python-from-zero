С этим артефактом связан файл IntroIV.py

# Введение в типы объектов языка Python

Программы на языке Python выполняют некоторые действия над объектами.
Данные в языке Python представлены в форме объектов.
- либо встроенных, предоставляемых языком Python, 
- либо объектов, которые мы создаем с применением конструкций языка Python
- или других инструментов, таких как библиотеки расширений, написанные на языке C.

Объекты – это области памяти со значениями и ассоциированными с ними наборами операций.
Программы на языке Python можно разложить на составляющие, как модули, инструкции, выражения и объекты;

1. Программы делятся на модули.
2. Модули содержат инструкции.
3. Инструкции состоят из выражений.
4. Выражения создают и обрабатывают объекты. 

Базовые встроенные объекты и их литералы, литерал - выражение, которые генерируют объекты.

Числа									= 1234, 3.1415, 3+4j, Decimal, Fraction
Строки									= ‘spam’, “guido’s” , b’a\x01c’
Списки									= [1, [2, ‘three’], 4]
Словари									= {‘food’: ‘spam’, ‘taste’: ‘yum’}
Кортежи									= (1,’spam’, 4, ‘U’)
Файлы									= myfile = open(‘eggs’, ‘r’)
Множества								= set(‘abc’), {‘a’, ‘b’, ‘c’}
Прочие базовые типы						= Сами типы, None, логические значения
Типы структурных элементовпрограмм		= Функции, модули, классы (часть IV, часть V, часть VI)
Типы, имеющие отношение к реализации	= Компилированный программный код, стек вызовов (часть IV, часть VII)

Таблица содержит далеко не полный список, потому что объектами явля ются все данные, которые приходится
обрабатывать в программах на языке Python. Например, когда на языке Python реализуется поиск текста по 
шаблону, – создаются объекты шаблонов, когда программируются сетевые взаимо действия, – используются
объекты сокетов. Существуют и другие типы объектов, которые создаются в результате импорта и
использования модулей, и все они обладают своим собственным поведением.

# Динамическая типизация

В языке Python отсутствует конструкция объявления типа, сам синтаксис выполняемых выражений задает 
типы создаваемых и используемых объектов. Фактически выражения, создающие объекты являются 
источниками типов.

в языке Python используется динамическая типизация (типы данных определяются автоматически и их не 
требуется объявлять в программ ном коде), но при этом он является языком со строгой типизацией 
- вы сможете выполнять над объектом только те операции, которые применимы к его типу.

# Индексы

В языке Python индексы реализованы в виде смещений от начала и потому индексация начинается с 0:
первый элемент имеет индекс 0, второй – 1 и так далее.

# Переменные

В языке Python не требуется объявлять переменные заранее.Переменная создается в тот момент, когда ей 
присваивается значение, при этом переменной можно присвоить значение любого типа, а при использовании
внутри выражения имя переменой замещается ее фактическим значением. Прежде чем у нас появится возможность 
обратиться к переменной, ей должно быть присвоено какое-либо значение.

В языке Python предусмотрена возможность индексации в обратном порядке, от конца к началу – положительные
индексы откладываются от левого конца последовательности, а отрицательные – от правого:

# Строки

Строки используются для записи текстовой информации, а также произвольных последовательностей байтов. Такие
последовательности поддерживают порядок размещения элементов, которые они содержат, слева направо: элементы
сохраняются и извлекаются исходя из их позиций в последовательностях.  Другими типами последовательностей
являются списки и кортежи.

# Срезы: Проще всего можно представить себе срез как способ извлечения целого столбца из строки за один шаг.

В общем виде синтаксис операции получения среза выглядит как: X[I:J]- означает: «извлечь из X все, начиная
со смещения I и до смещения J, но не включая его». В качестве результата возвращается новый объект.

Например, последняя операция из примера anime[1:3] вернет все символы строки S со смещениями с 1 по 2 в 
виде новой строки. В результате получается срез, или «выборка» двух символов из середины.

# Коннетация. Будучи последовательностями, строки поддерживают операцию конкатенации, которая записывается
в виде знака плюс (объединение двух строк в одну строку), и операцию повторения (новая строка создается за 
счет много кратного повторения другой строки):

Знак плюс (+) имеет различное значение для разных объектов: для чисел – сложение, для строк – конкатенация.
Это универсальное свойство языка Python, которое далее в книге будет называться полиморфизмом, означает, 
что фактически выполняемая операция зависит от объектов, которые принимают в ней участие. Такой 
полиморфизм в значительной степени обеспечивает выразительность и гибкость программного кода на
языке Python. Поскольку отсутствуют ограничения, связанные с типами, операции в языке Python 
обычно в состоянии автоматически обрабатывать объекты самых разных типов, при условии, что 
они поддерживают совместимый интерфейс (как в данном случае операция +).
В языке Python идея полиморфизма является ключевой концепцией.

# Неизменяемость. В предыдущих примерах ни одна из использованных операций не изменяла оригинальную строку.

Все операции над строками в результате создают новую строку, потому что строки являются неизменяемыми – 
после того, как строка будет создана, ее нельзя изменить. В Python нельзя изменить строку присвоением 
значения одной из ее позиций, но вы всегда можете создать новую строку и присвоить ей то же самое имя. 

Поскольку Python очищает память, занятую ненужными больше объектами, такой подход не так уж неэффективен.

Все объекты в языке Python либо относятся к классу неизменяемых, либо нет. Если говорить о базовых типах,
то числа, строки и кортежи являются неизменяемыми, а списки и словари – нет (они легко могут изменяться
в любой своей части). Помимо всего неизменяемость может рассматриваться как гарантия, что некоторый 
объект будет оставаться постоянным на протяжении работы программы.

# Методы специфичные для типа (str)

Cтроки также имеют свои собственные операции, реализованные в виде методов. Метод строк find выполняет поиск
подстроки в строке (он возвращает смещение переданной ему подстроки или -1,если поиск не увенчался успехом),
а метод replace производит глобальный поиск с заменой:

в доступной мне среде разработки методы свойственные строкам появляються по команде - последовательность.()

anime.built-in method() - без скобочек ругается, утверждает что внутри скобочек не должно быть аргументов

Кроме того, строки поддерживают операции подстановки, известные как форматирование и доступные как в виде
выражений (существовали изначально), так и в виде методов строк (появились в версиях 2.6 и 3.0):

В Python служебные символы представлены, в виде последовательностей, начинающихся с символа обратного слеша.

Специальная форма определения многострочных строковых литералов – тройные кавычки или апострофы. Когда 
используется такая форма, все строки в программном коде объединяются в одну строку, а там, где в 
исходном тексте выполняется переход на новую строку, вставляется символ «конец строки». 
Это незначительное синтаксическое удобство весьма полезно для оформления в сценариях 
на языке Python крупных блоков текста, таких как разметка HTML или XML:

Кроме того, Python предоставляет поддержку литералов «неформатированных», «сырых» строк, в которых символ
обратного слеша интерпретируетсякак обычный символ (они начинаются с символа r), а также поддержку строк
с символами Юникода, обеспечивающих интернационализацию.

Файлы также изменились в версии 3.0, и теперь они возвращают и принимают объекты типа str только при работе
в текстовом режиме, а при работе в двоичном режиме – только объекты типа bytes.

# Встроенный модуль для поиска по шаблону

Необходимо импортировать модуль с именем re. Этот модуль содержит аналогичные функции для выполнения поиска,
разбиения и замены, но за счет использования шаблонов мы можем использовать более общие варианты решения.

>>> Major = "Ghost in the shell"
>>> import re                    # загрузка встроенного модуля re - поиск по шаблону в строке
>>> match = re.match("Ghost[ \t]*(.*)shell", "Ghost in the shell")
>>> print(match)                 # <_sre.SRE_Match object; span=(0, 18), match='Ghost in the shell'>
<_sre.SRE_Match object; span=(0, 18), match='Ghost in the shell'>
>>> match.group(0)               # возвращает 'Ghost in the shell'
'Ghost in the shell'
>>> match.group(1)               # возвращает искомую подстроку  'in the '
'in the '
>>> 

В этом примере выполняется поиск подстроки, начинающейся со слова «Ghost» и завершающаяся словом «shell»
В нотации поиска заданы условия: ноль или более символов табуляции и пробелов [ \t]* после "Ghost"
за которыми могут следовать произвольные символы (.*) соглано выражению: [ \t]*(.*)
искомы символы которые [ \t]*(.*) - будут сохранены, как группа совпадения 

поиск проводиться в адрес строки "Ghost in the shell" 

Если такая подстрока будет найдена, части ее, соответствующие шаблону, заключенному в круглые скобки будут
доступны в виде групп - match.group(1)

# Списки

Списки – это упорядоченные по местоположению коллекции объектов произвольных типов, размер которых не
ограничен. Кроме того, в отличие от строк, списки являются изменяемыми – они могут модифицироваться 
как с помощью операций присваивания по смещениям, так и с помощью разнообразных методов работы. 

# Операции над последовательностями

Поскольку списки являются последовательностями, они поддерживают все операции над последовательностями,
которые обсуждались в разделе, посвященном строкам.Единственное отличие состоит в том, что результатом
таких операций являются списки, а не строки. Например, для списка, состоящего из трех элементов:

# Методы, специфичные для типа list (список)

Списки в языке Python являются аналогом массивов в других языках программирования, но они обладают более
широкими возможностями. Они не ограничены одним типом элементов, только что рассмотренный список содержит
три элемента совершенно разных типов (целое число, строку и вещественное число). Кроме того, размер 
списков не ограничен, благодаря чему они могут увеличиваться и уменьшаться по необходимости.

Методы списков позволяют вставлять новые элементы в произвольное место списка (insert), удалять элемент,
заданный значением (remove), и так далее. Так как списки являются изменяемыми, большинство методов 
списков несоздают новый список, а изменяют оригинальный список.

Хотя списки не имеют фиксированного размера, язык Python, тем не менее, не допускает возможности обращаться
к несуществующим элементам списка.Обращение к элементам списка по индексам, значения которых выходят за 
пределы списка, всегда является ошибкой:

# Вложенные списки

Одна из замечательных особенностей базовых типов языка Python состоит в том, что они поддерживают возможность
создания вложенных конструкций произвольной глубины и в любых комбинациях (например, можно создать список,
содержащий словарь, который содержит другой список, и так далее).Одно из очевидных применений этой 
особенности – представление матриц, или «многомерных массивов» в языке Python. 
Делается это с помощью списка, содержащего вложенные списки:

>>> anime = [[11, 404, 11],
...          [11, 404, 11],
...          [404, 11, 11]]
... 
>>> anime
[[11, 404, 11], [11, 404, 11], [404, 11, 11]]
>>> 

Здесь мы реализовали список, состоящий из трех других списков. В результа те была получена матрица чисел
3 x 3. Обращаться к такой структуре можно разными способами:

>>> anime[1]                    # вернуть строку 2
[11, 404, 11]
>>> anime[1][2]                 # вернуть строку 2, элемент 3
11
>>> 

Соединение операций индексирования позволяет все дальше и дальше погружаться вглубь вложенной структуры
объектов.Такая организация матриц вполне пригодна для решения небольших задач, но для реализации более
сложных программ числовой обработки информации желательно использовать специализированные расширения,
например NumPy. Такого рода инструменты позволяют хранить и обрабатывать матрицы намного эффективнее,
чем такая структура, реализованная в виде вложенных списков. Как уже говорилось, расширение NumPy
превращает Python в свободный и более мощный эквивалент системы MatLab, и такие организации, 
как NASA, Los Alamos и JPMorgan Chase,используют его для решения научных и финансовых задач.
Дополнительную информацию об этом расширении вы без труда найдете в Сети.

# Генераторы списков

Помимо обычных операций над последовательностями и методов списков Python предоставляет возможность выполнять
более сложные операции над списками, известные как выражения генераторов списков (list comprehension
expression), которые представляют эффективный способ обработки таких структур, как матрица anime.

Предположим, например, что нам требуется извлечь из нашей матрицы второй столбец. Строку легко можно получить,
выполнив операцию индексирования, потому что матрица хранится в виде строк, однако, благодаря генераторам
списков, получить столбец ни чуть не сложнее:

>>> col2 = [row[1] for row in anime]
>>> col2                        # возвращает [404, 404, 11]
[404, 404, 11]
>>> anime
[[11, 404, 11], [11, 404, 11], [404, 11, 11]]
>>> 

Генераторы списков следуют традиции системы представления множеств; они позволяют создавать новые списки, 
выполняя выражение для каждого элемента в последовательности, по одному за раз, слева направо. Генераторы
списков заключены в квадратные скобки (чтобы отразить тот факт, что они создают список) и составлены из 
выражения и конструкции цикла, которые используют одно и то же имя переменной (в данном случае row).

В предыдущем примере генератор списков интерпретируется так: «Получить элементы row[1] из каждой строки
матрицы anime и создать из них новый список». Результатом является новый список, содержащий значения из
второго столбца матрицы. На практике генераторы списков могут приобретать еще более сложную форму:

>>> col3 = [shell[1] + 1 for shell in anime]
>>> col3
[405, 405, 12]
>>> 

# shell[1] + 1				Добавить + 1 к каждому элементу в столбце 2 в матрице anime

>>> col4 = [shell[1] for shell in anime if shell[1] % 2 == 0]
>>> col4
[404, 404]

# if shell[1] % 2 == 0		Отфильтровать нечётные значения (через if введён фильтр "поделить на два = 0")	

Операция использует условный оператор if для исключения из результата нечетных чисел с помощью операции
деления по модулю – % (остаток от деления).Генераторы списков, применяемые к спискам, возвращают в каче-
стве результатов новые списки, но могут использоваться и для любых других объектов, допускающих 
выполнение итераций.

Ниже показано использование генератора списков для обхода жестко заданного в программном коде списка 
координат и строк:

>>> diag = [anime[i][i] for i in [0, 1,2 ]]
>>> diag                        # возвращает выборку элементов диагонали матрицы [11, 404, 11]
[11, 404, 11]
>>> 

# встроенные фукнции для генераторов списков (сложная тема, вне рамом учебника, но - они есть)
- filter
- map 

Генераторы списков можно применять к любым типам, являющимся последовательностями в языке Python, а также
к некоторым типам, которые не являются последовательностями.

в последних версиях Python можно также использовать конструкции генераторов списков, заключенные в круглые
скобки, для создания генераторов, которые воспроизводят результаты по требованию. Например с помощью
встроенной функции sum можно сум мировать элементы в последовательности (без участия вложенных)

>>> g = (sum(row) for row in anime)
>>> next(g)                    # возвращает суммы элементов строк - 426
426

Суммы вложенных последовательностей можно считать с с помощью встроенной функции map, генерируя результаты 
за счет передачи элементов другой функции. Обертывание вызова этой функции в список (в версии Python 3.0) 
вынуждает ее вернуть все значения:

>>> list(map(sum, anime))      # возвращает [426, 426, 426]
[426, 426, 426]

Синтаксис генераторов списков может также использоваться для создания множеств и словарей - см.строку 156
По факту в версии 3.0 с помощью подобных выражений-генераторов можно создавать списки, множества и словари:

# Словари

Словари в языке Python – это нечто совсем иное; они вообще не являются последовательностями, это то, что
известно как отображения.Отображения – это коллекции объектов, но доступ к ним осуществляется не по 
определенным смещениям от начала коллекции, а по ключам. В действительности отображения вообще не
подразумевают какого-либо упорядочения элементов по их позиции, они просто отображают ключи на 
связанные с ними значения.Словари – единственный тип отображения в наборе базовых объектов
Python также относятся к классу изменяемых объектов: они могут изменяться непосредственно
и в случае необходимости могут увели чиваться и уменьшаться в размерах подобно спискам.

# Дзен

>>> [ord(x) for x in 'anime']              # возвращает список кодов символов в строке
[97, 110, 105, 109, 101]
>>> [ord(x) for x in 'Ghoost']             # возвращает [71, 104, 111, 115, 116]
[71, 104, 111, 111, 115, 116]
>>> {ord(x) for x in 'Ghoost'}             # множества ликвидируют дубликаты (дубликаты кодов)
{104, 116, 115, 111, 71}
>>> {x: ord(x) for x in "Ghost"}           # возвращает уникальные ключи своварей (это просто супер)
{'t': 116, 's': 115, 'h': 104, 'G': 71, 'o': 111}
>>> 

# Вложенные словари

>>> anime = {'Major': {'Ghost': "Shell", "Stand": "Alone"},
...          "Name": ["Kusanagi", "Motoka"],
...          'age': 99.9}
>>> 

Здесь мы опять имеем словарь, содержащий три ключа верхнего уровня (ключи "Major", "Name", "Age)", однако
значения имеют более сложную структуру: для описания майора используется вложенный словарь, чтобы
обеспечить поддержку имен, состоящих из нескольких частей, а для перечисления имён используется
вложенный  список, что обеспечит возможность расширения в будущем. К компонентам этой структуры
можно обращаться почти так же, как мы делали это в случае с матрицей, но на этот раз вместо
числовых индексов мы используем ключи словаря:

>>> anime["Major"]                       # возвращает {'Stand': 'Alone', 'Ghost': 'Shell'}
{'Ghost': 'Shell', 'Stand': 'Alone'}
>>> anime["Major"]["Stand"]              # обращение к элементу вложенного словаря, возрв. 'Alone'
'Alone'
>>> anime["Name"]                        # возвращает вложенный список ['Kusanagi', 'Motoka']
['Kusanagi', 'Motoka']
>>> anime["Name"][1]                     # возвращает элемент вложенного списка  'Motoka'
'Motoka'
>>> anime["Name"].append("Virus")
>>> anime

# Дзен

Обратите внимание, как последняя операция в этом примере выполняет расширение вложенного списка. Так как
список имён майора – это отдельный от словаря участок в памяти, он может увеличиваться и уменьшаться без
каких-либо ограничений.

# Гибкость

Основная цель демонстрации этого примера состоит в том, чтобы показать вам гибкость базовых типов данных в
языке Python. Здесь вы можете видеть, что возможность вложения позволяет легко воспроизводить достаточно
сложные структуры данных. Для создания подобной структуры на языке C потребовалось бы приложить больше
усилий и написать больше программного кода: нам пришлось бы описать и объявить структуры и массивы,
заполнить их значениями, связать их между собой и так далее. В языке Python все это делается 
автоматически – запуск выражения приводит к созданию всей структуры вложенных объектов. 
Фактически это одно из основных преимуществ языков сценариев, таких как Python.

# Методы работы со словарями.

В наиболее общем случае мы могли бы получить список всех ключей словаря методом keys, отсортировать их с
помощью метода списка sort и затем выполнить обход значений в цикле for:

>>> D = {"a": 1, "b": 2, "c": 3}
>>> Ks = list(D.keys())                  # создание неупорядоченного списка ключей из словаря
>>> Ks.sort()                            # сортировка списка ключей по алфавиту
>>> Ks                                   # возвращает ['a', 'b', 'c']
['a', 'b', 'c']
>>> for key in Ks:                       # обход списка ключей
...     print(key, "=", D[key])
a = 1
b = 2
c = 3
>>>

Этот процесс, состоящий из трех этапов, в последних версиях Python можно упростить до единственной
операции с помощью новой встроенной функции sorted . Эта функция сортирует объекты разных типов и
возвращает результат: 

>>> D = {"a": 1, "c": 3, "b": 2,}
>>> for key in sorted(D):                 # использование втроенной функции sorted упрощает код
...     print(key, "=", D[key])
a = 1
b = 2
c = 3
>>> 

Этот пример может служить поводом для знакомства с циклом for языка Python. Цикл for представляет
собой самый простой и эффективный способ произвести обход всех элементов в последовательности и
выполнить блок программного кода для каждого из элементов. Переменная цикла, определяемая
пользователем (key), служит для ссылки на текущий элемент. В этом примере выводятся ключи
и значения несортированного словаря в отсортированном по ключам виде.

# Цикл For

Цикл for и родственный ему цикл while – это основные способы реализации повторяющихся действий в
сценариях. Однако в действительности цикл for (так же, как и родственные ему генераторы списков,
с которыми мы познакомились выше), является операцией над последовательностью. Он способен
работать с любыми объектами, являющимися последовательностями, а также с некоторыми 
объектами, которые последовательностями не являются.

>>> for shell in 'anime':
...     print(shell.upper())
A
N
I
M
E
>>> 

# shell - это условный оператор, он может быть любым.

# Цикл While

Цикл while в языке Python представляет собой более инстру мент выполнения циклически повторяющихся
операций и не имеет прямой связи с последовательностями:

>>> anime = 4
>>> while anime > 0:                      # пока anime больше 0 
...     print("shell" * anime)            # печатать строку shell помноженную на значение переменной anime
...     anime -= 1                        # хитрая штука, которая предотващает бесконечное воспроизведение
... 
... # если в команде anime - = 1  убрать (-) - цикл будет выполняться бесконечно, значение перемнной - шаг.
shellshellshellshell
shellshellshell
shellshell
shell
>>> 

# Интерации и оптимизация

Любой инструмент языка Python, сканирующий объект слева направо, использует протокол итераций.
Именно поэтому функция sorted, которая использовалась в предыдущем разделе, способна работать
со словарем непосредственно – нам не требуется вызывать метод keys для получения 
последовательности, потому что словари являются итерируемыми объектами, для
которых функция next возвращает следующий ключ.

Любой генератор списков всегда можно представить в виде эквивалентного цикла for, который создает
список с результатами, добавляя новые элементы в ходе выполнения итераций:

>>> cub = [x ** 2 for x in [1,2,3,4,5]]   # генератор списков - который вычисляет квадраты чисел в списке
>>> cub                                   # возвращает [1, 4, 9, 16, 25]
[1, 4, 9, 16, 25]
>>> cub = []                              # создание спика
>>> for x in [1,2,3,4,5]:                 # создание списка чисел в списке cub
...     cub.append(x**2)                  # вычисление согласно протоколу интераций (слева направо)
... 
>>> cub                                   # возвращает [1, 4, 9, 16, 25]
[1, 4, 9, 16, 25]
>>> 

Генераторы списков и родственные им инструменты функционального программирования, такие как функции
map и filter, обычно выполняются быстрее, чем цикл for (примерно раза в два), что особенно важно
для программ, обрабатывающих большие объемы данных.

# Кортежи 

Объект-кортеж в общих чертах напоминает список, который невозможно изменить – кортежи являются 
последовательностями, как списки, но они являются неизменяемыми, как строки. Синтаксически
литерал кортежа заключается в круглые, а не в квадратные скобки. Кортежи также поддерживают
включение объектов различных типов, вложение и операции, типичные для последовательностей:
>>> anime = (1,2,3,4,5,11)
>>> anime    
(1, 2, 3, 4, 5, 11)
>>> anime.append(+1)                     
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'tuple' object has no attribute 'append'

>>> anime = (1,2,3,4,5,11)                
>>> anime[0]                             
1
>>> anime[0] = 11
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment

>>> anime = (1,2,3,4,5,11)                # кортеж
>>> shell = anime + anime
>>> shell
(1, 2, 3, 4, 5, 11, 1, 2, 3, 4, 5, 11)
>>> 

Подобно спискам и словарям кортежи способны хранить объекты разных типов и допускают возможность
вложения, но в отличие от них, не могут изме нять свои размеры, так как являются неизменяемыми
объектами:

>>> anime = ("Major", 2.0, [11, 404, "Ghost"])   # тот же список - только его изменять нельзя
>>> anime[1]                                     # возвращает 2.0
2.0
>>> anime[-1]                                    # возвращает [11, 404, 'Ghost']
[11, 404, 'Ghost']
>>> anime[2][0]                                  # возвращает  11
11
>>> anime[2][-1]                                 # возвращает 'Ghost'
'Ghost'
>>> anime.append(4)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'tuple' object has no attribute 'append'
>>> 

# Дзен кортежа - неизменяемость (по факту - следствие динамической типотизации языка Python)

Поскольку Python использует динамическую типотизацию в качестве годноты, он нуждается в объекте,
который позволяет сохранять данные в неизменном виде при работе с ними, грубо говоря кортежи это 
костыль для языка, котороый позволяет менять тип данных в процессе работы с ними.

На практике кортежи используются не так часто, как списки, главное их достоинство – неизменяемость.
Если коллекция объектов передается между компонентами программы в виде списка, он может быть
изменен любым из компонентов. Если используются кортежи, такие изменения становятся
невозможны. То есть кортежи обеспечивают своего рода ограничение целостности,
что может оказаться полезным в крупных программах. 

# Файлы

Объекты-файлы – это основной интерфейс между программным кодом на языке Python и внешними файлами
на компьютере. Файлы являются одним из базовых типов, но они представляют собой нечто необычное,
поскольку для файлов отсутствует возможность создания объектов в виде литералов. Вместо этого,
чтобы создать объект файла, необходимо вызвать встроенную функцию open, передав ей имя
внешнего файла и строку режима доступа к файлу.

Например, чтобы создать файл для вывода данных, вместе с именем файла функции необходимо передать
строку режима ‘w’:

>>> anime = open("data.txt", "w")        # создание файла data.txt для вывод - "w"
>>> anime.write("Hello\n")               # запись строки байтов в файл - возвращает 6
6
>>> anime.write("Ghost in the shell")    # возвращает 18
18
>>> len("Ghost in the shell")            # 18
18
>>> anime.close()                        # закрывает файл и выталкивает выходные буферы на диск
>>> 

В этом примере создается файл в текущем каталоге и в него записывается текст (имя файла может 
содержать полный путь к каталогу, если требуется получить доступ к файлу, находящемуся в 
другом месте). 

Чтобы прочитать то, что было записано в файл, его нужно открыть в режиме  ‘r’ (этот режим 
используется по умолчанию, если строка режима в вызове функции опущена). Затем прочитать
содержимое файла в строку и отобразить ее. Содержимое файла для сценария всегда является
строкой независимо от типов данных, фактически хранящих ся в файле:

>>> anime = open("data.txt")             # без указания режима доступа
>>> text = anime.read()                  # читать файл целиком в строку
>>> text                                 # возвращает 'Hello\nGhost in the shell'
'Hello\nGhost in the shell'
>>> print(text)                          # вывод ( с попутной интерпретацией слежубных символов)
Hello
Ghost in the shell
>>> anime = open("data.txt", "r")        # ‘r’ – это режим доступа к файлу по умолчанию
>>> text = anime.read()                  # читать файл целиком в строку
>>> text                                 # возвращает 'Hello\nGhost in the shell'
'Hello\nGhost in the shell'
>>> print(text)                          # вывод ( с попутной интерпретацией слежубных символов)
Hello
Ghost in the shell
>>> text.split()                         # содержимое файла всегда является строкой - возвращает .str
['Hello', 'Ghost', 'in', 'the', 'shell']
>>> 

# Дзен файлов

Самый лучший на сегодняшний день способ чтения файлов состоит в том, чтобы не читать его содержимое
целиком – файлы предоставляют итераторы, которые обеспечивают автоматическое построчное чтение
содержимого файла в циклах for и в других контекстах.

При работе с файлами в Python 3.0 проводится очень четкая грань между текстовыми и двоичными данными.
Содержимое текстовых файлов представляется в виде строк и для них автоматически выполняется
кодирование и декодирование символов Юникода. Содержимое двоичных файлов представляется в 
виде строк специального типа bytes, при этом никаких автоматических преобразований
содержимого файлов не производится:

# Ахтунг!!!

>>> anime = open("data.bin", "rb").read()# открыть файл data.bin в режиме - чтения байтов rb, прочитать всё()
>>> anime                                # возвращает b'Hello\r\nGhost in the shell'
b'Hello\r\nGhost in the shell'
>>> anime[4:8]                           # возвращает b'o\r\nG'
b'o\r\nG'
>>> 

Либо я в чём то не прав, либо в более поздней версии питончика (3.5хх) преобразование происходит.

# Дзен встроенных фукнций при работе с файлами.

Функция open – это рабочая лошадка в большинстве операций с файлами, которые можно выполнять в языке
Python. Для решения более специфичных задач Python поддерживает и другие инструментальные средства,
напоминающие файлы: каналы, очереди, сокеты, файлы с доступом по ключу, файлы-хранилища объектов,
файлы с доступом по дескриптору, интерфейсы к реляционным и объектно-ориентированным базам данных
и многие другие.

# Другие базовые типы данных

Помимо базовых типов данных, существуют и другие, которые могут считаться базовыми в зависимости от
широты определения этой категории. Например, множества, совсем недавно появившиеся в языке, – 
которые не являются ни последовательностями, ни отображениями. 

Множества – это неупорядоченные коллекции уникальных и неизменяемых объектов. Множества создаются 
встроенной функцией set или с помощью новых синтаксических конструкций определения литералов и
генераторов множеств и поддерживают типичные математические операции над множествами.
 
Выбор синтаксической конструкции {...} для определения литералов множеств в версии 3.0 не случаен,
поскольку множества напоминают словари, в которых ключи не имеют значений:

>>> anime = set("Ghost int the shell")   # создание множества через встроенную фукнцию set
>>> anime                                # возвращает {'i', 't', 'n', 'e', 'l', ' ', 'h', 'o', 'G', 's'}
{'e', 'l', 'h', 't', ' ', 'G', 'o', 'n', 's', 'i'}
>>> shell = {"E","l","e","v","e","n"}    # в версии 3.0+ можно определять литераты множеств
>>> anime,shell                          # возвращает годноту
({'e', 'l', 'h', 't', ' ', 'G', 'o', 'n', 's', 'i'}, {'E', 'e', 'l', 'n', 'v'})
>>> 

Кроме того, недавно в Python появились вещественные числа с фиксированной точностью и рациональные
числа (числа, представленные дробью, то есть парой целых чисел – числителем и знаменателем). Обе
разновидности могут использоваться для решения проблем, связанных с точностью представления
простых вещественных чисел:

# вещественные числа

>>> 1 / 3
0.3333333333333333
>>> (2/3) + (1/2)
1.1666666666666665
>>> 

# вещественные числа с фиксированной точностью

>>> import decimal                       # вещественные числа с фиксированной точностью
>>> data = decimal.Decimal("3.141")
>>> data + 1                             # возвращает Decimal('4.141')
Decimal('4.141')
>>> 

>>> from fractions import Fraction       # рациональные числа - числитель и знаменатель
>>> data = Fraction(2,3)                 #
>>> data + 2                             # возвращает Fraction(8, 3)  ( data + x = 2 + 3 * x)
Fraction(8, 3)
>>> 

# Логический тип данных

Кроме того в языке Python имеется логический тип данных (представленный предопределенными объектами
True и False, которые по сути являются обычными целыми числами 1 и 0 с некоторыми особенностями 
отображения на экране), а кроме того, давно уже существует специальный объект None, обычно
используемый для инициализации переменных и объектов:

>>> 1 > 2, 2 > 1                         # возвращает (False, True)
(False, True)
>>> bool("anime")                        # возвращает True
True
>>> x = None
>>> print(x)                             # возвращает None
None
>>> L = [None] * 100
>>> L                                    # возвращает 100 объектов None

# Как можно нарушить гибкость программного кода

Тип объекта, возвращаемый встроенной функцией type, в свою очередь сам является объектом.

>>> anime = [11, "Major", "shell", 404]  # список для примера про гибкость кода: с.148
>>> type(anime)                          # возвращает <class 'list'>   - "список" это класс
<class 'list'>
>>> type(type(anime))                    # возвращает <class 'type'>   - "тип" это класс
<class 'type'>
>>> if type(anime) == type([]):          # проверка класса объекта: если объект anime это список, тогда
...     print("Yes")                     # возвращает Yes
... 
Yes
>>> if type(anime) == type({}):          # если объект anime это словарь, тогда 
...     print("Yes")
... elif type(anime) == type(()):
...     print("append")
... elif type(anime) == str:             # проверка и использованием имени типа объекта - строки
...     print("str")
... elif type(anime) == int:             # проверка и использованием имени типа объекта - числа
...     print("int")
... else:
...     print("NO")                      # возвращает NO
... 
NO
>>> if isinstance(anime, list):          # проверка в объекто-ориентированном стиле
...     print("Yes")                     # возвращает YES
Yes
>>> 

# Подробнее о классах типов рассказывается в главе 31

Bспользование таких проверок в программном коде практически всегда является неверным решением и
отличительным признаком бывшего программиста на языке C, приступившего к программированию на 
языке Python.

Наличие проверок на принадлежность объекта к тому или иному типу отрицательно сказывается на
гибкости программного кода, потому что вы ограничиваете его работой с единственным типом 
данных. Без таких проверок ваш программный код может оказаться в состоянии работать с
более широким диапазоном типов.

# Дзен - гибкость кода: наше всё ( смотри как работает переменная story в моём словаре) 202.

Как будет говориться далее, программный код на языке Python ориентируется на использование
интерфейсов объектов (наборов поддерживаемых операций), а не их типов. Отсутствие заботы
об определенных типах означает, что программный код автоматически может обслуживать
большинство из них – допустимыми будут любые объекты с совместимыми интерфейсами
независимо от конкретного типа. И хотя контроль типов поддерживается, а в редких
случаях даже необходим, тем не менее, такой способ мышления чужд языку Python.

# Классы, определяемые пользователем

Дзен объектно-ориентированного стиля программирова нияна языке Python, который позволяет сократить
время, затрачиваемое на разработку можно абстрактно описать терминами "классов". Классы определяют
новые типы объектов, которые расширяют базовый набор.

Например, вам мог бы потребоваться такой тип объектов, который моделировал бы дзен заниме. В языке
Python нет такого базового типа, тем не менее, следующий класс вполне мог бы удовлетворить ваши
потребности:

Описание класса

>>> class anime:                         # задаём имя класса
...     def __init__(self, name, story, pay):              # инициализация при создании, self это сам объект 
...         self.name = name                               # атрибут name
...         self.story = story                             # атрибут story
...         self.pay = pay                                 # атрибут pay

Данный класс определяет новый тип объектов, которые обладают атрибутами name, story, pay (иногда
атрибуты называют информацией о состоянии), а также тремя описаниями поведения, оформленными в
виде функций (которые обычно называют методами). Обращение к имени класса как к функции при
- водит к созданию экземпляра нового типа, а методы класса автоматически получают ссылку на
текущий экземпляр, обрабатываемый этими методами (аргумент self):

Описание методов класса

>>> def LastName(self):                  # метод 
...     return self.name.split()[-1]     # описание поведения объекта свойсвтенному классу в рамках метода
... 
>>> def LastStory(self):                 # метод
...     return self.name.split()[-1]     # разбить строку по символам пробела 
... 
>>> def Payment(self, percent):          # метод
...     self.pay *= (1.0 + perent)       # обновить сумму выплат

# Дзен 

имя класса (anime)
	объекты класса (self,name,story,pay)
		атрибуты объектов класса (name,story,pay_)
метод (функиця через аргумент self)
	описание метода (тело фукнции через аргумент self)

>>> class anime:                         # задаём имя класса
...     def __init__(self, name, story, pay):              # инициализация при создании, self это сам объект 
...         self.name = name                               # атрибут name
...         self.story = story                             # атрибут story
...         self.pay = pay                                 # атрибут pay
...     def LastName(self):                  # метод 
...         return self.name.split()[-1]     # описание поведения объекта свойсвтенному классу в рамках метода
...     def LastStory(self):                 # метод
...         return self.story.split()[-1]    # разбить строку по символам пробела 
...     def Payment(self, percent):          # метод
...         self.pay *= (1.0 + percent)      # обновить сумму выпла на %, размер % необходмио будет указать
... 
>>> Major = anime("Matoko Kusanagi", "Stand Alone Complex", 111)
>>> Lina = anime("Lina Inverse", "Dragon Slayer", 404)
>>> Celcia = anime("Elven Princess", "Talking Dog", 10)
>>> Major.name                           # возвращает 'Matoko Kusanagi'
'Matoko Kusanagi'
>>> Major.story                          # возвращает 'Stand Alone Complex'
'Stand Alone Complex'
>>> Major.pay                            # возвращает  111
111
>>> Major.LastName()                     # возвращает  'Kusanagi'
'Kusanagi'
>>> Lina.LastStory()                     # возвращает  'Slayer'
'Slayer'
>>> Celcia.Payment(.10)                  # указываем процент на который необходимо увеличить оплату (.x)
>>> Celcia.pay                           # возвращает 11.0
11.0
>>> type(anime)                          # возвращает <class 'type'>
<class 'type'>
>>> type(Major)                          # возвращает <class '__main__.anime'>
<class '__main__.anime'>
>>> 

# Дзен 
# Self - подразумеваемый объект.

Модель называется объектно-ориентированной потому, что здесь присутствует подразумеваемый объект
«self»: внутри функций, определяемых в классах, всегда присутствует подразумеваемый объект.

В некотором смысле типы, основанные на классах, просто создаются на базе основных типов и
используют их функциональные возможности. В данном случае пользовательский класс anime –
это всего лишь коллекция, состоящая из строки и числа (name, story и pay соответственно),
плюс функции, выполняющие обработку этих трёх встроенных объектов.

имя класса (anime)
	объекты класса (self,name,story,pay)
		атрибуты объектов класса (name,story,pay_)
метод (функиця через аргумент self)
	описание метода (тело фукнции через аргумент self)
экземпляр класса: имя переменной = класс(атрибут, атрибут, артибут)

Процесс обращения к объектм класса происходит с помощью подразумеваемого объект self.

>>> Major.LastName()   # вызов метода LastName, self - это Major
>>> Lina.LastStory()   # вызов метода LastStory, self - это Lina 

В условном прочтении фукнция Laststory с использованием объетка "Lina" класса "anime" звучит так:

		def LastStory(self):                 # метод класса anime приминительно к объекту self
...         return self.story.split()[-1]    # вернуть объект self с атрибутом story с -1 индексом

т.е при обращении к Lina по методу lastStory - вернуть объект Lina с атрибутом story с -1 индексом.
 
По факту объект self - является условностью, необходимой в условиях программирования, self это 1 
которая имеет бесконечно возможное число значений и бесконечно возможное число прочтений тем или
иным методом. Поскольку компьютер не способен записать "неопределённую условность" - мы даём ему
то, что он способен понять - объект, допустимый для чтения и записи. Фактически вся идея классов
это ни что иное как описание единственного объекта - self. 

По факту, то, что они называют "объектным-ориентированием" - является допустимым решением теории
условностей в информатике, основанной на комбинаторике допусков. Допуск а) может утверждать что 
объект self равен 0 - в то время как допуск б) может утверждать обратное. И то и другое верно в
языке сценарного типа и не противоречит себе в силу того, что эти допуски реализованы в качестве
сценариев. Я могу записать крамольное 1 == 0 через объект self и компьютер согласиться со мной в 
рамках сценария, если сценарий будет это дпускать.

Люди, которые это придумали - не глупей меня.