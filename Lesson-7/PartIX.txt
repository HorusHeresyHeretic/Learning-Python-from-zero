Глава 9 Файлы и кортежи, с этим артефактом связан файл PartIX.py

# Кортежи

Кортежи представляют собой простые группы объектов. Они действуют точно так же, как списки, за исключением 
того, что не допускают непосредственного изменения (ониявляются неизменяемыми) и в литеральной форме 
записываются как последовательность элементов в круглых, а не в квадратных скобках.

# Это упорядоченные коллекции объектов произвольных типов.

Подобно строкам и спискам, кортежи являются коллекциями объектов, упорядоченных по позициям (то есть они 
обеспечивают упорядочение своего содержимого слева направо). Подобно спискам, они могут содержать объ-
екты любого типа.

# Обеспечивают доступ к элементам по смещению

Подобно строками и спискам, доступ к элементам кортежей осуществляется по смещению (а не по ключу) – они
поддерживают все операции, которые основаны на использовании смещения, такие как индексирование и извле-
чение среза.

# Относятся к категории неизменяемых последовательностей

Подобно строкам и спискам, кортежи являются последовательностями и поддерживают многие операции над
последовательностями. Однако, подобно строкам, кортежи являются неизменяемыми объектами, поэтому
они не поддерживают никаких операций непосредственного изменения, которые применяются к спискам.

# Имеют фиксированную длину, гетерогенны и поддерживают произвольное число уровней вложенности.

Поскольку кортежи являются неизменяемыми объектами, вы не можете изменить размер кортежа, минуя процедуру 
создания копии. С другой стороны, кортежи могут хранить другие составные объекты (то есть списки,
словари и другие кортежи), а следовательно, поддерживают произвольное число уровней вложенности.

# Массивы ссылок на объекты

Подобно спискам, кортежи проще представлять, как массивы ссылок на объекты, – кортежи хранят указатели
(ссылки) на другие объекты, а операция индексирования над кортежами выполняется очень быстро.

# Тут есть над чем подумать.

вот это по идеии вложенный кортеж:

>>> anime = (1, ("manga", 1.2), 5)     
>>> anime
(1, ('manga', 1.2), 5)

тогда почему этот не вложенный?

>>> anime = (1, ("manga"), 1.2, 5)
>>> anime
(1, 'manga', 1.2, 5)
>>> 

Лутц тоже приводит в качестве примера вложенного кортежа - кортеж  двумя элементами в скобках:

>>> T = ("abc", ("def", "ghi"))
>>> T
('abc', ('def', 'ghi'))
>>> 

>>> T = ("abc", ("def"), "ghi")
>>> T
('abc', 'def', 'ghi')
>>> 

(!) правильно получаеться так:

>>> T = ("abc", ("def",), "ghi")
>>> T
('abc', ('def',), 'ghi')
>>> 

Также стоит обратить внимание на правильную работу правила, в кортеже ("abc", (х), "ghi") существует объект Х
в качестве вложения, следовательно при обращении по индексу кортеж имеет вид:

3 индекса первого порядка в отношении объекта "abc" , 
3 индекса второго порядка в отношении объекта "ghi" и
неизвестно число индексов третьего порядка в отношении Х

>>> T = ("abc", ("def",), "ghi")
>>> T[0][0]                            
'a'
>>> T[0][1]                            
'b'
>>> T[0][2]                            
'c'
>>> T[1][0]                            
'def'
>>> T[2][1]                             
'h'
>>> 

Поэтому, если мы хотим получить d из def - нужно использовать невиданную доселе магию, обращение 
- к индексу, индекса, индекса

>>> T[1][0][0]
'd'
>>> 

В полном виде этот пример, который я только что придумал, потому что меня переклинил мой посстравматический 
синдром до степени - прощай жестокий мир, здравствуйт окно 12 этажа и пришлось срочно закидываться таблетками
- в полном виде этот очень поучительный пример выглядит так:

>>> T = ("abc", ("def",), "ghi")
>>> T[0][0]                            
'a'
>>> T[0][1]                            
'b'
>>> T[0][2]                            
'c'
>>> T[1][0]                            
'def'
>>> T[2][0]                            
'g'
>>> T[2][1]                            
'h'
>>> T[2][2]                            
'i'
>>> T[1][0][0]                         
'd'
>>> T[1][0][1]                         
'e'
>>> T[1][0][2]                         
'f'
>>> 

Первым индексом (первый у нас идёт под циферкой 0) индекса второго объекта кортежа является объект "def", а
для доступа к элементам свойственным объекту "def" необходимо образаться вглубину через name[x][x][x] - чтоъ
лишний раз доказывает полезность правила голден боя "учиться учиться учиться" по сравнению с внезапным позывом
прекратить весь этот балаган.

Но в целом это не праздник жизни когда в 32 ты отчетливо понимаешь что у тебя только две альетрантивы суициду:
- первая, это сесть за комп и чему то научится,  вторая - испортить себе жизнь в российской психиатрии 
которой на тебя похуй. Таблетки заканчиватьюся. Надо срочно что то менять. Или рано или поздно я не
остановлюсь. Но опуститься до похода в анонимную психиатрическую помощь я реально не готов.

Сука - ну вот как так может перклинить из за птср на почве просмотра видео про котиков, про котиков КАРЛ!

# история с запятой (я был прав)

Поскольку круглые скобки могут также окружать выражения (глава 5), необходимо что-то предпринять, чтобы дать
интерпретатору понять, что единственный объект в круглых скобках – это кортеж, а не простое выражение.

Если вам действительно необходимо получить кортеж с единственным элементом, нужно просто добавить запятую 
после этого элемента, перед закрывающей круглой скобкой:

>>> anime = (1,)                       # Кортеж из одного элемента (не выражение)
>>> print(anime)
(1,)
>>>

>>> x = (40)						   # Целое число
>>> x
40

В виде исключения при определении кортежей интерпретатор позволяет опускать открывающую и закрывающую круглые 
скобки, если синтаксически конструкция интерпретируется однозначно. Например, кортеж создается простым
перечислением четырех элементов, разделенных запятыми. В контексте операции присваивания интерпретатор
распознает, что это кортеж, даже при отсутствии круглых скобок.

>>> anime = 1, "Ghost shell", 1.2, 5   # по факту кортежи можно записывать без скобок
>>> anime
(1, 'Ghost shell', 1.2, 5)
>>> 

Единственное место, где круглые скобки являются обязательными, – при передаче кортежей функциям в виде литералов
(где круглые скобки имеют важное значение) и при передаче их инструкции print в версии Python 2.X (где важное
значение имеют запятые).

# Преобразования, методы и неизменяемость

Несмотря на отличия в синтаксисе литералов, операции, выполняемые над кортежами, идентичны операциям, приме-
няемым к строкам и спискам. Единственное отличие состоит в том, что операции +, * и извлечения среза при
применении к кортежам возвращают новые кортежи, а также в том, что в отличие от строк, списков и 
словарей, кортежи имеют сокращенный набор методов.

Если, к примеру, необходимо отсортировать содержимое кортежа, его сначала следует преобразовать в список,
чтобы превратить в изменяемый объект и получить доступ к методу сортировки или задействовать новую
функцию sorted, которая принимает объекты любых типов последовательностей (и не только):

# Лутц забыл сказать чт оесли кортеж состоит из элементов разных типов - фиг ты его отсортируешь

>>> anime = (11, 501, "Ghost", "Shell")
>>> print(anime)                     # кортеж (11, 501, 'Ghost', 'Shell')
(11, 501, 'Ghost', 'Shell')
>>> anime = list(anime)
>>> anime                            # список [11, 501, 'Ghost', 'Shell']
[11, 501, 'Ghost', 'Shell']
>>> try:
...     anime.sort()                 # unorderable types: str() < int()
... except TypeError:
...     print(anime)
[11, 501, 'Ghost', 'Shell']
>>> 

читай супер понятный материал про перехват исключений

https://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html


>>> anime = (11, 501, 404, 00)
>>> print(anime)
(11, 501, 404, 0)
>>> anime = list(anime)
>>> anime.sort()
>>> anime
[0, 11, 404, 501]
>>> anime = tuple(anime)
>>> anime
(0, 11, 404, 501)
>>> 

>>> anime = (11, 501, 404, 00)
>>> sorted(anime)
[0, 11, 404, 501]
>>>  

Здесь list и tuple – это встроенные функции, которые используются для преобразования в список и затем обратно
в кортеж. В действительности обе функции создают новые объекты, но благодаря им создается эффект 
преобразования.

Важно отметить, что за счёт того, что фукнции list и tuple создают новые объекты в системной таблице - они
также создают и новые ссылки на эти объекты, поэтому в алгоритме и при его исполнении:

>>> anime = (11, 501, 404, 00)
>>> anime = list(anime)
>>> anime
[11, 501, 404, 0]
>>> 

в действительности будет существовать только одна ссылка anime на один объект - список объектов anime, а
другая ссылка anime (первая, которая указыват на список объектов кортежа) - будет разименованна.
 
# Для преобразования кортежей можно также использовать генераторы списков. Например, ниже из кортежа 
создается список, причем попутно к каждому элементу прибавляется число 20:

>>> anime = (11, 501, 404, 00)
>>> ghost = [i + 20 for i in anime]
>>> ghost
[31, 521, 424, 20]
>>> 

Генераторы списков в действительности являются операциями над последовательностями – они всегда создают новые
списки, но они могут использоваться для обхода содержимого любых объектов последовательностей, включая 
кортежи, строки и другие списки.

(!)

они могут применяться даже к программным компонентам, которые физически не являются последовательностями, – к
любым объектам, поддерживающим возможность выполнения итераций, включая файлы, которые автоматически 
читаются строка за строкой.

# Методы доступные для кортежей

Кортежи обладают всего двумя методами – index и count, которые действуют точно так же, как одноименные методы
списков:

>>> anime = (11, 501, 11, 501, 404, 11, 11)
>>> anime.index(11)          # первое вхождение по индексу 11 находиться на первой позиции - возвращает 0
0
>>> anime.index(501)         # первое вхождение по индексу 501 находиться на второй позиции - возвращает 1
1
>>> anime.index(11, 2)       # второе вхождение по индексу 11 находиться на третьей позиции - возвращает 2 
2
>>> 

# Неизменяемость

Следует заметить, что правило неизменяемости применяется только к самому кортежу, но не к объектам, которые
он содержит. Например, список внутри кортежа может изменяться как обычно:

>>> anime[2][0] = 501
>>> anime
(11, 501, [501, 501], 404, 11, 11)
>>> anime = (11, 501, [11, 501], 404, 11, 11)
>>> anime[0]                       #  возвращает элемент кортежа - возвращает 11, этот элемент нельзя измениьь
11
>>> anime[1]                       #  возвращает элемент кортежа - возвращает 501  и его нельзя изменить тоже
501
>>> anime[2]                       #  возвращает список - возвращает [11, 501], элементы списка можно имзенять.
[11, 501]
>>> anime[2] = [11]                #  возвращает исключение 'tuple' object does not support item assignment
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> anime[2][0] = 501
>>> anime                          #  возвращает (11, 501, [501, 501], 404, 11, 11)
(11, 501, [501, 501], 404, 11, 11)
>>> anime[2][1] = "Ghost"
>>> anime
(11, 501, [501, 'Ghost'], 404, 11, 11)
>>> 

Дао в том что сам кортеж изменить никак нелья - когда я пытался скормить интерпретатору команду anime[2] = [11] 
- он посчитал это посягательством на целосность кортежа = изменением элемента кортежа в кортеже, так нельзя.
- потому что "изменение элементов кортежа в кортеже" и есть попытка изменить сам кортеж - а он неизменяемый.
  
Но (!) можно имзенять элементы ВНУТРИ изменяемого элемента вложенного в кортежа - например список по индексам
списка.

# Дзен о том - зачем нужны кортежи.

(ясень пень зачем - затем чтобы единожды записать неизменяемое выражение, например результат счисления рядов)

Создатель языка Python – математик по образованию, и он рассматривал кортежи, как простые ассоциации объектов,
а списки – как структуры данных, допускающие изменения в течение всего времени своего существования.

Единственная годнота от Лутца - использование Кортежей для обозначения строк в таблицах реляционных баз данных.

Но, если спросить меня, то Лутцу просто не хватает математического бэкграунда, конечно он немного повешал о
- константах, с точки зрения других языков программирования, цитирую:

"""неизменяемость кортежей обеспечивает своего рода поддержку целостности – вы можете быть уверены, что
кортеж не будет изменен посредством другой ссылки из другого места в программе, чего нельзя сказать о 
списках. Тем самым кортежи играют роль объявлений «констант», присутствующих в других языках
программирования, несмотря на то, что в языке Python это понятие связано с объектами, а не
с переменными."""

Реальность дядка Лутц более проста и сурова: если создатель Питона - математик, то он как никто нуждался в
константах, вся прикладная математика и все сложные счисления практического порядка так или иначе зависят от
известным нам констант, например нам известна константа силы притяжения земли. Поэтому автор Питончика решил,
что будет записывать все константы из математики, физики и химии в таком типе объкта - который никогда и ни
при каких обстоятельства не поедит в сторону в результате многострочных вычислений, основанных на списках и 
словарях ( я хоть и хуёвый математик, но даже я вижу как испоьзовать список или словарь для счисления) ввиду
того, что они - списки и словари, как объекты допускают изменяемость содержимого.

Представь себе дядька Лутц что алгоритм на 100500 строк счисления процесса запуска ракеты на Луну поехал наХ,
потому что где то внутри него изменилась константа, которую до этого вычисляли 100500 учёных в течении веков.

то то.

(!) # ФАЙЛЫ

Файлы – именованные области постоянной памяти в компьютере, которыми управляет операционная система.

Встроенная функция open создает объект файла, который обеспечивает связь с файлом, размещенным в компьютере. 
После вызова функции open можно выполнять операции чтения и записи во внешний файл, используя методы 
полученного объекта.

open faliname = создать объект файла (и как следствие ссылку на этот объект в системной таблице)

Файлы не являются ни числами, ни последовательностями или отображениями – для задач работы с файлами они 
предоставляют одни только методы. Большинство методов файлов связаны с выполнением операций ввода-вывода 
во внешние файлы, ассоциированные с объектом, но существуют также методы, которые позволяют переходить 
на другую позицию в файле, выталкивать на диск буферы вывода и так далее.

(слева просто рандомные имена для ссылок которые придумал Лутц)

# output = open(r"C:\spam", "w")   Открывает файл для записи ("w" означает write – запись)  
# input = open("data", "r")		   Открывает файл для чтения  ("r" означает read – чтение)
# input = open(‘data’)			   То же самое, что и в предыдущей строке (режим ‘r’ используется по умолчанию)
# aString = input.read()		   Чтение файла целиком в единственную строку
# aString = input.read(N)		   Чтение следующих N символов (или байтов) в строку
# aString = input.readline()	   Чтение следующей текстовой строки(включая символ конца строки) в строку
# aList = input.readlines()		   Чтение файла целиком в список строк (включая символ конца строки)
# output.write(aString)			   Запись строки символов (или байтов) в файл
# output.writelines(aList)		   Запись всех строк из списка в файл
# output.close()				   Закрытие файла вручную (выполняется по окончании работы с файлом)
# output.flush()				   Выталкивает выходные буферы на диск,файл остается открытым
# anyFile.seek(N)				   Изменяет текущую позицию в файле для следующей операции, смещая ее на N байтов от начала файла.
# for line in open(‘data’):        Итерации по файлу, построчное чтение
	операции над line
# open("f.tx",encoding="latin-1")  Файлы с текстом Юникода в Python 3.0(строки типа str)
# open("f.bin", "rb")			   Файлы с двоичными данными в Python 3.0 (строки типа bytes)

Открытие файлов

Чтобы открыть файл, программа должна вызвать функцию open, передав ей имя внешнего файла и режим работы. 
Обычно в качестве режима используется строка ‘r’, когда файл открывается для чтения (по умолчанию),
‘w’ – когда файл открывается для записи или 
‘a’ – когда файл открывается на запись в конец.

• Добавление символа b в строку режима означает работу с двоичными данными (в версии 3.0 отключается 
 интерпретация символов конца строки и кодирование символов Юникода).

• Добавление символа + означает, что файл открывается для чтения и для записи (то есть вы получаете 
 возможность читать и записывать данные в одини тот же объект файла, часто совместно с операцией 
 позиционирования в файле).

Оба аргумента функции open должны быть строками. Кроме того, функция может принимать третий необязательный
аргумент, управляющий буферизацией выводимых данных, 

– значение ноль означает, что выходная информацияне будет буферизироваться 
(то есть она будет записываться во внешний файлсразу же, в момент вызова метода записи).

Имя внешнего файла может включать платформозависимые префиксы абсолютного или относительного пути к файлу.
Если путь к файлу не указан, предполагается, что он находится в текущем рабочем каталоге. Очень интересно.

Лутц начинает вещать годноту, которую я не знаю.

(!) "Выталкивает выходные буферы на диск" и что с чем едят.

По лутцу: выполняется открытие нового текстового файла в режиме для записи, в него записываются две строки
(завершающиеся символом новой строки \n), после чего файл закрывается.

Но, файл закрываеться командой 

>>> myfile.close()
>>> 

которая выталкивает выходные буферы на диск, что это значит:

Во время этой операции я открыл директорию рабочего каталога и наблюдал за происходящим (ссылка на каталог)

 C:\\Users\\Battlestation\\Documents\\Visual Studio 2015\\Projects\\PythonApplication1\\PythonApplication1\

 При исполнеии этого алгоритма и до команды "вытолкнуть выходные буфер на диск" текстовый файл весил 0 байт.

>>> myfile = open("myfile.txt", "w")             # открывает файл (создаёт, очищает)
>>> myfile.write("Ghost in the shell file\n")    # записывает строку текста
24
>>> myfile.write("Stand Alone complex end\n")    # записывает ещё одну строку
24

после исполнения команды 

>>> myfile.close()
>>> 

текстовый файл myfile.txt стал весить 50 байт.

Отсюда вывод - метод .close() принудительно пишет данные в во внешнии файлы, Лутц тоже вешает об этом в книге.

Вызов метода close разрывает связь с внешним файлом. Интерпретатор Python немедленно освобождает память, за-
нятую объектом, как только в программе будет утеряна последняя ссылкана этот объект. Как только объект файла
освобождается, интерпретаторавтоматически закрывает ассоциированный с ним файл (что происходит также в момент
завершения программы). Благодаря этому вам не требуется закрывать файл вручную, особенно в небольших сценариях,
которые выполняются непродолжительное время. С другой стороны, вызов методаclose не повредит, и его рекомендуется
использовать в крупных системах.

Строго говоря, возможность автоматического закрытия файлов не является частью спецификации языка, и с течением 
времени такое поведение может измениться. Следовательно, привычку вызывать метод close вручную можно только
приветствовать.

На счёт течения времени не понял - он говорит так, как будто возможно отменить основную идею языка по в рамках
системной таблице. Не уврене что такое возможно с течениемвремени. Мы обращаемся к файлу, появляется ссылка на 
объект "файл" - как только мы зкончили к нему образаться - ссылка разименовываеться и файл закрываеться.

Но общее дао я понял - лучше писать данные сразу через .close() чем проверять на прочность алгоритм.

Поэтому запишем, что

# Файлы обеспечивают буферизацию ввода-вывода и позволяют производить позиционирование в файле.

В момент закрытия файла освобождаются ресурсы операционной системыи выталкиваются выходные буферы. По умолчанию
вывод в файлы всегда выполняется с помощью промежуточных буферов, то есть в момент записи текста в файл он не
попадает сразу же на диск – буферы выталкиваются на диск только в момент закрытия файла или при вызове метода
flush. Вы можете отключить механизм буферизации с помощью дополнительных параметров функции open, но это может
привести к снижению производительности операций ввода-вывода. Файлы в языке Python поддерживают также
возможность позиционирования – метод seek позволяет сценариям управлять позицией чтения и записи.

Также стоит запомнить, кое что важное.

(!)

В любом случае содержимое файлав программах на языке Python принимает форму строк – операция чтения возвращает
текст в строках, и метод записи принимает информацию в виде строк.

Для чтения строк лучше использовать итераторы файлов

Несмотря на то что методы чтения и записи, перечисленные в таблице, являются наиболее часто используемыми,
имейте в виду, что самый лучший, пожалуй, способ чтения строк из файла на сегодняшний день состоит в том,
что бы вообще не использовать операцию чтения из файла – как будет показано в главе 14, файлы имеют
итератор, который автоматически читает информацию из файла строку за строкой в контексте цикла for,
в генераторах списков и в других итерационных контекстах.

(Лутц имеет ввиду что проще всего использовать интератор чтения поскольку файл сам по себе читает себя слева
направо по одномй симовлу и следовательно использование этого интератора самой простой и легкий способ чтения).

# Содержимое файлов находится в строках, а не в объектах

Обратите внимание: в табл. 9.2 показано, что данные, получаемые из файла, всегда попадают в сценарий в виде
строки, поэтому вам необходимо будет выполнять преобразование данных в другие типы объектов языка Python,
если эта форма представления вам не подходит. Точно так же, при выполнении операции записи данных в файл,
в отличие от инструкции print, интерпретатор Python не выполняет автоматическое преобразование объектов 
в строки – вам необходимо передавать методам уже сформированные строки. Поэтому при работе с файлами вам 
пригодятся рассматривавшиеся ранее инструменты преобразования данных из строкового представления в 
числовое и наоборот (например, int, float, str, а также выражения форматирования строк и метод format).

Кроме того, в состав Python входят дополнительные стандартные библиотечные инструменты, предназначенные для
работы с универсальным объектом хранилища данных (например, модуль pickle) и обработки упакованных двоичных
данных в файлах (например, модуль struct). 

# чтение целиком

Если необходимо вывести содержимое файла, обеспечив правильную интерпретацию символов конца строки, его
следует прочитать в строку целиком, с помощью метода read, и вывести:

>>> open("myfile.txt").read()
'Ghost in the shell file\nStand Alone complex end\n'
>>> 

>>> print(open("myfile.txt").read())             # дружбомагия чтения файла в одну строку
Ghost in the shell file
Stand Alone complex end

>>> 

# чтение интератором (!)

>>> for line in open("myfile.txt"):
...     print(line, end = "")
Ghost in the shell file
Stand Alone complex end
>>> 

В этом случае функцией open создается временный объект файла, содержимое которого автоматически будет читаться
итератором и возвращаться по одной строке в каждой итерации цикла.

# учимся работать с файлами .py которые я уже успел накодить.

смотри файл построчно с использованием интератора

>>> for line in open("ghost1.py"):              # использование интератора для чтения файла
...     print(line, end = "")                   # возвращает весь файл построчно, с сохранением структуры
Ghost = 'Ghost'
Shell = 'Shell'
Enemy = 'Enemy'
Kill_day = 'Kill_day'
Anime_day = 'Anime_day'
x = 'god1'
y = 'god2'
z = 'god3'
q = 'devil'
Ghost = x 
Shell = y 
Enemy = z
q = x + y + z 
Kill_day = x + y + z
Anime_day = Kill_day and Kill_day != Ghost
if Anime_day == Kill_day:                                 # кракозябры вместо русского языка в тексте коммента
    Ghost = 404
    kill_day = 5
    day = 22
    Ghost = Ghost - kill_day * day
    x = 204
    if Ghost < x :
        print ('Big Ghost')
    else:
        print ('Small Ghost')
elif Anime_day != Kill_day:  
    Ghost = 404
    kill_day = 6
    day = 22
    Ghost = Ghost - kill_day * day
    x = 204
    if Ghost > x :
        print ('Big Ghost')
    else:
        print ('Small Ghost')
elif Anime_day != Kill_day:
    print(Kill_day)
else:
    print(Python)
>>> 

смотрим файл с использованием дружбомагии принта

>>> print(open("ghost1.py").read())             # также возвращает весь файл построчно, со структурой
Ghost = 'Ghost'
Shell = 'Shell'
Enemy = 'Enemy'
Kill_day = 'Kill_day'
Anime_day = 'Anime_day'
x = 'god1'
y = 'god2'
z = 'god3'
q = 'devil'
Ghost = x 
Shell = y 
Enemy = z
q = x + y + z 
Kill_day = x + y + z
Anime_day = Kill_day and Kill_day != Ghost
if Anime_day == Kill_day:                                 # кракозябры вместо русского языка в тексте коммента
    Ghost = 404
    kill_day = 5
    day = 22
    Ghost = Ghost - kill_day * day
    x = 204
    if Ghost < x :
        print ('Big Ghost')
    else:
        print ('Small Ghost')
elif Anime_day != Kill_day:  
    Ghost = 404
    kill_day = 6
    day = 22
    Ghost = Ghost - kill_day * day
    x = 204
    if Ghost > x :
        print ('Big Ghost')
    else:
        print ('Small Ghost')
elif Anime_day != Kill_day:
    print(Kill_day)
else:
    print(Python)

смотрим файл по одной строке

>>> myfile = open("ghost1.py")
>>> myfile.readline()
"Ghost = 'Ghost'\n"

смотрим файл построчно с использованием: open("filename.tx",encoding="latin-1")

>>> for line in open("ghost1.py", encoding="latin-1"):
...     print(line, end = "")                   # возвращает кракозябры в комментах
Ghost = 'Ghost'
Shell = 'Shell'
Enemy = 'Enemy'
Kill_day = 'Kill_day'
Anime_day = 'Anime_day'
x = 'god1'
y = 'god2'
z = 'god3'
q = 'devil'
Ghost = x 
Shell = y 
Enemy = z
q = x + y + z 
Kill_day = x + y + z
Anime_day = Kill_day and Kill_day != Ghost
if Anime_day == Kill_day:                                 # кракозябры вместо русского языка в тексте коммента
    Ghost = 404
    kill_day = 5
    day = 22
    Ghost = Ghost - kill_day * day
    x = 204
    if Ghost < x :
        print ('Big Ghost')
    else:
        print ('Small Ghost')
elif Anime_day != Kill_day:  
    Ghost = 404
    kill_day = 6
    day = 22
    Ghost = Ghost - kill_day * day
    x = 204
    if Ghost > x :
        print ('Big Ghost')
    else:
        print ('Small Ghost')
elif Anime_day != Kill_day:
    print(Kill_day)
else:
    print(Python)
>>> 

# запись в файл (с использование параметра "a" - что означает "записать в конец файла")

>>> anime = open("ghost1.py", "a")
>>> anime.write("Major")
5
>>> anime.close()
>>> 

(!) сработало - IDLE сразу предложил мне перезапустить файл ghost1 поскольку в него были внесены изменения.

теперь файл выглядит так...

elif Anime_day != Kill_day:
    print(Kill_day)
else:
    print(Python)
Major

(!) и он может выглядить так:

Major

если не дай бог воспользоваться режимом записи "w

>>> anime = open("ghost1.py", "w")			# режим записи "w" - опасная штука, не пользуйся им 
>>> anime.write("Major")					# тупо перезаписывает все строки файла на Майора в 1ой позиции
5
>>> anime.close()
>>> 

# на попытку использовать плю по Лутцу для указания режима чтения-записи, возвращает исключение.

ValueError: must have exactly one of create/read/write/append mode

# Двочиные данные при чтении внешних файлов.

• Содержимое текстовых файлов представляется в виде обычных строк типа str, выполняется автоматическое
 кодирование/декодирование символов Юникода и по умолчанию производится интерпретация символов конца строки.

• Содержимое двоичных файлов представляется в виде строк типа bytes, и оно передается программе без каких-либо
 изменений.

Для работы с двоичными файлами следует использовать строки bytes
- а обычные строки str – для работы с текстовыми файлами.

Когда выполняется операция чтения двоичных данных из файла, она возвращает объект типа bytes – последовательность
коротких целых чисел, представляющих абсолютные значения байтов (которые могут соответствовать символам, а 
могут и не соответствовать), который во многих отношениях очень близко напоминает обычную строку:

у меня всё красиво.

>>> data = open("data.bin", "rb").read()
>>> data
b'Hello\r\nGhost in the shell'
>>> 

у Лутца двоичная хуерга

>>> data = open(‘data.bin’, ‘rb’).read()	 # Открыть двоичный файл для чтения
>>> data									 # Строка bytes хранит двоичные данные
b’\x00\x00\x00\x07spam\x00\x08’
>>> data[4:8]								 # Ведет себя как строкаb’spam’
>>> data[4:8][0]						     # Но в действительности хранит 8-битные целые числа
115
>>> bin(data[4:8][0])						 # Функция bin() в Python 3.0
‘0b1110011’

Кроме того, двоичные файлы не выполняют преобразование символов конца строки – текстовые файлы по умолчанию 
отображают все разновидности символов конца строки в и из символ \n в процессе записи и чтения, и производят
преобразование символов Юникода в соответствии с указанной кодировкой. Так как операции с символами Юникода
и с двоичными данными представляют особый интерес для многих программистов, мы отложим полное их обсуждение
до главы 36.

(и слава богу что отложим - не вдохновляет меня всё эта двоичность, хотя надо и её понять тоже - для железа)

# Сохранение и интерпретация объектов Python в файлах

(!) Помни - Данные всегда записываются в файл в виде строк

>>> x,y,z = 11,501,404
>>> S = "anime"
>>> D = {"a":1,"b":2}
>>> L = [1,2,3]
>>> L
[1, 2, 3]
>>> F = open("datafile.txt","w")
>>> F.write(S + "\n")
6
>>> F.write("%s,%s,%s\n" % (x,y,z))
11
>>> F.write(str(L) + "$" + str(D) + "\n")
27
>>> F.close()
>>> 

>>> print(open("datafile.txt").read())
anime
11,501,404
[1, 2, 3]${'b': 2, 'a': 1}

>>> 

Создав файл, мы можем исследовать его содержимое, открыв файл и прочитав данные в строку (одной операцией).
Обратите внимание, что функция автоматического вывода в интерактивной оболочке дает точное побайтовое
представление содержимого, а инструкция print интерпретирует встроенные символы конца строки, чтобы 
обеспечить более удобочитаемое отображение:

>>> data = open("datafile.txt").read()
>>> data
"anime\n11,501,404\n[1, 2, 3]${'b': 2, 'a': 1}\n"
>>> 

Теперь нам необходимо выполнить обратные преобразования, чтобы получить из строк в текстовом файле действительные
объекты языка Python. Интерпретатор Python никогда автоматически не выполняет преобразование строк в числа или
в объекты других типов, поэтому нам необходимо выполнить соответствующие преобразования, чтобы можно было
использовать операции над этими объектами, такие как индексирование, сложение и так далее:

>>> Heresy = open("datafile.txt")
>>> line1 = Heresy.readline()                  # присвоить ссылку результату команды "прочитать одну строку"
>>> line1                                      # возвращает -  'anime\n'
'anime\n'
>>> line1.rstrip()                             # удалить символ конца строки - возвращает  'anime'
'anime'
>>> line2 = Heresy.readline()
>>> line2                                      # возвращает  - '11,501,404\n'
'11,501,404\n'
>>> parts = line2.split(",")                   # даём команды - разбить на подстроки с запятыми
>>> parts                                      # ['11', '501', '404\n']
['11', '501', '404\n']
>>> 

Был использован метод split, чтобы разбить строку на части по запятым, которые играют роль символов-разделителей,
 – в результате мы получили список строк, каждая из которых содержит отдельное число. Теперь нам необходимо
 преобразовать эти строки в целые числа, чтобы можно было выполнять математические операции над ними:

>>> int(parts[1])                              # преобразовать строку в целое число по индексу элемента  - 501
501
>>> numbers = [int(i) for i in parts]
>>> numbers
[11, 501, 404]
>>> 

Обратите внимание: для удаления завершающего символа \n в конце последней подстроки не был использован метод
rstrip, потому что int и некоторые другие функции преобразования просто игнорируют символы-разделители, 
окружающие цифры.

Чтобы преобразовать список и словарь в третьей строке файла, можно воспользоваться встроенной функцией eval,
которая интерпретирует строку как программный код на языке Python (формально – строку, содержащую выражение
на языке Python):

>>> line3 = Heresy.readline()
>>> line3                                      # возвращает "[1, 2, 3]${'b': 2, 'a': 1}\n"
"[1, 2, 3]${'b': 2, 'a': 1}\n"
>>> parts = line3.split("$")                   # разбить на подстроки по символу "$"
>>> parts                                      # возвращает ['[1, 2, 3]', "{'b': 2, 'a': 1}\n"]
['[1, 2, 3]', "{'b': 2, 'a': 1}\n"]
>>> eval(parts[0])                             # eval - интерпретирует строку как код, возвращает - [1, 2, 3]
[1, 2, 3]
>>> objects = [eval(i) for i in parts]
>>> objects                                    # [[1, 2, 3], {'a': 1, 'b': 2}]
[[1, 2, 3], {'b': 2, 'a': 1}]
>>> part1 = objects[0]
>>> part1
[1, 2, 3]
>>> part2 = objects[1]
>>> part2
{'b': 2, 'a': 1}

# Сохранение объектов Python с помощью модуля pickle

Функция eval, использованная в предыдущем примере для преобразования строк в объекты, представляет собой 
инструмент. И иногда даже слишком мощный. Функция eval без лишних вопросов выполнит любое выражение на 
языке Python, даже если в результате будут удалены все файлы в компьютере, если передать в выражение
соответствующие права доступа! 

Если вам действительно необходимо извлекать объекты Python из файлов, но вы не можете доверять источнику
этих файлов, идеальным решением будет использование модуля pickle, входящего в состав стандартной 
библиотеки Python.

Модуль pickle позволяет сохранять в файлах практически любые объекты Python без необходимости с нашей стороны
выполнять какие-либо преобразования. Он напоминает суперуниверсальную утилиту форматирования и преобразования
данных. Чтобы сохранить словарь в файле, например, мы передаем его непосредственно в функцию модуля pickle:

>>> Anime = {"Major":11, "Ghost":501, "Complex": "Alone"}
>>> Anime                                                   # {'Ghost': 501, 'Major': 11, 'Complex': 'Alone'}
{'Ghost': 501, 'Major': 11, 'Complex': 'Alone'}
>>> File = open("superfile.pkl", "wb")                      # создаём новый файл с непонятным расширением
>>> import pickle                                           # загружаем супер модуль
>>> pickle.dump(Anime,File)                                 # даём команду - свалить объекты Anime в файл File
>>> File.close()
>>> print(open("superfile.pkl").read())

!!! возвращает дикую билиберду в которой просматриваеться наш словарь.

Чтобы потом прочитать словарь обратно, можно просто еще раз воспользоваться возможностями модуля pickle:

>>> Heresy = open("superfile.pkl", "rb")
>>> import pickle
>>> Read = pickle.load(Heresy)
>>> Read
{'Complex': 'Alone', 'Major': 11, 'Ghost': 501}
>>> 

(!) Сериализация объектов. 

Модуль pickle выполняет то, что называется сериализацией объектов, – преобразование объектов в строку байтов и
обратно, не требуя от нас почти никаких действий. В действительности, внутренняя реализация модуля pickle 
выполнила преобразование нашего словаря в строку, при этом незаметно для нас (и может выполнить еще более
замысловатые преобразования при использовании модуля в других режимах):

>>> open("superfile.pkl", "rb").read()
b'\x80\x03}q\x00(X\x05\x00\x00\x00Ghostq\x01M\xf5\x01X\x05\x00\x00\x00Majorq\x02K\x0bX\x07\x00\x00\x00Complexq\x03X\x05\x00\x00\x00Aloneq\x04u.'
>>> 

Обратите также внимание на модуль shelve – инструмент, который использует модуль pickle для сохранения объектов
Python в файлах с доступом по ключу, описание которых далеко выходит за рамки этой книги (впрочем, пример 
использования модуля shelve вы найдете в главе 27; кроме того, дополнительные примеры использования
модуля pickle приводятся в главах 30 и 36).

# Сохранение и интерпретация упакованных двоичных данных в файлах

В некоторых приложениях приходится иметь дело с упакованными двоичными данными, которые создаются, например,
программами на языке C. Стандартная библиотека языка Python включает инструмент, способный помочь в этом, –
модуль struct, который позволяет сохранять и восстанавливать упакованные двоичные данные. В некотором смысле,
это совершенно другой инструмент преобразования данных, интерпретирующий строки в файлах как двоичные данные.

Чтобы создать файл с упакованными двоичными данными, откройте его в режиме ‘wb’ (write binary – запись 
двоичных данных) и передайте модулю struct строку формата и некоторый объект Python.

!!!!!

Лутц я знал что ты не силён в двоичной хуерге!!!

Правильные ответы смотри здесь: http://www.cyberforum.ru/python/thread1025134.html


>>> binary = open("bindata.bin", "wb")                      # открываем файл в режиме записи в байтах
>>> import struct                                           # загружаем полезный модуль типа pickle для bin
>>> data = struct.pack(b">i4sh", 7, b"Spam", 8)             # запаковать данные в () методом модуля struck
>>> data                                                    # b'\x00\x00\x00\x07Spam\x00\x08'
b'\x00\x00\x00\x07Spam\x00\x08'
>>> binary.write(data)                                      # записать данные в формате bin в файл
10
>>> binary.close()
>>> 

Что нужно занть, 1 - спецификаторы модуля struck http://ilnurgi1.ru/docs/python/modules/struct.html

> - прямой порядок
< - обратный порядок
x - пропустить один байт
b - знаковый один байт
B - беззнаковый байт
h - знаковое короткое целое число, 2 байта
H - беззнаковое короткое целое число, 2 байта
i - знаковое целое число, 4 байта
I - беззнаковое целое число, 4 байта
l - знаковое длинное целое число, 4 байта
L - беззнаковое длинное целое число, 4 байта
Q - беззнаковое очень длинное целое число, 8 байт
f - число с плавающей точкой, 4 байта
d - число с плавающей точкой двойной точности, 8 байт
p - счетчик и символы, 1 + count байт
s - символы, count символов

поэтому кмоанда, которую Лутц отдал интерпретатору звучит так: запокавать данные в структуру с использованием
спецификаторов:

> - прямой порядок
 -в порядке следования байтов «от старшего к младшему»
i - знаковое целое число, 4 байта
s - символы, count символов
h - знаковое короткое целое число, 2 байта

например это может выглядть так:

>>> binary = open("bindata.bin", "wb")                      # открываем файл в режиме записи в байтах
>>> import struct                                           # загружаем полезный модуль типа pickle для bin
>>> data = struct.pack(b">hsh", 7, b"Spam", 8)             # запаковать данные в () методом модуля struck
>>> data                                                    # b'\x00\x00\x00\x07Spam\x00\x08'
b'\x00\x07S\x00\x08'
>>> binary.write(data)                                      # записать данные в формате bin в файл
5
>>> binary.close()
>>> 

4s - это 4х символьная строка, следовательно пример может выглдяить так:

>>> binary = open("bindata.bin", "wb")                      # открываем файл в режиме записи в байтах
>>> import struct                                           # загружаем полезный модуль типа pickle для bin
>>> data = struct.pack(b">h4sh", 7, b"Ghost", 8)             # запаковать данные в () методом модуля struck
>>> data                                                    # b'\x00\x00\x00\x07Spam\x00\x08'
b'\x00\x07Ghos\x00\x08'
>>> binary.write(data)                                      # записать данные в формате bin в файл
8
>>> binary.close()
>>> 

или так:

>>> binary = open("bindata.bin", "wb")                      # открываем файл в режиме записи в байтах
>>> import struct                                           # загружаем полезный модуль типа pickle для bin
>>> data = struct.pack(b">h5sh", 7, b"Ghost", 8)             # запаковать данные в () методом модуля struck
>>> data                                                    # b'\x00\x00\x00\x07Spam\x00\x08'
b'\x00\x07Ghost\x00\x08'
>>> binary.write(data)                                      # записать данные в формате bin в файл
9
>>> binary.close()
>>> 

Что даёт нам незамасикрованное знание о том - как именно эта хреновина работает, xs - это указание строки,
где х = числу символов в строке, поэтому:

>>> binary = open("bindata.bin", "wb")                        # открываем файл в режиме записи в байтах
>>> import struct                                             # загружаем полезный модуль типа pickle для bin
>>> data = struct.pack(b">i18sh", 7, b"Ghost in the shell", 8)# запаковать строку из18 символов через спецификатор 18s
>>> data                                                      # b'\x00\x00\x00\x07Spam\x00\x08'
b'\x00\x00\x00\x07Ghost in the shell\x00\x08'
>>> binary.write(data)                                        # записать данные в формате bin в файл
24
>>> binary.close()
>>> 

Комментарий к этому процессу звучит так: В следующем примере используется строка формата, которая определяет
пакет данных, содержащий 4-байтовое целое число, 18-символьную строку и 2-байтовое целое число, причем все
представлены в формате big-endian – в порядке следования байтов «от старшего к младшему».

Интерпретатор Python создаст строку bytes двоичных данных, которую затем мы запишем в файл обычным способом 
строка состоит из экранированных последовательностей, представляющих шестнадцатеричные значения). Чтобы
преобразовать эти значения в обычные объекты языка Python, достаточно просто прочитать строку обратно и
распаковать ее с использованием той же строки формата. Следующий фрагмент извлекает значения, 
преобразуя их в обычные объекты (целые числа и строка):

>>> binary = open("bindata.bin", "rb")
>>> data = binary.read()
>>> data                                                    # b'\x00\x00\x00\x07Ghost in the shell\x00\x08'
b'\x00\x00\x00\x07Ghost in the shell\x00\x08'
>>> import struct
>>> values = struct.unpack(">i18sh", data)
>>> values
(7, b'Ghost in the shell', 8)
>>> values[1]
b'Ghost in the shell'
>>> print(values[1])
b'Ghost in the shell'
>>> 

хм. а что делать с b?

в теории можно так:

>>> binary = open("bindata1.bin", "wb")                       
>>> import struct                                            
>>> data = struct.pack(">i18sh", 7, b"Ghost in the shell", 8)	# b только перед строкой
>>> data                                                      
b'\x00\x00\x00\x07Ghost in the shell\x00\x08'
>>> binary.write(data)                                        
24
>>> binary.close()
>>> binary = open("bindata1.bin", "wb")                         
>>> import struct                                             
>>> data = struct.pack(">i18sh", 7, B"Ghost in the shell", 8)
>>> data                                                      
b'\x00\x00\x00\x07Ghost in the shell\x00\x08'
>>> binary.write(data)                                        
24
>>> binary.close()
>>> binary = open("bindata1.bin", "rb")
>>> data = binary.read()
>>> data                                                    
b'\x00\x00\x00\x07Ghost in the shell\x00\x08'
>>> import struct
>>> values = struct.unpack(">i18sh", data)
>>> values                                                 
(7, b'Ghost in the shell', 8)
>>> values[1]
b'Ghost in the shell'
>>> print(values[1])
b'Ghost in the shell'
>>> type(values[1])
<class 'bytes'>
>>> 

но алгоритм всё равно возвращает нам байтовую строку b'Ghost in the shell' - этот торт совсем не торт

В теории можно сделать так- но результат тот же.

>>> binary = open("bindata2.bin", "wb")
>>> import struct
>>> values = (1, b"Ghost in the shell", 8)
>>> s = struct.Struct('>i 18s h')
>>> packed_data = s.pack(*values)
>>> packed_data
b'\x00\x00\x00\x01Ghost in the shell\x00\x08'
>>> binary.write(packed_data)
24
>>> binary.close()
>>> binary = open("bindata2.bin", "rb")
>>> data = binary.read()
>>> data
b'\x00\x00\x00\x01Ghost in the shell\x00\x08'
>>> import struct
>>> values = struct.unpack(">i18sh", data)
>>> values
(1, b'Ghost in the shell', 8)
>>> type(values[1])
<class 'bytes'>
>>> print(values[1])
b'Ghost in the shell'
>>> 

поэтому необходимо использовать декодирование

>>> values[1].decode("utf-8")
'Ghost in the shell'
>>> 

кроме того полезно помнить общуюю идею модуля

>>> import struct
>>> a = struct.pack("I", 1)
>>> a
b'\x01\x00\x00\x00'
>>> b = struct.unpack("I", a)
>>> b
(1,)

# Менеджеры контекста файлов + try/finally

Необходимо будет прочитать обсуждение поддержки менеджеров контекста файлов в главе 33, впервые появившейся в 
версиях Python 3.0 и 2.6. Даже при том, что менеджеры контекста в основном применяются для обработки
исключений, тем не менее они позволяют обертывать программный код, выполняющий операции с файлами, 
дополнительным слоем логики, который гарантирует, что после выхода за пределы блока инструкций
менеджера файл будет закрыт автоматически, и позволяет не полагаться на автоматическое 
закрытие файлов механизмом сборки мусора:

Аналогичную функциональность предоставляет конструкция try/finally, с которой мы познакомимся в главе 33, но 
за счет избыточного программного кода – три дополнительных строки, если быть более точным (впрочем, мы можем
не использовать ни один из вариантов и позволить интерпретатору самому закрывать файлы):

>>> binary = open("bindata2.bin", "rb")
>>> try:
...     for line in binary:
...         print(line)
... finally:
...     binary.close()
b'\x00\x00\x00\x01Ghost in the shell\x00\x08'
>>> 

>>> Heresy = open("datafile.txt")
>>> try:
...     for line in Heresy:
...         print(line)
... finally:
...     Heresy.close() 
anime

11,501,404

[1, 2, 3]${'b': 2, 'a': 1}

>>>

>>> Heresy = open("datafile.txt")
>>> try:
...     Heresy.readline() 
... finally:
...     Heresy.close()
'anime\n'
>>> 

# Заключение.

Классификация объектов

Тип	объектов	   Категория				Изменяемый?

Числа (все)			Числа					Нет

Строки			Последовательности			Нет

Списки			Последовательности			Да

Словари				Отображения				Да

Кортежи			Последовательности			Нет

Файлы				 Расширения			Понятие неприменимо

Множества			 Множества				Да

Фикс.множества  (frozenset)Множества        Нет

bytearray (3.0)  Последовательности         Да

(!) Строковый тип bytearray это байтовая строка

(!) Файлы экспортируют только методы, поэтому понятие изменяемости к ним по-настоящему неприменимо – хотя они
 могут изменяться при выполнении операции записи, но это не имеет никакого отношения к ограничениям типов в 
 языке Python.

# ГОДНОТА!!!!

# перегрузка операторов

Объекты, реализованные с помощью классов, могут свободно попадать в любую из этих категорий (категорий объектов)
. Например, если нам потребуется реализовать новый тип объектов последовательностей, который был бы совместим
со встроенными типами последовательностей, мы могли бы описать класс, который перегружает операторы 
индексирования и конкатенации:

>>> class MyHeresy:
...     def __init__(self, date):
...         self.date = date
...     def __getitem__(self, index):
...         self.index = self[index]
...     def __add__(self, other):
...         self.other = self + other 
... 
>>> FirstGame = MyHeresy("01.01.2017")
>>> SecondGame = MyHeresy(FirstGame)
>>> FirstGame.date
'01.01.2017'

И так далее, лично я пока могу только получить исключение вида: 
RecursionError: maximum recursion depth exceeded while calling a Python object
потому чт оя дно и не смог в такой класс, как у Лутца в примечании, надо будет погуглить.

Точно так же можно было бы создать новый изменяемый или неизменяемый объект, выборочно реализовав методы, 
вызываемые для выполнения операций непосредственного изменения (например, для выполнении операций присваивания
self[index] = value вызывается метод __setitem__). 

Существует также возможность выполнять реализацию новых объектов на других языках программирования, таких как
C, в виде расширений. Чтобы определить выбор между множествами операций над числами, последовательностями и 
отображениями, необходимо будет подставить указатели на функции C в ячейки структуры.

# Хинт при работе с сыылками.

Ссылки – это более высокоуровневый аналог указателей в других языках программирования. И хотя вы не можете
извлечь непосредственное значение самой ссылки, тем не менее одну и ту же ссылку можно сохранить более чем 
в одном месте (в переменных, в списках и так далее). Это полезная особенность – вы можете передавать 
крупные объекты между компонентами программы без выполнения дорогостоящей операции копирования. 
Однако, когда действительно необходимо создать копию объекта, вы можете запросить их:

• Выражение извлечения среза с пустыми пределами (L[:]) создает копию последовательности.

• Метод словарей и множеств copy создает копию словаря (D.copy()).

• Некоторые встроенные функции, такие как list, создают копию списка (list(L)).

• Модуль copy, входящий в состав стандартной библиотеки, создает полные копии объектов.


>>> x = [1,2,3]
>>> y = ["a", x, "b"]                        # ['a', [1, 2, 3], 'b']
>>> z = {"x":x, "y":2}                       # {'y': 2, 'x': [1, 2, 3]}
>>> x[1] = "im stupid and my class isnt work at all"
>>> y                                        
['a', [1, 'im stupid and my class isnt work at all', 3], 'b']
>>> z
{'y': 2, 'x': [1, 'im stupid and my class isnt work at all', 3]}
>>> 

как мы видим:
- Так как списки относятся к категории изменяемых объектов, изменения в объекте списка, произведенные с помощью 
любой из трех ссылок, также отразятся на других двух ссылках:

Например, предположим, что у нас имеются список и словарь, и для нас нежелательно изменение их значений 
посредством других переменных:

>>> L = [1,2,3]
>>> D = {‘a’:1, ‘b’:2}

Чтобы предотвратить такую возможность, достаточно связать с другими переменными копии объектов вместо того, 
чтобы связать с ними сами объекты:

>>> A = L[:]				 # Вместо A = L (или list(L))
>>> B = D.copy()			 # Вместо B = D (то же относится и к множествам)

В этом случае изменения, произведенные с помощью других переменных, повлияют на копии, а не на оригиналы:

>>> anime = [1,2,3]
>>> heresy = {"Horus":1, "Impi":0}
>>> a = anime[:]
>>> b = heresy.copy()
>>> a[1] = "complex"
>>> b["chaos"] = "quest"
>>> anime, heresy
([1, 2, 3], {'Horus': 1, 'Impi': 0})
>>> a, b
([1, 'complex', 3], {'Horus': 1, 'chaos': 'quest', 'Impi': 0})
>>> 

Если вернуться к первоначальному примеру, то избежать побочных эффектов, связанных со ссылками, можно,
использовав выражение извлечения среза из оригинального списка:

>>> x = [1,2,3]
>>> y = ["a", x[:], "b"]                     # операция извлечения среза создаёт копию ссылки на объект
>>> z = {"x":x[:], "y":2}                    # благодаря чему ссылки y и z ссылаються на копии отличные от х
>>> x[1] = "im stupid and my class isnt work at all"
>>> y                                        
['a', [1, 2, 3], 'b']
>>> z
{'y': 2, 'x': [1, 2, 3]}
>>> 

Теперь изменения, выполненные с помощью переменной X, отразятся только на самой переменной X, но не на L и D;
точно так же изменения в L или D никак не будут воздействовать на X.

# замечание по поводу копий: выражение извлечения среза с пустыми значениями пределов и метод словаря copy 
создают поверхностные копии – то есть они не копируют вложенные структуры данных, даже если таковые при-
сутствуют. 

Если необходима полная копия структуры произвольной глубины вложенности, следует использовать стандартный 
модуль copy: добавьте инструкцию import copy и вставьте выражение X = copy.deepcopy(Y), которое создаст
полную копию объекта Y со сколь угодно большой глубиной вложенности. 

Эта функция выполняет рекурсивный обход объектов и копирует все составные части. Однако такой подход 
используется намного реже (потому что для этого приходится писать дополнительный программный код). 
Обычно ссылки – это именно то, что нам требуется, в противном случае чаще всего применяются такие
способы копирования, как операция извлечения среза и метод copy.

>>> import copy
>>> y = [1,2,3]
>>> x = copy.deepcopy(y)
>>> y
[1, 2, 3]
>>> x
[1, 2, 3]
>>> id(y)
20838152
>>> id(x)
52587208
>>> 

# Сравнение, равенство и числа (где то всё это уже было, но солушаем Лутца о рексурсии)

При сравнивании вложенных объектов интерпретатор Python всегда автоматически выполняет обход структуры данных,
чтобы применить операции сравнения рекурсивно, слева направо и настолько глубоко, насколько это необходимо.
Первое найденное различие определяет результат сравнения.

>>> Heresy1 = [1,2,3,4]
>>> Heresy2 = [1,2,3,4]
>>> Heresy1 == Heresy2, Heresy1 is Heresy2
(True, False)
>>>

• Оператор == проверяет равенство значений. Интерпретатор выполняет проверку на равенство, рекурсивно
  сравнивая все вложенные объекты.

• Оператор is проверяет идентичность объектов. Интерпретатор проверяет, являются ли сравниваемые объекты
  одним и тем же объектом (то есть расположены ли они по одному и тому же адресу в памяти). 

>>> Heresy1 = "HorusHeresy"
>>> Heresy2 = "HorusHeresy"
>>> Heresy1 == Heresy2, Heresy1 is Heresy2
(True, True)
>>> 

Здесь у нас так же имеется два различных объекта с одинаковыми значениями: оператор == должен вернуть истину,
а оператор is – ложь. Но так как интерпретатор с целью оптимизации кэширует и повторно использует короткие 
строки, в действительности в обе переменные, Heresy1 и Heresy2, записывается ссылка на одну ту же строку 
‘HorusHeresy’ в памяти, поэтому оператор is проверки идентичности возвращает истину. 

Чтобы получить нормальное поведение, потребуется использовать более длинные строки:

>>> Heresy1 = "Horus is Heresy"
>>> Heresy2 = "Horus is Heresy"
>>> Heresy1 == Heresy2, Heresy1 is Heresy2
(True, False)
>>> 

Операторы отношений к вложенным структурам также применяются рекурсивно:

>>> Heresy1 = [1,2,3,(4,1)]
>>> Heresy2 = [1,2,3,(4,2)]
>>> Heresy1 < Heresy2, Heresy1 == Heresy2, Heresy1 > Heresy2
(True, False, False)
>>> 

Результат последней строки в этом примере в действительности представляет собой кортеж из трех объектов – 
результатов трех выражений (пример кортежа без объемлющих круглых скобок).

# Сравнение словарей ( технически невозможно в 3.0 и выше, но можно попробовать вручную)

Чтобы выяснить относительный порядок словарей в версии 3.0, можно написать цикл и вручную сравнить значения 
ключей или вручную создать отсортированные списки пар ключ/значение и сравнить их – для этого вполне 
достаточно будет задействовать метод словарей items и встроенную функцию sorted:

>>> Heresy = {"Horus":1,"Impi":0}           # 5 интеракций дадут одинаковый результат в порядке объекто сортед
>>> Anime = {"Ghost":11, "Shell":501}
>>> Anime == Heresy                         # False
False
>>> list(Heresy.items())                    
[('Impi', 0), ('Horus', 1)]
>>> sorted(Heresy.items())                  
[('Horus', 1), ('Impi', 0)]
>>> list(Anime.items())                    
[('Shell', 501), ('Ghost', 11)]
>>> sorted(Anime.items())                   
[('Ghost', 11), ('Shell', 501)]
>>> sorted(Heresy.items()) > sorted(Anime.items())
True
>>> sorted(Heresy.items()) < sorted(Anime.items())
False
>>> 

# True - False по Лутцу

Интерпретатор Python распознает любую пустую структуру данных как «ложь», а любую непустую структуру данных –
как «истину». В более широком смысле понятия истины и лжи – это свойства, присущие всем объектам в Python, 
– каждый объект может быть либо «истиной», либо «ложью»:

• Числа, отличные от нуля, являются «истиной».

• Другие объекты являются «истиной», если они непустые.

Объект		Значение

“spam”		True

“”			False

[]			False

{}			False

1			True

0.0			 False

None		 False

(короче всё что не пустое - тру)

Так как объекты могут быть «истинными» или «ложными», в программах на языке Python часто можно увидеть такие
условные инструкции, как if X:, которая, если предположить, что X является строкой, равноценна инструкции 

if X != ‘’:

# None по Лутцу

None - всегда расцениваеться как ложь.

Пример: чтобы можно было выполнять присваивание любому из 100 элементов списка (списки не вырастают из 
пустоты), обычно создается список из 100 элементов, который заполняется объектами None:

>>> L = [None] * 100
>>>
>>> L
[None, None, None, None, None, None, None, ... ]

В этом примере мы никак не ограничиваем размер списка (его по-прежнему позднее можно будет увеличить или 
уменьшить), мы просто создаем список определенного размера, чтобы обеспечить возможность присваивания по
индексам. Точно так же можно было бы инициализировать список нулями, но все-таки предпочтительнее 
использовать None, если заранее не известно, какие данные будет содержать этот список.

# Тип bool

Логический тип bool в языке Python просто усиливает понятия «истина» и «ложь» в языке Python. Этот тип 
реализован так, что он действительно является лишь незначительным расширением к понятиям «истина» и 
«ложь», уже описанным, и предназначенным для того, чтобы сделать значения истинности более явными.

• При явном использовании слов True и False в операциях проверки на истинность они интерпретируются как 
«истина» и «ложь», которые в действительности являются специализированными версиями целых чисел 1 и 0.

• Результаты операций проверок также выводятся как слова True и False, а не как значения 1 и 0.

Здесь Лутц топит за то, что технически True и False это 1 и 0 соотвественно и хоитя в интерпретаторе они 
выводяться как True и False - в действительности Питон просто возвращает 1 если тру и 0 если фалсе.
При использовании Bool True это тру, а False это False

>>> Heresy1 = 1
>>> Heresy2 = 2
>>> bool(Heresy1 < Heresy2), bool(Heresy1 == Heresy2), bool(Heresy1 > Heresy2)
(True, False, False)
>>> 

(!) Вообщем это всё херня - в действительноти тип Bool нужен что бы проверять объекты без операции сравнения.

функция bool, используеться для проверки логического значения объекта (например, для проверки истинности 
объекта, чтобы убедиться, что объект не является пустым или не равен нулю): 

>>> bool(1)                                 
True
>>> bool([])                                
False
>>> bool({})                                
False
>>> bool(())                                
False
>>> bool("Heresy")
True
>>> 

# Иерархии типов данных в языке Python

Главное, что следует учитывать, – в языке Python все элементы являются объектами и могут быть использованы в
ваших программах. Например, можнопередать класс в функцию, присвоить его переменной, заполнить им список или
словарь и так далее.

# Объекты типов

Фактически даже сами типы в языке Python являются разновидностью объектов: объекты типов являются объектами 
типа type (попробуйте быстро произнести эту фразу три раза!). Говоря серьезно, вызов встроенной функции
type(X) возвращает объект типа объекта X. 

Объекты типов могут использоваться для сравнения типов вручную в инструкции if. Однако по причинам, изложенным
в главе 4, ручная проверка типа в языке Python обычно рассматривается как нечто неправильное, что существенно
ограничивает гибкость программного кода.

 - что в целом правильно, пользуйся парень проверокй в цикле с помощью интератора for i in type и так далее.

В Python 2.2 у каждого базового типа появилось новое встроенное имя, добавленное для обеспечения поддержки 
настройки типов через объектно-ориентированный механизм наследования классов: dict, list, str, tuple, int, 
float, complex, bytes, type, set и другие

Эти имена представляют не просто функции преобразования, а настоящие конструкторы объектов, хотя при решении 
несложных задач вы можете рассматривать их как простые функции.

Модуль types, входящий в состав стандартной библиотеки, также предоставляет дополнительные имена типов, не
являющиеся встроенными и предоставляет возможность проверять тип объекта с помощью функции isinstance. 
Например, все следующие операции проверки возвращают истину:

>>> type([1]) == type([])                  
True
>>> type([1]) == list
True
>>> isinstance([1], list)
True
>>> 

# В модуле types определены имена других типов

>>> import types
>>> def F(): pass
>>> type(F) == types.FunctionType
True

>>> import types                          
>>> def F(): pass
>>> type(11) == types.FunctionType
False
>>> 

# Полезный совет от Лутца в заключении

(!) Избегайте создания циклических структур данных.

Если объект-коллекция содержит ссылку на себя, он называется циклическим объектом. Всякий раз, когда 
интерпретатор Python обнаруживает циклическую ссылку, он выводит [...], чтобы не попасть в
бесконечный цикл:

>>> Heresy = ["Horus Heresy"]
>>> Heresy.append(Heresy)
>>> Heresy
['Horus Heresy', [...]]
>>> 

Кроме понимания того, что три точки в квадратных скобках означают циклическую ссылку в объекте, это случай 
заслуживает особого внимания, т.к. он может привести к сбоям – циклические структуры могут вызывать неожи-
данное зацикливание программного кода, если вы не все предусмотрели. Например, некоторые программы хранят
список или словарь уже посещенных элементов, с помощью которого обнаруживают попадание в цикл. Советы по
устранению этих неполадок приводятся в упражнениях к первой части книги,в главе 3; кроме того, решение
проблемы приводится также в конце главы 24, в программе reloadall.py.

# Неизменяемые типы не могут изменяться непосредственно

Наконец, вы не можете изменять неизменяемые объекты непосредственно. Вместо этого создайте новый объект – с
помощью операций извлечения среза, конкатенации и так далее, и присвойте, если это необходимо, первоначальной
переменной:

T = (1, 2, 3)
T[2] = 4 # Ошибка!
T = T[:2] + (4,) # Все в порядке: (1, 2, 4)

Это может показаться лишней работой, но выигрыш в том, что неизменяемые объекты, такие как кортежи и строки,
не порождают приведенных выше проблем, т.к. они не могут изменяться непосредственно и не подвержены, как 
списки, побочным эффектам такого рода.

# годнота на утро. (закрепление - Лутц реально думает чт оя просто читаю его книгу и всю дорогу не кодю)

Обратите внимание, что в некоторых строках точка с запятой используется как разделитель инструкций, что
позволяет уместить в одной строке несколько инструкций, например: в строке X=1;X выполняется 
присваивание значения переменной и последующий его вывод

>>> Heresy = "Horus Heresy"; Heresy
'Horus Heresy'
>>> 

Кроме того, запомните, что запятая между выражениями обычно означает создание кортежа, даже в отсутствие
круглых скобок: выражение X,Y,Z – это кортеж из трех элементов, который интерпретатор выведет, заключив
в круглые скобки.

>>> a = 1; b = 2; c = 3; a,b,c
(1, 2, 3)
>>> 

и на этой ноте мы заканчиваем первые полгода и 320 страниц ЛУтца, после Дрейка по диагонали - есть над чем
подумать. хорошо чт оя потратил первые пару месяцев на другие учебники. жаль то что синтаксиси начиаеться
только сейчас. 

ЗЫ ЛУтц проверочные вопросы не годнота. впрочем твоя книжка для тех кто совсем нуб. Хорошо чувствовать себя
чуть лучше чем нуб.

с 323 следующая.



