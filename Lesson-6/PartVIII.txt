Списки, с этим артефактом связан файл PartVII (и тот факт что я уже умею в списки и словари)

Списки в языке Python – это:

Упорядоченные коллекции объектов произвольных типов:

С функциональной точки зрения, списки – это лишь место, в котором собраны другие объекты, поэтому их можно
также рассматривать как группы. Кроме того, списки обеспечивают позиционное упорядочение элементов слева
направо (то есть они являются последовательностями).

Доступ к элементам по смещению:

Так же как и в случае со строками, вы можете использовать операцию индексирования для извлечения отдельных 
объектов из списка по их смещениям. Поскольку элементы в списках упорядочены по их местоположению, можно
также выполнять такие действия, как извлечение срезов и конкатенация.

Переменная длина, гетерогенность и произвольное число уровней вложенности:

В отличие от строк, списки могут увеличиваться и уменьшаться непосредственно (их длина может изменяться) и 
могут содержать не только односимвольные строки, но и любые другие объекты (списки гетерогенны). Списки
могут содержать другие сложные объекты и поддерживают возможность создания произвольного числа уровней
вложенности, поэтому имеется возможность создавать списки списков из списков и так далее.

Относятся к категории изменяемых объектов:

В терминах категорий типов списки могут изменяться непосредственно (являются изменяемыми объектами) и 
поддерживают все операции над последовательностями, которые поддерживаются и строками, такие как ин-
дексирование, извлечение срезов и конкатенация. Операции над последовательностями одинаковым образом
работают как в случае списков, так и в случае строк, единственное отличие – при применении операций 
над последовательностями (таких как конкатенация и извлечение среза) к спискам возвращается новый 
список, а не новая строка. Кроме того, т. к. списки являются изменяемыми объектами, они 
поддерживают также операции, которые не поддерживаются строками (такие как операции 
удаления и присваивания по индексам, изменяющие список непосредственно).

Массивы ссылок на объекты:

Формально списки в языке Python могут содержать ноль или более ссылок на другие объекты. Списки чем-то напоминают
массивы указателей (адресов). Извлечение элемента из списка в языке Python выполняется так же быстро, как 
извлечение элемента массива в языке C. В действительности списки – это самые настоящие массивы языка C,
реализованные в интерпретаторе Python, а не связанные структуры данных.

Когда используется ссылка на объект, интерпретатор разыменовывает ее, поэтому ваши программы всегда будут
иметь дело толькос объектами. Всякий раз, когда выполняется присваивание объекта элементу какой-либо 
структуры или имени переменной, интерпретатор Python сохраняет ссылку на этот объект, а не его копию
(за исключением, когда явно запрашивается выполнение операции копирования).

>>>отсюда вывод - если хочешь хранить ссылки на объекты в системной таблице - используй списки.

>>>смотри help(list)

# Итерации по спискам и генераторы списков

>>> 3 in [1,2,3,4]
True
>>> for x in [1,2,3,4]:
...     print(x +1)
2
3
4
5
>>>

Оператор цикла for выбирает эле менты последовательности в порядке слева направо и выполняет одну или более 
инструкций для каждого из них.

Генераторы списков – это способ построить новый список, применяя выражение к каждому элементу
последовательности; они являются близкими родственниками инструкции цикла for.

>>> Heresy = [x*2 for x in "Horus Heresy"]       
>>> Heresy
['HH', 'oo', 'rr', 'uu', 'ss', '  ', 'HH', 'ee', 'rr', 'ee', 'ss', 'yy']
>>> 

Функционально это выражение эквивалентно циклу for, создающему список результатов вручную, но, как мы узнаем в
следующих главах, генераторы списков не только имеют более простой синтаксис, но и выполняются быстрее:

>>> res = []
>>> for c in "SPAM":                             
...     res.append(c * 4)                        
... 
>>> res
['SSSS', 'PPPP', 'AAAA', 'MMMM']
>>> 

>>> Heresy = []
>>> for x in "Horus Heresy":
...     Heresy.append(x * 2)
... 
>>> Heresy
['HH', 'oo', 'rr', 'uu', 'ss', '  ', 'HH', 'ee', 'rr', 'ee', 'ss', 'yy']
>>> 

Встроенная функция map выполняет похожие действия, но применяет к элементам последовательности не выражение,
а функцию, и из полученных результатов создает новый список:

>>> Heresy = list(map(abs, [1,2,3,4,5]))
>>> Heresy
[1, 2, 3, 4, 5]
>>> 

# Индексы, срезы и матрицы

Так как списки являются последовательностями, операции доступа к элементам по индексам и извлечения срезов 
работают точно так же, как и в случае со строками. Однако в результате обращения к элементу по индексу
возвращается объект, который расположен по указанному смещению, а в результате операции извлечения
среза всегда возвращается новый список:

>>> Heresy = ["Horus", "Heresy", "Heretic"]
>>> Heresy[0]
'Horus'
>>> Heresy[1]
'Heresy'
>>> Heresy[2]
'Heretic'
>>> Heresy[-2]
'Heresy'
>>> Heresy[:2]
['Horus', 'Heresy']
>>> 

Здесь следует отметить следующее: поскольку списки (и объекты других типов) могут быть вложены в другие списки,
иногда бывает необходимо объединять в цепочку несколько индексов, чтобы получить доступ к элементам на более
глубоком уровне вложенности в структуре данных. Например, один из простейших способов представления матриц
(многомерных массивов) в языке Python заключается в использовании вложенных списков. Ниже приводится
пример двухмерного массива размером 3x3, построенного на базе списков:

>>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> matrix[1]
[4, 5, 6]
>>> matrix[1][1]
5
>>> matrix[2][0]
7
>>> matrix = [[1,2,3],
...           [4,5,6],
...           [7,8,9]]
... 
>>> matrix[1][1]
5
>>> 

# хинт, если что модуль NumPy предоставляет другие способы организации матриц.

# Изменение списка

Списки относятся к категории изменяемых объектов, поэтому они поддерживают операции, которые изменяют сам
список непосредственно. Непосредственное изменение объекта может отражаться более чем на одной ссылке в
системной таблице. Все операции, представленные в этом разделе, изменяют сам список объектови не 
приводят к необходимости создавать новую копию объекта, как это было в случае со строками.

# Присваивание по индексам и срезам

>>> Heresy = ["Horus", "Heresy", "Heretic"]
>>> Heresy[0] = "Chaos"
>>> Heresy
['Chaos', 'Heresy', 'Heretic']
>>> Heresy = ["Horus", "Heresy", "Heretic"]
>>> Heresy[0:2] = ["Chaos", "Exterminatus"]
>>> Heresy
['Chaos', 'Exterminatus', 'Heretic']
>>> 

Обе операции присваивания – и отдельному элементу, и срезу – производятся непосредственно в списке – они 
изменяют сам список, а не создают новый список объектов. Операция присваивания по индексу в языке Python
работает практически так же, как в языке C и во многих других языках программирования: интерпретатор 
замещает старую ссылку на объект в указанном смещении на новую.

При редактировании списков в системной таблице происходит замещение старых ссылок на объекты на новые.

Присваивание срезу, последняя операция в предыдущем примере, замещает целый раздел списка за один прием.
Поскольку это довольно сложная операция (не вижу ничего сложного), проще будет представить ее, как
последовательное выполнение двух действий:

1. Удаление. Раздел списка, определяемый слева от оператора =, удаляется.

2. Вставка. Новые элементы, содержащиеся в объекте, расположенном справа от оператора =, вставляются в список,
начиная с левого края, где находился прежний удаленный срез.

В действительности это не совсем то, что происходит на самом деле, но это достаточно точно объясняет, почему
число вставляемых элементов не должно соответствовать числу удаляемых элементов. Например, представим, что 
список L имеет значение [1,2,3], тогда в результате операции присваивания L[1:2]=[4,5] будет получен 
список [1,4,5,3].

Интерпретатор сначала удалит 2 (срез, состоящий из одного элемента), а затем, начиная с позиции удаленного 
элемента 2, вставит элементы 4 и 5. Это также объясняет, почему операция L[1:2]=[] в действительности
является операцией удаления – интерпретатор удалит срез (элемент со смещением 1) и затем вставит 
пустой список.

# Методы списков.

>>> Heresy = ["Horus", "Heresy", "Heretic"]
>>> Heresy.append("Chaos")                               
>>> Heresy                                               
['Horus', 'Heresy', 'Heretic', 'Chaos']
>>> Heresy.sort()
>>> Heresy
['Chaos', 'Heresy', 'Heretic', 'Horus']
>>> 

Наиболее часто используемым методом, пожалуй, является метод append, который просто добавляет единственный
элемент (ссылку на объект) в конец списка. В отличие от операции конкатенации, метод append принимает
единственный объект, а не список. По своему действию выражение L.append(X) похоже на выражение L+[X],
но в первом случае изменяется сам список, а во втором – создается новый список.

.append - изменяет список
Heresy +[x] - создаёт новый

(а там где новый объект - там и новая ссылка на него)

Другой часто используемый метод – метод sort, выполняет переупорядочивание элементов в самом списке. По
умолчанию он использует стандартные операторы сравнения языка Python (в данном случае выполняется
сравнивание строк) и выполняет сортировку в порядке возрастания значений.

Однако существует возможность изменить порядок сортировки с помощью именованных аргументов – специальных 
синтаксических конструкций вида «name=value», которые используются в вызовах функций для передачи пара-
метров настройки по их именам. 

Именованный аргумент key в вызове метода sort позволяет определить собственную функцию сравнения, принимающую
единственный аргумент и возвращающую значение, которое будет использовано в операции сравнения, а именованный 
аргумент reverse позволяет выполнить сортировку не в порядке возрастания, а в порядке убывания:

>>> Heresy = ["abc", "ABD", "aBe"]
>>> Heresy.sort()                                        
>>> Heresy                                               
['ABD', 'aBe', 'abc']
>>> Heresy.sort(key=str.lower)                          
>>> Heresy                                               
['abc', 'ABD', 'aBe']
>>> Heresy.sort(key=str.lower, reverse=True)
>>> Heresy
['aBe', 'ABD', 'abc']
>>> 

# Аргумент key может также пригодиться при сортировке списков словарей, когда с его помощью можно указать ключ,
по которому будет определяться положение каждого словаря в отсортированном списке.

>>> Heresy = ["abc", "ABD", "aBe"]
>>> Heresy.sort()                                        # сортировка с учётом регистра символов
>>> Heresy                                               
['ABD', 'aBe', 'abc']
>>> Heresy.sort(key=str.lower)                           # привидение символов к нижнему регистру
>>> Heresy                                               
['abc', 'ABD', 'aBe']
>>> Heresy.sort(key=str.lower, reverse=True)			 # изменение направления сортировки
>>> Heresy
['aBe', 'ABD', 'abc']
>>> 

Важно заметить, что методы append и sort изменяют сам объект списка и невозвращают список в виде результата
(точнее говоря, оба метода возвращают значение None). Если вы написали инструкцию вроде L=L.append(X), вы 
не получите измененное значение L (в действительности вы вообще потеряете ссылку на список) – 
использование таких атрибутов, как append и sort, приводит к изменению самого объекта, 
поэтому нет никаких причин выполнять повторное присваивание.

>>> Heresy = ["abc", "ABD", "aBe"]
>>> Heresy.sort()                                        
>>> Heresy

Heresy - новая ссылка, старая отправилась погулять по полям варпа и было поглощена лордами хаоса.

Отчасти из-за этих особенностей методов в последних версиях Python сортировку можно также выполнить с помощью
встроенной функции, которая способна сортировать не только списки, но и любые другие последовательности
и возвращает новый список с результатом сортировки (оригинальный список при этом не изменяется):

sorted - сохраняет старую сслыку на изменяемый объект и создаёт новую.

>>> Heresy = ["abc", "ABD", "aBe"]
>>> sorted(Heresy, key=str.lower, reverse=True)          #  ['aBe', 'ABD', 'abc']
['aBe', 'ABD', 'abc']
>>> Heresy = ["abc", "ABD", "aBe"]
>>> sorted([x.lower() for x in Heresy], reverse=True)
['abe', 'abd', 'abc']
>>> 

В этом примере элементы списка предварительно изменяються с помощью генератора [x.lower() for x in Heresy],

>>> Heresy = list("Banned By The Horus")
>>> sorted([x+str(1) for x in Heresy], reverse=True)
['y1', 'u1', 's1', 'r1', 'o1', 'n1', 'n1', 'h1', 'e1', 'e1', 'd1', 'a1', 'T1', 'H1', 'B1', 'B1', ' 1', ' 1', ' 1']
>>> 

Технически выполняется сортировка не оригинального, а временного списка, созданного в процессе сортировки.

Как и строки, списки обладают рядом других методов, выполняющих специализированные операции. Например, метод
reverse изменяет порядок следования элементов в списке на обратный, а методы extend и pop вставляют несколько
элементов в конец списка и удаляют элементы из конца списка соответственно.

Кроме того, существует встроенная функция reversed, которая во многом напоминает встроенную функцию sorted, но
ее необходимо обертывать в вызов функции list, потому что она возвращает итератор (подробнее об итераторах
мы поговорим позднее):

>>> Heresy = list("Banned By The Horus")
>>> Heresy.pop()                                 
's'
>>> Heresy.reverse()                             
>>> Heresy                                       
['u', 'r', 'o', 'H', ' ', 'e', 'h', 'T', ' ', 'y', 'B', ' ', 'd', 'e', 'n', 'n', 'a', 'B']
>>> list(reversed(Heresy))
['B', 'a', 'n', 'n', 'e', 'd', ' ', 'B', 'y', ' ', 'T', 'h', 'e', ' ', 'H', 'o', 'r', 'u']
>>> 

# Хинт

В некоторых типах программ метод pop, показанный здесь, часто используется в паре с методом append для
реализации структур данных типа стек – «последний пришел, первый ушел» (Last-In-First-Out, LIFO). Конец
списка служит вершиной стека:

>>> Heresy= []
>>> Heresy.append(1)
>>> Heresy.append(2)
>>> Heresy
[1, 2]
>>> Heresy.pop()
2
>>> Heresy
[1]
>>> 

Метод pop может принимать необязательное смещение элемента, который удаляется из списка и возвращается (по
умолчанию это последний элемент). Другие методы списков позволяют удалять элементы с определенными
значениями (remove), вставлять элементы в определенную позицию (insert), отыскивать смещение 
элемента по заданно му значению (index) и так далее:

>>> Heresy = ["Horus", "Heresy", "Heretic"]
>>> Heresy.index("Horus")                         
0
>>> Heresy.insert(2, "Chaos")                     
>>> Heresy                                        
['Horus', 'Heresy', 'Chaos', 'Heretic']
>>> Heresy.pop(0)
'Horus'
>>> Heresy
['Heresy', 'Chaos', 'Heretic']
>>> 

# Прочие часто используемые операции над списками

Так как списки относятся к категории изменяемых объектов, вы можете ис пользовать инструкцию del для удаления
элемента или среза непосредственно из списка:

>>> Heresy = list("God Emperor vs Horus Banhammer")
>>> del Heresy[0]                                
>>> Heresy
['o', 'd', ' ', 'E', 'm', 'p', 'e', 'r', 'o', 'r', ' ', 'v', 's', ' ', 'H', 'o', 'r', 'u', 's', ' ', 'B', 'a', 'n', 'h', 'a', 'm', 'm', 'e', 'r']
>>> del Heresy[:4]                                 
>>> Heresy
['m', 'p', 'e', 'r', 'o', 'r', ' ', 'v', 's', ' ', 'H', 'o', 'r', 'u', 's', ' ', 'B', 'a', 'n', 'h', 'a', 'm', 'm', 'e', 'r']
>>> 

Так как операция присваивания срезу выполняется как удаление и вставка, можно удалять срезы списка, присваивая
им пустой список (L[i:j]=[]) – интерпретатор сначала удалит срез, определяемый слева от оператора =, а затем
вставит пустой список. С другой стороны, присваивание пустого списка по индексу элемента приведет к 
сохранению ссылки на пустой список в этом элементе, а не к его удалению:

(помни)

все операции непосредственного изменения объектов, обсуждавшиеся здесь, применимы только к изменяемым объектам:
они не будут работать со строками (или с кортежами, которые рассматриваются в главе 9), независимо от
прикладываемых вами усилий. Изменяемость или неизменяемость – это исходное свойство, присущее 
каждому типу объектов.

Лутц я помню! я уже давно понял глубокое дао системной таблицы нашего языка: 
- меняем ссылку на неизменяемый объект
- создаём копию неизменяемого объекта с целью записи нового (и как следствие новую ссылку на новый объект)
- изменям сам объект, если он является изменяемым, при этом в заивисмости от метода либо сохраняем ссылку, 
- либо нет. 

# Словари (вообще  словари и списки нравяться мне больше всего)

(!) Повторенье - мать учения, основные характеристики словарей по Лутцу

Доступ к элементам по ключу, а не по индексу.

Иногда словари называют ассоциативными массивами, или хешами. Они определяют взаимосвязь между значениями и
ключами, поэтому для извлечения элементов словаря можно использовать ключи, под которыми эти элементы были
сохранены в словаре. Для получения элементов словаря используется та же самая операция доступа по индексу,
как и в списке, только индекс приобретает форму ключа, а не смещения относительно начала.

Неупорядоченные коллекции произвольных объектов.

В отличие от списков, элементы словарей хранятся в неопределенном порядке. В действительности, интерпретатор
вносит элемент случайности в порядок следования элементов для обеспечения более быстрого поиска. Ключи 
описывают символическое (не физическое) местоположение элементов в словаре.

Переменная длина, гетерогенность и произвольное число уровней вложенности.

Подобно спискам словари могут увеличиваться и уменьшаться непосредственно (то есть без создания новых копий).
Они могут содержать объекты любых типов и поддерживают возможность создания произвольного числа уровней 
вложенности (они могут содержать списки, другие словари и так далее).

Относятся к категории «изменяемых отображений»

Словари могут изменяться непосредственно с использованием операции индексирования (они являются изменяемыми),
но они не поддерживают операции над последовательностями, которые поддерживаются строками и списками. Словари
представляют собой неупорядоченные коллекции,поэтому операции, которые основаны на использовании 
фиксированного порядка следования элементов (например, конкатенация, извлечение среза), не имеют
смысла для словарей. Словари – это единственный встроенный представитель объектов-отображений
(объекты, которые отображают ключи на значения).

Таблицы ссылок на объекты (хеш-таблицы)

Если списки – это массивы ссылок на объекты, которые поддерживают возможность доступа к элементам по их 
позициям, то словари – это неупорядоченные таблицы ссылок на объекты, которые поддерживают доступ к 
элементам по ключу. 

Внутри словари реализованы как хеш-таблицы (структуры данных, которые обеспечивают очень высокую скорость
поиска), изначально небольшого размера и увеличивающиеся по мере необходимости. Более того, интерпретатор
Python использует оптимизированные алгоритмы хеширования для обеспечения максимально высокой скорости
поиска ключей. Подобно спискам, словари хранят ссылки на объекты (а не их копии).

Судя по всему - словари и спики наиболее эффективны в объектно-ориентированном плане.

# смотри dir(dict) или help(dict)

При определении в виде литералов словари записываются как последовательность пар key:value, разделенных
запятыми, заключенных в фигурные скобки.1 Пустой словарь в литеральном представлении – это пустая пара 
скобок. Словари могут вкладываться в литеральном представлении в виде значений внутри других словарей, 
списков или кортежей.

# списки и словари увеличиваются в размерах по-разному. Как будет показано в следующем разделе, словари
обычно дополняются с помощью операции присваивания по новым ключам во время выполнения программы – такой
подход совершенно не годится для списков (списки обычно расширяются с помощью метода append).

>>> dic = {'anime':'аниме',"ghost":"призрак","shell":"образ"}
>>> list(dic.keys())
['shell', 'anime', 'ghost']
>>> "anime" in dic
True

# оператор проверки на вхождение in может использоваться для работы со строками и списками, но точно так же он
может использоваться и для работы со словарями. Это возможно благодаря тому, что словари определяют
итераторы, которые обеспечивают пошаговый обход списков ключей. Существуют и другие типы, которые
поддерживают итераторы, отвечающие обычному использованию типа; например, файлы имеют итераторы,
которые позволяют выполнять построчное чтение данных.

(!) Обратите также внимание на синтаксис list(dic.keys()). Мы были вынуждены заключить вызов метода в вызов 
функции list по уже встречавшейся ранее причине – в версии 3.0 метод keys возвращает итератор, а не список.
Вызов функции list принудительно выполняет обход всех значений итератора, что позволяет вывести их все сразу.

Словари, как и списки, относятся к категории изменяемых объектов, поэтому их можно изменять, увеличивать, 
уменьшать непосредственно, не создавая новые словари: чтобы изменить или создать новую запись в словаре,
достаточно выполнить операцию присваивания по ключу. Инструкция del также может применяться к словарям –
она удаляет значение, связанное с ключом, который играет роль индекса. Кроме того, обратите внимание на
наличие вложенного списка в следующем примере. Все типы-коллекции в языке Python могут вкладываться 
друг в друга в произвольном порядке:

>>> dic = {"Horus": 2, "Impi": 1, "Kaos": 3}
>>> dic["Horus"]                                 
2
>>> "Horus" in dic                               
True
>>> dic["Kaos"] = ["Warp", "Chaos", "Evil"]
>>> dic                                          
{'Kaos': ['Warp', 'Chaos', 'Evil'], 'Impi': 1, 'Horus': 2}
>>> del dic["Impi"]
>>> dic                                          
{'Kaos': ['Warp', 'Chaos', 'Evil'], 'Horus': 2}
>>> dic["Impi"] = "Banned Impi"
>>> dic
{'Kaos': ['Warp', 'Chaos', 'Evil'], 'Impi': 'Banned Impi', 'Horus': 2}
>>> 

# Дзен отличия словарей от списокв

В отличие от списков, словари допускают выполнение присваивания по новому ключу (который ранее отсутствовал),
в результате создается новый элемент словаря. Этот прием не может применяться к спискам, потому что в этом 
случае интерпретатор обнаруживает выход за пределы списка и генерирует сообщение об ошибке. Чтобы увеличить
размер списка, необходимо использовать такие инструменты списков, как метод append или присваивание срезу.

# Дополнительные методы словарей

Методы словарей values и items возвращают список значений элементов словаря и кортежи пар (key, value) 
соответственно:

>>> dic = {"Horus": 2, "Impi": 1, "Kaos": 3}
>>> list(dic.values())                          #  [2, 1, 3] 
>>> list(dic.items())
[('Impi', 1), ('Kaos', 3), ('Horus', 2)]
>>> 

Такие списки удобно использовать в циклах, когда необходимо выполнить обход элементов словаря. Попытка 
извлечения несуществующего элемента словаря обычно приводит к появлению ошибки, однако метод get в 
таких случаях возвращает значение по умолчанию (None или указанное значение). С помощью этого 
метода легко можно реализовать получение значений по умолчанию и избежать появления ошибки
обращения к несуществующему ключу:

>>> dic.get("Horus")                             
2
>>> print(dic.get("anime"))                      
None
>>> dic.get("anime", 501)
501
>>> 

Метод update реализует своего рода операцию конкатенации для словарей, при этом он не имеет никакого отношения
к упорядочению элементов слева направо (для словарей такое упорядочение не имеет смысла). Он объединяет ключи
и значения одного словаря с ключами и значениями другого, просто перезапи сывая значения с одинаковыми
ключами:

>>> Heresy = {"Horus Heresy":{"Horus":1, "Emperor":2}}
>>> dic = {'anime':'аниме',"ghost":"призрак","shell":"образ"}
>>> Heresy.update(dic)                           
>>> Heresy                                       
{'ghost': 'призрак', 'Horus Heresy': {'Emperor': 2, 'Horus': 1}, 'anime': 'аниме', 'shell': 'образ'}
>>> 

Метод pop удаляет ключ из словаря и возвращает его значение. Он напоминает метод pop списков, только вместо 
необязательного индекса элемента принимает ключ:

>>> Heresy = {"Horus Heresy":{"Horus":1, "Emperor":2}}
>>> dic = {'anime':'аниме',"ghost":"призрак","shell":"образ"}
>>> Heresy.update(dic)                           
>>> Heresy                                       
{'shell': 'образ', 'anime': 'аниме', 'Horus Heresy': {'Horus': 1, 'Emperor': 2}, 'ghost': 'призрак'}
>>> Heresy.pop("anime")                          
'аниме'
>>> Heresy
{'shell': 'образ', 'Horus Heresy': {'Horus': 1, 'Emperor': 2}, 'ghost': 'призрак'}
>>> 

Кроме того, словари имеют метод copy, который мы рассмотрим в главе 9, как один из способов избежать побочных
эффектов, связанных с наличием нескольких ссылок на один и тот же словарь.

# Таблица языков

В следующем примере создается таблица, которая отображает названия ереси (ключи) на имена их создателей
(значения). С помощью этой таблицы можно по названию ереси определить имя создателя ереси:

>>> Heresy = {"Horus Heresy": "Horus",
...         "Holy Terra": "Impi",
...         "Anime": " Major",
...         "Chaos Heresy": "Slaanesh"}
... 
>>> Heresy
{'Horus Heresy': 'Horus', 'Anime': ' Major', 'Holy Terra': 'Impi', 'Chaos Heresy': 'Slaanesh'}
>>> story1 = "Horus Heresy"
>>> creator1 = Heresy[story1]
>>> creator1                                     
'Horus'
>>> story2 = "Holy Terra"
>>> creator2 = Heresy[story2]
>>> creator2                                     
'Impi'
>>> story3 = "Anime"
>>> creator3 = Heresy[story3]
>>> story4 = "Chaos Heresy"
>>> creator4 = Heresy[story4]
>>> creator3                                     
'Major'
>>> creator4
'Slaanesh'
>>> for x in Heresy:
...     print(x, "\t", Heresy[x])
Holy Terra 	 Impi
Horus Heresy 	 Horus
Anime 	 Major
Chaos Heresy 	 Slaanesh
>>> for lang in Heresy:
...     print(lang, "\t", Heresy[lang])
Holy Terra 	 Impi
Horus Heresy 	 Horus
Anime 	 Major
Chaos Heresy 	 Slaanesh
>>> 

(можно вспомнить символы табуляции - это было гдето выше и отредактировать выводимт текст получше, например)

>>> for x in Heresy:
...     print(x, "\t     ", Heresy[x])
Holy Terra 	      Impi
Anime 	      Major
Horus Heresy 	      Horus
Chaos Heresy 	      Slaanesh
>>> 

>>> for x in Heresy:
...     print(x, "\t\\", Heresy[x])
Horus Heresy 	\ Horus
Holy Terra 	\ Impi
Anime 	\ Major
Chaos Heresy 	\ Slaanesh
>>> 

>>> for x in Heresy:
...     print(x, Heresy[x])
Anime Major
Horus Heresy Horus
Chaos Heresy Slaanesh
Holy Terra Impi
>>> 

если: 

>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
>>> for name, phone in table.items():
...     print('{0:10} ==> {1:10d}'.format(name, phone))
Sjoerd     ==>       4127
Jack       ==>       4098
Dcab       ==>       7678
>>> 

тогда:

>>> Heresy = {"Horus Heresy": "Horus",
...         "Holy Terra": "Impi",
...         "Anime": "Major",
...         "Chaos Heresy": "Slaanesh"} 
... 
>>> for name, phone in Heresy.items():
...     print('{0:10} ==> {1:10}'.format(name, phone))
Holy Terra ==> Impi      
Anime      ==> Major     
Horus Heresy ==> Horus     
Chaos Heresy ==> Slaanesh  
>>> 

или

>>> Heresy = {"Horus Heresy": "Horus",
...         "Holy Terra": "Impi",
...         "Anime": "Major",
...         "Chaos Heresy": "Slaanesh"} 
... 
>>> for x, y in Heresy.items():
...     print('{0:10} ==> {1:10}'.format(x, y))
Holy Terra ==> Impi      
Anime      ==> Major     
Horus Heresy ==> Horus     
Chaos Heresy ==> Slaanesh  
>>> 

и в результате то что и требоваловь - красивый вывод таблицы имён:

>>> Heresy = {"Horus Heresy": "Horus",
...         "Holy Terra": "Impi",
...         "Anime": "Major",
...         "Chaos Heresy": "Slaanesh"}
... 
>>> Heresy
{'Horus Heresy': 'Horus', 'Chaos Heresy': 'Slaanesh', 'Anime': 'Major', 'Holy Terra': 'Impi'}
>>> story1 = "Horus Heresy"
>>> creator1 = Heresy[story1]
>>> creator1                                     # 'Horus'
'Horus'
>>> story2 = "Holy Terra"
>>> creator2 = Heresy[story2]
>>> creator2                                     # 'Impi'
'Impi'
>>> story3 = "Anime"
>>> creator3 = Heresy[story3]
>>> story4 = "Chaos Heresy"
>>> creator4 = Heresy[story4]
>>> creator3                                     # 'Major'
'Major'
>>> creator4
'Slaanesh'
>>> for x, y in Heresy.items():
...     print('{0:15} ==> {1:10s}'.format(x, y))
Horus Heresy    ==> Horus     
Chaos Heresy    ==> Slaanesh  
Anime           ==> Major     
Holy Terra      ==> Impi      
>>> 

Опять я усложнил учебный процесс (!) и потратил время, в любом случае глубокий смысл этого примера в том, что:
Python в действительности позволяет выполнять обход ключей словаря и без вызова метода keys в операторе цикла
for. Для любого словаря D цикл можно оформить как for key in D:, что равносильно полной форме записи 
for key in D.keys(): -  for x in Heresy: # То же, что и: for x in Heresy.keys()

# Лутц вешает дзен про словари:

Операции над последовательностями неприменимы к словарям. Словари – это отображения, а не последовательности.
Вследствие того, что словари не предусматривают никакого упорядочения элементов, такие операции, как
конкатенация (упорядоченное объединение) и извлечение среза (извлечениенепрерывного блока элементов),
просто неприменимы.

Присваивание по несуществующему индексу приводит к созданию нового элемента. Ключи можно создавать при 
определении словаря в виде литерала (в этом случае они встраиваются непосредственно в литерал) или при
присваивании значения новому ключу существующего объекта словаря.Результат получается тот же самый.

Ключи не обязательно должны быть строками. В наших примерах в качестве ключей использовались строки, но могут 
использоваться любые другие неизменяемые объекты (то есть не списки). Например, в качестве ключей допустимо
использовать целые числа, что превращает словарь в подобие списка (как минимум, в смысле индексирования).

В качестве ключей можно также использовать кортежи, что позволяет создавать составные ключи. Экземпляры 
классов (обсуждаются в четвертой части книги) также могут играть роль ключей при условии, что они
поддерживают определенные методы, которые сообщат интерпретатору, что он имеет дело с неизменяемым
объектом, в противном случае они будут бесполезны, если рассматривать их как фиксированные ключи.

Самое умное это месседж про то, что в словарях возможно использовать эксземпляры классов.
По всей  видимости имеется ввиду то, что классом объектов может соотвествоать значение.

наверное это выглядит так (если помнить что у меня уже есть класс объектов - anime)

Heresy = {"anime": "anime is a not a string - anime is a class object type"}

# Использование словарей для имитации гибких списков

Списки не допускают возможность присваивания по индексам, находящимся за пределами списков - это я видел, 
возвращает исключение list assignment index out of range

Можно, конечно, с помощью операции повторения создать список достаточно большой длины (например, [0]*100), но
можно создать нечто похоже, задействовав словарь, который не требует такого выделения пространства. При 
использовании целочисленных ключей словари могут имитировать списки, которые увеличиваются при
выполнении операции присваивания по смещению:

>>> Heresy = {}
>>> Heresy[99] = "Horus Heresy"
>>> Heresy[99]
'Horus Heresy'
>>> Heresy
{99: 'Horus Heresy'}
>>> 

Результат выглядит так, как если бы Heresy был списком из 100 элементов, но на самом деле это словарь с 
единственным элементом – значением ключа 99 является строка "Horus Heresy". В такой структуре можно
обращаться по смещениям, как в списке, но при этом не требуется выделять пространство для всех 
позиций, которые могут когда-либо потребоваться при выполнении программы. При использовании
подобным образом словари представляют собой более гибкие эквиваленты списков.

# Использование словарей для структур разреженных данных.

(Лутц продолжает вещать про гибкость в словарях, хорошо что я познакомился со словарями ранее)

Похожим образом словари могут использоваться для реализации структур разреженных данных, таких как многомерные
массивы, где всего несколько элементов имеют определенные значения:

>>> Heresy = {}
>>> Heresy[(2,3,4)] = 88
>>> Heresy[(11,404,501)] = 99
>>> x = 2; y = 3; z = 4                         
>>> Heresy[(x,y,z)]                              
88
>>> Heresy                                       
{(11, 404, 501): 99, (2, 3, 4): 88}
>>> a = 11; b = 404; c = 501
>>> Heresy[(a,b,c)]                            
99

Здесь словарь использован для представления трехмерного массива, в котором только два элемента, (2,3,4) и 
(11,404,501), имеют определенные значения. Ключами словаря являются кортежи, определяющие координаты 
непустых элементов.

Благодаря этому вместо трехмерной матрицы, объемной и по большей части пустой, оказалось достаточно 
использовать словарь из двух элементов. В такой ситуации попытка доступа к пустым элементам будет
приводить к возбуждению исключения, так как эти элементы физически отсутствуют:

>>> Heresy[(2,3,6)]

Traceback (most recent call last): File “<stdin>”, line 1, in ? KeyError: (2, 3, 6)

# Как избежать появления ошибок обращения к несуществующему ключу:

Существует по крайней мере три способа получить значение по умолчанию вместо возбуждения исключения – можно 
предварительно проверить наличие ключа с помощью условного оператора if, воспользоваться конструкцией try,
чтобы перехватить и явно обработать исключение, или просто использовать представленный ранее метод словаря
get, способный возвращать значение по умолчанию для несуществующих ключей:

>>> if (2,3,6) in Heresy:
...     print(Heresy[(2,3,6)])
... else:
...     print("Horus Heresy is everything for me")
Horus Heresy is everything for me
>>> 

(!)

>>> try:                                            # попытаться обратиться по индексу
...     print(Heresy[(2,3,6)])
... except KeyError:                                # перехватить исключение и обработать (вижу в первый раз)
...     print("Horus Heresy is everything for me")
Horus Heresy is everything for me
>>> 

АГА! значит если я пишу:except KeyError - то программа перехватыает указанный тип исключения, обрабаывает его
и вместо того что бы остановиться - едет дальше. Нужно будет внимательно почитать про перехват исключений.

>>> Heresy.get((2,3,4), 0)                          
88
>>> Heresy.get((2,3,6), 0)                          
0
>>> Heresy.get((2,3,6), 11)
11
>>> 

# Использование словарей в качестве «записей».

словари представляют один из многих способов описания свойств элементов в программах, то есть они могут играть
ту же роль, какую играют «структуры» и «записи» в других языках программирования. В следующем примере 
выполняется заполнение словаря путем присваивания значений новым ключам в виде нескольких инструкций:

>>> rec = {}
>>> rec["name"] = "Horus"
>>> rec["age"] = "501"
>>> rec["job"] = "Heresy"
>>> print(rec["name"])
Horus
>>> 

Встроенные типы языка Python позволяют легко представлять структурированную информацию; это особенно заметно,
когда появляются уровни вложенности. В следующем примере снова используется словарь для хранения свойств
объекта, но на этот раз заполнение производится в единственной инструкции (вместо того, чтобы выполнять
присваивание каждому ключу в отдельности), причем здесь присутствуют вложенные список и словарь,
чтобы обеспечить представление структурированных свойств объекта:

Чтобы извлечь компоненты вложенных объектов, достаточно просто объеди- извлечь компоненты вложенных объектов,
достаточно просто объединить в цепочку операции индексирования:

Heresy = {"name":"Horus",
        "jobs":["Heresy","Heretic"],
        "web":"www.chaos.net/Horus",
        "home":{"state":"Terra","zip":"501404"}}
Heresy["name"]                                
Heresy["jobs"]
Heresy["jobs"][1]
Heresy["home"]["zip"]

# интерфейсы словарей (годнота на будущее)

Некоторые расширения для Python также предоставляют интерфейсы, которые выглядят и действуют как словари. На-
пример, обращение к индексированным файлам данных в формате DBM во многом напоминает обращение к словарю, 
который сначала требуется открыть. Строки сохраняются и извлекаются с помощью операции индексирования
по ключу:

import anydbm
file = anydbm.open(“filename”) # Ссылка на файл
file[‘key’] = ‘data’		   # Сохранение данных по ключу
data = file[‘key’]			   # Извлечение данных по ключу

В главе 27 будет показано, как таким же способом можно сохранять целые объекты Python, достаточно лишь заменить
имя модуля anydbm на shelve (shelves (хранилища) – это базы данных с доступом к информации по ключу, 
предназначенные для хранения объектов Python). 

Для работы в Интернете поддержка CGI-сценариев, предусмотренная в языке Python, также обеспечивает интерфейс,
напоминающий словарь. Вызов метода cgi.FieldStorage возвращает объект, по своим характеристикам
напоминающий словарь, – с одной записью для каждого поля ввода, находящегося на клиентской
веб-странице:

import cgi
form = cgi.FieldStorage()					# Анализирует данные формы
if ‘name’ in form:
	showReply(‘Hello, ‘ + form[‘name’].value)

# Другие способы создания словарей.

Благодаря практической ценности словарей с течением времени способы их создания пополнялись. 

>>> {"name": "Horus", "age": 501}                 # традиционное литеральное выражение
{'name': 'Horus', 'age': 501}
>>> Heresy = {}                                   # динамическое присваивание по ключам
>>> Herey["name"] = "Horus"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'Herey' is not defined
>>> Heresy["age"] = 501
>>> Heresy = dict(name= "Horus", age= 501)              # форма именованных элементов
>>> Heresy
{'age': 501, 'name': 'Horus'}
>>> Heresy = dict([("name", "Horus"), ("age", 501)])	# Кортежи ключ/значение
>>> 

Все четыре варианта создают один и тот же словарь, содержащий два элемента, которые удобно использовать в
следующих случаях:

• Первый вариант удобен, если содержимое всего словаря известно заранее.

• Второй вариант удобно использовать, когда необходимо динамически создавать словарь по одному полю за раз.

• Третий вариант с использованием именованных аргументов даже компакт нее, чем литералы, но он требует, чтобы 
  все ключи были строками.

• Последний вариант удобен, когда ключи и значения во время выполнения программы необходимо хранить в виде 
  последовательностей.

Gоследний вариант часто используется в соединении с функцией zip, которая позволяет объединить отдельные
списки ключей и значений, создаваемые динамически во время выполнения (например, при извлечении данных из
столбцов в файле).

(!)

Если значения всех ключей словаря остаются все время одними и теми же, можно использовать специализированную 
форму инициализации словаря, при использовании которой достаточно просто передать список ключей и начальное 
значение (по умолчанию используется значение None):

>>> Heresy = dict.fromkeys(["a", "b"], 0)
>>> Heresy
{'b': 0, 'a': 0}
>>> Heresy = dict.fromkeys(["a", "b"], 11)
>>> Heresy
{'b': 11, 'a': 11}
>>> Heresy = dict.fromkeys(["a", "b", 11], "Horus Heresy")
>>> Heresy
{11: 'Horus Heresy', 'b': 'Horus Heresy', 'a': 'Horus Heresy'}
>>> 

# начальное значение это х в выражении dict.fromkeys(["a", "b"], х) - может быть чем угодно по типу.

# Лутц вешает про условно новые фичи

В версии 3.0 словари:

• Поддерживают новые выражения генераторов словарей, близко напоминающие генераторы списков и множеств.

• Методы D.keys, D.values и D.items возвращают итерируемые представления вместо списков.

• Вследствие особенности, описанной в предыдущем пункте, требуют по иному выполнять обход ключей в
   отсортированном порядке.

• Больше не поддерживают возможность непосредственного сравнивания между собой – теперь сравнивание должно
   выполняться вручную.

• Больше не поддерживают метод D.has_key – вместо него следует использовать оператор in проверки на вхождение.

# Генераторы словарей

Генераторы словарей выполняют цикл, отбирают пары ключ/значение в каждой итерации и заполняют ими новый словарь.
Значения, получаемые в ходе итераций, доступны в виде переменной цикла. 

Например, одним из стандартных способов динамической инициализации словаря в версиях 2.6 и 3.0 является
использование функции zip для объединения ключей и значений с последующей передачей результата функции
dict.

Функция zip позволяет единственным вызовом создать словарь из списков ключей и значений. Если множество ключей
и значений заранее не известно, вы всегда можете поместить их в списки в процессе вычислений и затем
объединить их воедино:

>>> list(zip(["Heresy","Horus","Chaos"],["Horus Heresy","Horus Heretic","Chaos Heresy"]))
[('Heresy', 'Horus Heresy'), ('Horus', 'Horus Heretic'), ('Chaos', 'Chaos Heresy')]
>>> 

# ниже пример создания словаря Ериси из результата вызова фукнции zip

>>> Heresy = dict(zip(["Heresy","Horus","Chaos"],["Horus Heresy","Horus Heretic","Chaos Heresy"]))
>>> Heresy
{'Chaos': 'Chaos Heresy', 'Heresy': 'Horus Heresy', 'Horus': 'Horus Heretic'}
>>>

В Python 3.0 того же эффекта можно добиться с помощью генератора словарей. В следующем примере демонстрируется
создание нового словаря из пар ключ/значение, которые извлекаются из результата вызова функции zip (это выра-
жение читается практически точно так же, хотя и выглядит немного сложнее):

>>> Heresy = {x: y for (x, y) in zip(["Heresy","Horus","Chaos"],["Horus Heresy","Horus Heretic","Chaos Heresy"])}
>>> Heresy
{'Heresy': 'Horus Heresy', 'Horus': 'Horus Heretic', 'Chaos': 'Chaos Heresy'}
>>> 

Генераторы словарей выглядят менее компактными, но они гораздо более универсальны, чем можно было бы 
предположить, исходя из этого примера, – мы можем использовать их для отображения единственной
последовательности значений в словари, вычисляя ключи с помощью выражений, как обычные
значения:

>>> D = {x: x ** 2 for x in [1, 2, 3, 4]}
>>> D
{1: 1, 2: 4, 3: 9, 4: 16}
>>>

>>> Heresy = {x: x + 1 for x in [1,2,3,4]}
>>> Heresy
{1: 2, 2: 3, 3: 4, 4: 5}
>>> 

>>> Heresy = {x: x + 1 for x in range(1,5)}
>>> Heresy
{1: 2, 2: 3, 3: 4, 4: 5}
>>> 

>>> Heresy = {x: x + 1 for x in range(-1,7)}
>>> Heresy
{0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, -1: 0}
>>>

>>> Heresy = {x: x * 1 for x in "Heresy"}
>>> Heresy
{'r': 'r', 's': 's', 'y': 'y', 'H': 'H', 'e': 'e'}
>>> 

>>> Heresy = {a: a + " anime" for a in ["Horus Heresy", "Chaos Heresy"]}
>>> Heresy
{'Horus Heresy': 'Horus Heresy anime', 'Chaos Heresy': 'Chaos Heresy anime'}
>>> 

Генераторы словарей удобно использовать для инициализации словарей из списков ключей, почти так же, как это
делает метод fromkeys

>>> Heresy = dict.fromkeys(["a", "b", "Chaos"], 0)
>>> Heresy
{'Chaos': 0, 'a': 0, 'b': 0}
>>> 

Тоже самое, но методом генератора, похоже генератор словарей решает!

>>> Heresy = {x: 0 for x in ["a", "b", "Chaos"]}
>>> Heresy
{'a': 0, 'Chaos': 0, 'b': 0}
>>> 

ибо:

>>> Heresy = {x: "Null heresy" for x in ["a", "b", "Chaos"]}
>>> Heresy
{'a': 'Null heresy', 'b': 'Null heresy', 'Chaos': 'Null heresy'}
>>>

ещё пример генератора из другого интерируемого объекта с использованием ключей по умолчанию (умл. - None)

>>> Heresy = dict.fromkeys("Horus Heresy")
>>> Heresy      
{'e': None, 'y': None, 'r': None, 'u': None, 'o': None, ' ': None, 'H': None, 's': None}

>>> Heresy = {x: None for x in "Horus Heresy"}
>>> Heresy
{'e': None, 'y': None, 'r': None, 'u': None, 'o': None, ' ': None, 'H': None, 's': None}
>>> 

Подобно родственным инструментам, генераторы словарей поддерживают дополнительные возможности, которые не 
были продемонстрированы здесь, включая вложенные циклы и условные инструкции if. См. главы 14 и 20.

# Представление словарей.

В версии 3.0 методы словарей keys, values и items возвращают объекты представлений.

Объекты представлений – это итерируемые объекты, то есть объекты, которые вместо всего списка значений 
возвращают по одному значению за одно обращение. Кроме того, что они являются итерируемыми объектами,
представления словарей также сохраняют оригинальный порядок следования компонентов словаря, отражают
результаты операций, которые выполняются над словарем, и поддерживают операции над множествами.

С другой стороны, они не являются списками и не поддерживают такие операции, как обращение к элементам по
индексам или метод sort списков, а также не отображают значения своих элементов при выводе.

Понятие итерируемого объекта более формально будет рассматриваться в главе 14, а пока нам достаточно будет
знать, что результаты этих трех методов необходимо обертывать вызовом встроенной функции list, – если
появится необходимость применить операции над списками или отобразить значения элементов:

Лутцу вещает что в версии 3.0 представления словарей сохраняют оригинальный порядок следования словаря

>>> D = dict(a=1, b=2, c=3)
>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}
>>> K = D.keys()						# В версии 3.0 создаст объект представления, а не список
>>> K
<dict_keys object at 0x026D83C0>
>>> list(K)								# Принудительное создание списка в версии 3.0
[‘a’, ‘c’, ‘b’]
>>> V = D.values()						# То же относится к представлениям значений и элементов
>>> V
<dict_values object at 0x026D8260>
>>> list(V)
[1, 3, 2]
>>> list(D.items())
[(‘a’, 1), (‘c’, 3), (‘b’, 2)]
>>> D = dict(a=1, b=2, c=3)
>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}
>>> list(K)[0]
‘a’

НО!В моей весрии 3.5 интерпретатор возвращает список объектов и представления словарей не сохраняют порядок.

>>> Heresy = dict(Horus = 1, Heresy = 404, Chaos = 505)
>>> Heresy                                 
{'Chaos': 505, 'Heresy': 404, 'Horus': 1}
>>> Anime = Heresy.keys()
>>> Anime                                    
dict_keys(['Chaos', 'Heresy', 'Horus'])
>>> list(Heresy)                           
['Chaos', 'Heresy', 'Horus']
>>> Story = Heresy.values()                
>>> Story                                  
dict_values([505, 404, 1])
>>> list(Story)                            
[505, 404, 1]
>>> list(Heresy.items())                   
[('Chaos', 505), ('Heresy', 404), ('Horus', 1)]
>>> list(Heresy)[0]
'Chaos'
>>> 

По факту результат >>> list(Heresy)[0] всегда будет разным, вот напрмимер:

>>> Heresy = dict(Major = "ghost", Bato = "boevik", Gato = "enemy", unit = 501, story = 404)
>>> Heresy                                 # возвращает весь словарь
{'story': 404, 'Bato': 'boevik', 'Major': 'ghost', 'Gato': 'enemy', 'unit': 501}
>>> Anime = Heresy.keys()                  # ключи
>>> Anime                                  # возвращает ключ словаря
dict_keys(['story', 'Bato', 'Major', 'Gato', 'unit'])
>>> list(Heresy)                           # создаёт список из сключей словаря
['story', 'Bato', 'Major', 'Gato', 'unit']
>>> Story = Heresy.values()                # значения ключей
>>> Story                                  # возвращает значения ключей словаря
dict_values([404, 'boevik', 'ghost', 'enemy', 501])
>>> list(Story)                            # создание списка из значения ключей словаря
[404, 'boevik', 'ghost', 'enemy', 501]
>>> list(Heresy.items())                   # создание спика из объектов словаря - ключей и значений
[('story', 404), ('Bato', 'boevik'), ('Major', 'ghost'), ('Gato', 'enemy'), ('unit', 501)]
>>> list(Heresy)[0]                        # обращается по индексу к элементам списка, теряет порядок
'story'
>>> list(Heresy)[0:2]                      # извлекает срез из элементов списка, теряет порядок
['story', 'Bato']
>>> 

Происходит это потому что в версии 3.5 представления словарей не являються интерируемыми объектами, наверное
было бы удобнее что бы они были таковыми, но по факту мы имеем то что имеем.

Далее Лутц вешает о том, что: Кроме случаев отображения результатов в интерактивной оболочке, вы едва ли
будете обращать внимание на эту особенность, потому что конструкции обхода элементов в цикле в языке 
Python автоматически заставляют итерируемые объекты возвращать по одному результату в каждой итерации:

В версии 3.0 наверное сохраняет порядок следования, а у меня нет.

>>> for k in D.keys(): print(k)
a
b
c
>>> 

>>> for k in D.keys(): print(k)
c
b
a
>>> 

Кроме того, в версии 3.0 словари по-прежнему остаются итерируемыми объектами, которые последовательно 
возвращают ключи, как и в версии 2.6, – что исключает необходимость вызывать метод keys:

(!) а в версии 3.5 нет и как следствие нарушают порядок вывода элементов:

>>> for key in D: print(key)
c
b
a
>>> 

>>> for k in D.keys(): print(k)            
c
a
b
>>> for key in D: print(key)
c
a
b
>>> 

Далее Лутц вещает что: в отличие от списков, возвращаемых в виде результатов в версии 2.X, представления 
словарей в версии 3.0 способны динамически отражать все последующие изменения в словарях, выполненные
уже после создания объекта отображения:

В теории:

>>> D = {‘a’:1, ‘b’:2, ‘c’:3}
>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}
>>> K = D.keys()
>>> V = D.values()
>>> list(K)						# Представления сохраняют оригинальный
[‘a’, ‘c’, ‘b’]					# порядок следования ключей в словаре
>>> list(V)
[1, 3, 2]
>>> del D[‘b’]					# Изменяет словарь непосредственно
>>> D
{‘a’: 1, ‘c’: 3}
>>> list(K)						# Изменения в словаре отражаются на объектах представлений
[‘a’, ‘c’]
>>> list(V)						# Но это не так в версии 2.X!
[1, 3]

На практике представления словарей не сохраняют оригинальный порядок.

>>> D = {"a":1, "b":2, "c":3}
>>> D
{'c': 3, 'a': 1, 'b': 2}
>>> K = D.keys()
>>> V = D.values()
>>> list(K)                                 # Представления сохраняют оригинальный
['c', 'a', 'b']
>>> list(V)
[3, 1, 2]
>>> del D["b"]                              # Изменяет словарь непосредственно
>>> D
{'c': 3, 'a': 1}
>>> list(K)                                 # Изменения в словаре отражаются на объектах представлений
['c', 'a']
>>> list(V)
[3, 1]
>>> 

В итоге, в Python версии 3.5 мы имеем два варианта.
- 1 использовать малопонятный import collections https://pymotw.com/3/collections/ordereddict.html
- использовать .sort() в отношении списка

Поддержки интерируемый объектов по методам .keys .values на страницах интернета в отношении 3.5+ не наблюдаю.

Сортировка списков.

>>> D = {"a":1, "b":2, "c":3}
>>> D
{'b': 2, 'a': 1, 'c': 3}
>>> K = D.keys()
>>> a = list(K)
>>> a.sort()
>>> a
['a', 'b', 'c']
>>> V = D.values()
>>> b = list(V)
>>> b.sort()
>>> b
[1, 2, 3]
>>> a[1]
'b'
>>> b[0:2]
[1, 2]
>>> 

import collections 

>>> import collections
>>> Heresy = collections.OrderedDict()
>>> Heresy["Horus"] = "Heresy"
>>> Heresy["Chaos"] = "Chaos Heresy"
>>> Heresy["Crusade"] = "Anti Heresy"
>>> Heresy
OrderedDict([('Horus', 'Heresy'), ('Chaos', 'Chaos Heresy'), ('Crusade', 'Anti Heresy')])
>>> a = Heresy.keys()
>>> b = Heresy.values()
>>> a
odict_keys(['Horus', 'Chaos', 'Crusade'])
>>> b
odict_values(['Heresy', 'Chaos Heresy', 'Anti Heresy'])
>>> x = list(a)
>>> y = list(b)
>>> x[1]
'Chaos'
>>> y[0]
'Heresy'
>>> 

Ибо.

A regular dict does not track the insertion order, and iterating over it produces the values in order based
on how the keys are stored in the hash table, which is in turn influenced by a random value to reduce 
collisions. In an OrderedDict, by contrast, the order in which the items are inserted is remembered 
and used when creating an iterator

Regular dictionary:
c C
b B
a A

OrderedDict:
a A
b B
c C

# Представления словарей и множества

Кроме того, в отличие от списков результатов, возвращаемых в версии 2.X, объекты представлений в версии 3.0,
возвращаемые методом keys, похожи на множества и поддерживают операции над множествами, такие как пересече-
ние и объединение. 

Объекты представлений, возвращаемые методом values,такой особенностью не обладают, потому что они не являются
уникальными, тогда как объекты представлений, возвращаемые методом items, такой особенностью обладают, если
пары (key, value) являются уникальными и хешируемыми.

Учитывая, что множества достаточно сильно похожи на словари, ключи которых не имеют значений (и даже литералы
множеств в версии 3.0 заключаются в фигурные скобки, как словари), это обстоятельство выглядит вполне
логичным. 

Подобно ключам словарей, элементы множеств неупорядочены, уникальны и относятся к разряду неизменяемых
объектов.

Ниже наглядно показано, как интерпретируются списки ключей, когда они используются в операциях над множествами.
В таких операциях объекты представлений могут смешиваться с другими представлениями, множествами и словарями
(в этом случае словари интерпретируются точно так же, как представления, возвращаемые методом keys):

>>> D = {"a":1, "b":2, "c":3}
>>> D
{'a': 1, 'c': 3, 'b': 2}
>>> K = D.keys()
>>> K | {"x": 4}
{'a', 'c', 'b', 'x'}
>>> K
dict_keys(['a', 'c', 'b'])
>>> 

Тут Лутц затрагивает гибкость, но похоже что к концу главы он устал и ему лень много писать. Общая идея в том,
что раз содержимое словаря близко по дузху многим другим представлениям в Питон и как следствие интерпретатор
не боиться с ними работать в рамках одного выражения.
А именно, интерпретатору нравяться ключи словарей.

Что же в отношении значений словарей, то:

>>> D = {"a":1, "b":2, "c":3}
>>> V = D.values()
>>> V & {"x": 4}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for &: 'dict_values' and 'dict'
>>>  

итого:

>>> Heresy = dict(Major = "ghost", Bato = "boevik", Gato = "enemy", unit = 501, story = 404)
>>> Anime = Heresy.keys()
>>> Story = Anime & {"Horus Heresy": "Anime Chaos"}
>>> Story
set()
>>> 

как мы видим в рамках идей гибкости интерпретатор возвращает нам множество - set()

# Представления элементов словарей также могут обладать свойствами множеств, если они допускают возможность 
хеширования, – то есть, если они содержат только неизменяемые объекты:

>>> anime = {"Major": 1, "Ghost": 2, "Complex": 501}
>>> list(anime.items())
[('Major', 1), ('Ghost', 2), ('Complex', 501)]
>>> anime.items() | anime.keys()
{'Complex', 'Major', ('Complex', 501), ('Ghost', 2), ('Major', 1), 'Ghost'}
>>> anime.items() | anime
{'Major', 'Complex', ('Major', 1), 'Ghost', ('Complex', 501), ('Ghost', 2)}

>>> anime.items() | anime.keys()  # перед нами объединение представлений элементов похожих на множества

>>> anime.items() | anime	      # Словари интерпретируются как представление ключей - ибо есть правило (!)

Читатель, здесь за решёткой продаёться решётки стальные,
- их для дворца свого покупал шлемоблещущий Лутц.

Отлистай на 150+ страниц назад и прочитай про правило применения методов в заивисомти от классов - поскольку
мы используем метод характерный для множеств то и интерпретатор интерпретирует словарь anime как 
представление ключей (или что то в этом духе - там точно было такое правило)

множество пар ключ-значение

>>> anime.items() | {("c", 3), ("d", 4)}
{('c', 3), ('Ghost', 2), ('Major', 1), ('Complex', 501), ('d', 4)}
>>> 

функция dict как участник этого безобразия - обрати внимание на скобки (!)

>>> Heresy = dict(anime.items() | {("c", 3), ("d", 4)})
>>> Heresy
{'Major': 1, 'c': 3, 'Ghost': 2, 'Complex': 501, 'd': 4}
>>> 

# Метод сортировки словарей по Лутцу.

>>> Heresy = dict(Major = "ghost", Bato = "boevik", Gato = "enemy", unit = 501, story = 404)
>>> Ks = Heresy.keys()
>>> Ks = list(Ks)
>>> for x in Ks: print(x, Heresy[x])
story 404
unit 501
Gato enemy
Bato boevik
Major ghost
>>>

Естественным образом нам в реальности нужен collections.OrderedDict() в более свежих версиях, но Лутц вещает

>>> Heresy = dict(Major = "ghost", Bato = "boevik", Gato = "enemy", unit = 501, story = 404)
>>> for x in sorted(Heresy): print(x, Heresy[x])
Bato boevik
Gato enemy
Major ghost
story 404
unit 501
>>> 

# sorted() принимает итерируемые объекты и возвращает красивый результат, возвращает то он конечно возвращает,
но для сортировки словаря по позициями нам всё равно потребуется import collections

# Сравнение ключей различных словарей

sorted(D1.items()) < sorted(D2.items())

# метод проверки ключей

>>> Heresy = dict(Major = "ghost", Bato = "boevik", Gato = "enemy", unit = 501, story = 404)
>>> if "c" in Heresy: print("present", Heresy["c"])
... else:
...     print("no")
no
>>>

>>> Heresy = dict(Major = "ghost", Bato = "boevik", Gato = "enemy", unit = 501, story = 404)
>>> print(Heresy.get("c"))                      
None
>>> print(Heresy.get("Major"))                   
ghost
>>> print(Heresy.get("ghost"))                  
None
>>> if Heresy.get("c") != None: print("present", Heresy["c"])
... else:
...     print("Lets go to nect chapter of this book")
Lets go to nect chapter of this book
>>>  

с 284



















 