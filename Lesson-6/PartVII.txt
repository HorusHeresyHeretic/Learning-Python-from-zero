# Метод форматирования строк, основы

Новый метод format объектов строк, появившийся в версиях 2.6 и 3.0 (и выше), использует строку, относительно
которой он вызывается, как шаблон и принимает произвольное количество аргументов, представляющих значения
для подстановки.

Фигурные скобки внутри строки шаблона используются для обозначения замещаемых спецификаторов и их параметров,
которые могут определять порядковые номера позиционных аргументов (например, {1}) или имена именованных 
аргументов (например, {food}).

Порядковые номера позиционных аргументов

>>> anime = "{0}, {1} and {2}"
>>> anime.format ("stand", "alone", "complex")     
'stand, alone and complex'
>>> anime = "{0}, {2} and {1}"
>>> anime.format ("stand", "alone", "complex")     
'stand, complex and alone'
>>> 

Имена именованных аргументов

>>> anime = "{stand}, {alone} and {complex}"
>>> anime.format (stand = "ghost", alone = "in the", complex = "shell")  
'ghost, in the and shell'

Оба варианта.

>>> anime = "{stand}, {alone} and {complex}, {1}, {0}"
>>> anime.format ("anime", "story", stand = "ghost", alone = "in the", complex = "shell")
'ghost, in the and shell, story, anime'

Нотация: 

anime = "{str1}, {str2}, {str3}, {1},{0}
anime.format ("0", "1", str1 = "str", str2 = "str", str3 = "str")

При использование порядковых номеров позиционных аргументов в выражении метода форматирования строк, их
значения задаються в скобках () после .format перед значениями строк, которые мы форматируем, пример

anime = "{str1} ,{str2} , {3}, {1}, {str3}, {2}, {0}"
anime.format ("0", "1", "2", "3", "4", str1 = 'str"...) 

Естественно, строка шаблона также может быть литералом, кроме того, сохраняется возможность подстановки
значений объектов любых типов:

>>> "{stand}, {1}, {alone}, {complex}, {0}".format ("anime", "story", stand = 501, alone = [1,2], complex = {"Ghost":"Major","Bato":"Major Friend","11":"Crazy Major Friends","Godo":"Evil Enemy"})
"501, story, [1, 2], {'11': 'Crazy Major Friends', 'Godo': 'Evil Enemy', 'Ghost': 'Major', 'Bato': 'Major Friend'}, anime"

Как и при использовании оператора форматирования % и других строковых методов, метод format создает и 
возвращает новый объект строки, который можно тут же вывести на экран или сохранить для последующего 
использования (не забывайте, что строки являются неизменяемыми объектами, поэтому метод format
вынужден создавать новый объект). Возможность форматирования строк может использоваться не
только для их отображения:

>>> Major = "{stand}, {1}, {alone}, {complex}, {0}".format ("anime", "story", stand = 501, alone = [1,2], complex = {"Ghost":"Major"})
>>> Major                                         
"501, story, [1, 2], {'Ghost': 'Major'}, anime"
>>> Major.split("[1, 2]")                         
['501, story, ', ", {'Ghost': 'Major'}, anime"]
>>> anime = Major.replace("501", "Stand alone complex")    
>>> anime
"Stand alone complex, story, [1, 2], {'Ghost': 'Major'}, anime"

# Использование ключей, атрибутов и смещений

Как и оператор форматирования %, метод format обладает дополнительными возможностями. Например, в строках
формата допускается ссылаться на имена атрибутов объектов и ключи словарей, – как и в привычном синтаксисе
языка Python, квадратные скобки обозначают ключи словаря, а точка применяется для организации доступа к
атрибутам объектов, на которые ссылаются позиционные или именованные спецификаторы. 

В первом примере ниже демонстрируется подстановка значения ключа «spam» словаря и значения атрибута
 «platform» объекта импортированного модуля sys, которые передаются как позиционные аргументы.
 
>>> import sys
>>> "My {1[spam]} runs {0.platform}".format(sys, {"spam": "laptop"})
'My laptop runs win32'  
 
 Во втором примере делается то же самое, но на этот раз объекты для подстановки передаются в виде
 именованных аргументов:

>>> "My {config[spam]} runs {sys.platform}".format(sys=sys, config = {"spam": "laptop"})
'My laptop runs win32'
>>> 

В квадратных скобках в строках формата можно также указывать смещение от начала списка (или любой другой 
последовательности), но при этом допускается использовать только положительные смещения, поэтому данная
возможность не является достаточно универсальной, как можно было бы подумать.

Как и в операторе %, чтобы обратиться по отрицательному смещению, получить срез или вставить результат
произвольного выражения, данные для подстановки должны быть подготовлены отдельными выражениями,
за пределами строки формата:

>>> animelist = list("Ghost in the shell")        
>>> animelist 
['G', 'h', 'o', 's', 't', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 's', 'h', 'e', 'l', 'l']
>>> "first = {0[0]}, second = {0[1]}".format(animelist)
'first = G, second = h'
>>> "first={0}, last={1}".format(animelist[0], animelist[-1])
'first=G, last=l'
>>> parts = animelist[0], animelist[-1], animelist[1:3]
>>> "first={0}, last={1}, middle={2}".format(*parts)
"first=G, last=l, middle=['h', 'o']"

(!) это годнота - поэксперементируй с ней.

>>> anime = list("Stand alone complex")
>>> story = "anime1 = {0[0]}, anime2= {0[1]}, anime3 = {0[2]}".format(anime)
>>> story                                        
'anime1 = S, anime2= t, anime3 = a'

>>> anime = list("Stand alone complex")
>>> ghost = "anime1 = {0}, anime-1 = {1}".format(anime[0], anime[-1])
>>> ghost                                         
'anime1 = S, anime-1 = x'

>>> anime = list("Stand alone complex")           
>>> Major = anime[0], anime[-1], anime[0:5]       
>>> Bato = "anime1 = {0}, anime2 = {1}, anime3 = {2}".format(*Major)    
>>> Bato
"anime1 = S, anime2 = x, anime3 = ['S', 't', 'a', 'n', 'd']"
>>> 

(!) Большую ценность имеет совет Лутца готовить данные отдельным выражением за пределом строки .format.
Команда .format(*переменная) достаточно мощный инструмент, который по всей видимости позволяет класть
внутрь форматируемой строки данные из внешних источников через переменную, с которй они связаны.

бла бла бла.format(*переменная) где переменная - внешний источник данных в какой нибудь таблице.

# Специальные приемы форматирования

Еще одно сходство с оператором форматирования % состоит в том, что за счет использования дополнительных 
синтаксических конструкций форматирования имеется возможность выполнять более точное форматирование.
Вслед за идентификатором символа подстановки, через двоеточие, можно указать спецификатор формата,
определяющий ширину поля вывода, выравнивание и код типа значения. Ниже приводится формальный 
синтаксис спецификатора формата:

{fieldname!conversionflag:formatspec}

Поля спецификатора имеют следующий смысл:

• fieldname – порядковый номер или имя именованного аргумента, за которым может следовать необязательное имя
 «.name» атрибута или индекс «[index]» элемента.

• conversionflag – может быть r, s или a, которые определяют применение к значению встроенной функции repr,
 str или ascii соответственно.

• formatspec – определяет способ представления значения, описывает такие характеристики представления, как 
ширина поля вывода, выравнивание, дополнение, количество знаков после десятичной точки и так далее, и за-
вершается необязательным кодом типа значения.

Поле formatspec, следующее за двоеточием, в общем виде имеет следующий синтаксис (квадратные скобки окружают
необязательные компоненты и не имеют отношения к синтаксису поля):

[[fill]align][sign][#][0][width][.precision][typecode]


В поле align может указываться символ <, >, = или ^, обозначающий выравнивание по левому или по правому краю,
дополнение после символа знака числа или выравнивание по центру соответственно.

Спецификатор формата formatspec может также содержать вложенные {} строки форматирования с именами полей,
чтобы извлекать значения из списка аргументов динамически (практически так же, как символ * в операторе
форматирования).

Полный список допустимых кодов практически полностью совпадает со списком спецификаторов, используемых в 
операторе форматирования % . Дополнительно метод format позволяет использовать код типа «b» для
отображения целых чисел в двоичном формате (эквивалент вызову встроенной функции bin).

Кроме того, код типа «%» используется для отображения символа процента, а для ото бражения десятичных целых
чисел допускается использовать только код «d» (коды «i» и «u» считаются недопустимыми).

В следующем примере спецификатор {0:10} предписывает вывести значение первого позиционного аргумента в поле
шириной 10 символов.

>>> "{0:10} = {1:10}".format("Ghost", 123.456)   
'Ghost      =    123.456'

Спецификатор {1:<10} предписывает вывести значение второго позиционного аргумента в поле шириной 10 символов,
с выравниванием по левому краю.

>>> "{0:<10} = {1:<10}".format("Ghost", 123.456)
'Ghost      = 123.456   '
>>> 

Спецификатор {0.platform:>10} предписывает вывести значение атрибута platform первого позиционного аргумента
в поле шириной 10 символов, с выравниванием по правому краю:

>>> import sys
>>> "{0.platform:>10} = {1[item]:<10}".format(sys, dict(item="laptop"))
'     win32 = laptop    '
>>> 

# О чём вообще вещает Лутц, если на дворе 24.05.2017. ты уже полгода учисшься кодить и чувствуешь себя тупым,
потому что за это время осилил только ШАпошникова, 240 страниц ЛУтца и около 50 страниц в интернете по языку.

>>> "{0:10} = {1:10}".format("Ghost", 123.456)
'Ghost      =    123.456'
>>> "{0:5} = {1:10}".format("Ghost", 123.456)
'Ghost =    123.456'
>>> "{0:5} = {1:5}".format("Ghost", 123.456)
'Ghost = 123.456'
>>> "{0:3} = {1:5}".format("Ghost", 123.456)
'Ghost = 123.456'
>>> 

>>> "{0:10} = {2:10}".format("Ghost", 123.456, 501.11)
'Ghost      =     501.11'
>>> "{0:10} = {0:10}".format("Ghost", 123.456, 501.11)
'Ghost      = Ghost     '
>>> 
>>> "{0:10} = {0:3}".format("Ghost", 123.456, 501.11)
'Ghost      = Ghost'
>>> "{1:10} = {0:3}".format("Ghost", 123.456, 501.11)
'   123.456 = Ghost'
>>> "{2:1} = {0:3}".format("Ghost", 123.456, 501.11)
'501.11 = Ghost'
>>> 


Спецификаторы позволяют задавать поля и формат вывода аргументов + выбирать какие аргументы выводим

"{x1:x2} = {y1:y2}".format("str", int_float, int, "str")

x1 это селекция аргументов в скобках .format(x0,x1,x2,x3) 
х2 это ширина поля в которое мы вовыдим значение аргумента, если заданная ширина поля уже чем значение
аргумента - то Питон автоматически настраивает такую ширину для поля вывода, котора позволит вывести.
y1 это селекция аргументов в скбоках .format(y0,y1,y2,y3)
y2 - тоже что и x2

естественным образом под шириной поля подразумеваеться L - то бишь len().

Кроме того можно задавать дополнительные действия, добавляя символы после двоеточия.

# Выравнивание

>>> "{0:<10} = {1:<10}".format("Ghost", 123.456)
'Ghost      = 123.456   '
>>> "{0:>10} = {1:>10}".format("Ghost", 123.456)
'     Ghost =    123.456'
>>> "{0:<10} = {1:>10}".format("Ghost", 123.456)
'Ghost      =    123.456'
>>> "{0:^10} = {1:^10}".format("Ghost", 123.456)
'  Ghost    =  123.456  '
>>> 
  
Кроме того, я наконецто понял как правильно обращаться и обрабатывать данных из других модулей в Питон.

>>> import module1
Ghost Shell Anime
>>> "{0.a:>10} = {1:<10}".format(module1, "Shell")
'     Ghost = Shell 

module1 это

a = "Ghost"
b = "Shell"
c = "Anime"
print(a,b,c)

# Это свет истины детка! форматирование рулит!!!

# Использование атрибутов в спецификаторах.

"{int.name:>int} = {int:int}".format(filename, "str") - предписывает вывести значние атрибута (name) из файла
(filename) и присвоить ему значение "str".

# По Лутцу идея вращается вокруг правила:

{fieldname!conversionflag:formatspec}

• fieldname – порядковый номер или имя именованного аргумента, за которым может следовать необязательное имя
 «.name» атрибута или индекс «[index]» элемента.

• conversionflag – может быть r, s или a, которые определяют применение к значению встроенной функции repr,
 str или ascii соответственно.

 в теории это может выглядить так:

{0.name:10}
{0.[1]:10} 

или так:

{0.module1!r:10}
{0.[11]!s:10}

Так что мы можем работать не только с тем, что сами пишем в скобках, но и с переменными из других файлов и с
индексами этих переменных. 

>>> import module1
Ghost Shell Anime
>>> "{0.a[1]!r:>10} = {1:<10}".format(module1, "Shell")
"       'h' = Shell     "
>>> "{0.b[4]!s:>10} = {1:<10}".format(module1, "Shell")
'         l = Shell     '
>>> "{0.c[4]!a:>10} = {1:<10}".format(module1, "Shell")
"       'e' = Shell     "
>>> 

а conversionflag - поможет нам в дальнейшем работать с получаемыми значениями в программируемом алгоритме.

В свою очередь formatspec – определяет способ представления значения, описывает такие характеристики
представления, как ширина поля вывода, выравнивание, дополнение, количество знаков после десятичной
точки и так далее, и завершается необязательным кодом типа значения.

технически это выглядит так:

{0.name!x:1} где

0 - это fieldname
.name - имя атрибута, переменной, файла
!x - conversionflag (характер вывода или символы указывающие на выравнивание) 
1 - formatspec

(Лутцу нужно поработать над тем как он подаёт этот материал - мне пришлось напрячься что бы всё понять)

# едем дальше (к работе с файлами вернёмся завтра)

Для вывода вещественных чисел метод format поддерживает те же самые коды типов и параметры форматирования, что
и оператор %. Так, в следующем примере спецификатор {2:g} предписывает вывести третий аргумент, отформати-
рованный в соответствии с представлением вещественных чисел по умолчанию, предусмотренным кодом «g». 

>>> "{0:e}, {1:.3e}, {2:g}".format(3.14159, 3.14159, 3.14159)
'3.141590e+00, 3.142e+00, 3.14159'
>>> 

Спецификатор {1:.2f} предписывает использовать формат «f» представления вещественных чисел с двумя знаками
после десятичной точки. Спецификатор {2:06.2f} дополнительно ограничивает ширину поля вывода 6 символами
и предписывает дополнить число нулями слева:

>>> "{0:f}, {1:.2f}, {2:06.2f}".format(3.14159, 3.14159, 3.14159)
'3.141590, 3.14, 003.14'

Метод format поддерживает также возможность вывода чисел в шестнадцатеричном, восьмеричном и двоичном 
представлениях. Фактически строка формата может служить альтернативой использованию некоторых
встроенных функций:

>>> "{0:X}, {1:o}, {2:b}".format(255, 255, 255)
'FF, 377, 11111111'

>>> bin(255), int("11111111", 2), 0b11111111
('0b11111111', 255, 255)

Параметры форматирования можно указывать непосредственно в строке формата или динамически извлекать из списка
аргументов, с помощью синтаксиса вложенных конструкций, практически так же, как с помощью символа звездочки в
операторе форматирования %:

>>> "{0:.2f}".format(1 / 3.0)
'0.33'
>>> "{000:.11f}".format(1 / 7.0)
'0.14285714286'

>>> "%.2f" % (1 / 3.0)
'0.33'
>>> "%.11f" % (1 / 3.0)
'0.33333333333'
>>> 

# .{1}f - равнозначно *f

# а вообще смотри понятный пример, который всё объясняет:

>>> "{0:.{3}f}".format(1 / 3.0, 4, 10, 11)
'0.33333333333'
>>> "{0:.{2}f}".format(1 / 3.0, 4, 10, 11)
'0.3333333333'
>>> 

.{x}f - указывает характер вывода ( на то это и formatspec) по аргументу в скобках, х - номер аргумента с 0.

Наконец, в Python 2.6 и 3.0 появилась новая встроенная функция format, которая может использоваться для 
форматирования одиночных значений. Она может рассматриваться как более компактная альтернатива методу
format и напоминает способ форматирования единственного значения с помощью оператора %: 

>>> "{0:.2f}".format(1.2345)           
'1.23'
>>> format(1.2345, ".2f")          # новая фукнция   
'1.23'
>>> "%.2f" % 1.2345
'1.23'
>>> 

С технической точки зрения, встроенная функция format вызывает метод __format__ объекта, который в свою очередь
вызывает метод str.format каждого форматируемого элемента. Однако эта функция имеет не такой компактный 
синтаксис, как оригинальный оператор %, что ведет нас к следующему разделу.

# Дзен, import и все все все.

Если ты написал класс и сунул его в модуль, а потом захотел импортировать аргументы в другой модуль - знай(!)

>>> import anime
>>> anime.FirstGame.date
'01.01.2017'
>>> anime.FirstGame.hostTeam
'AnimeTeam'
>>> anime.FirstGame.guestTeam
'EvilTeam'
>>> anime.FirstGame.hostGoals
'100500'
>>> anime.FirstGame.guestgoals
'0'
>>> anime.FirstGame.hostteammembers
'Ghost in the shell characters'
>>> anime.FirstGame.questteammembers
'Random Evil characters'
>>> anime.NextGame.hostGoals
'0'
>>> a = anime.FirstGame.date
>>> b = anime.FirstGame.questteammembers
>>> print(a, b)

import filename
filename.atriburename.methodname

(если конечно я не перепутал атрибуты и методы местами)

# Сравнение метода format с оператором форматирования %

В общем случае применение оператора форматирования выглядит проще, чем вызов метода format, особенно при
использовании универсального спецификатора формата %s

# выражение форматирования

>>> print("%s=%s" % ("Ghost in the shell", 501))
Ghost in the shell=501
>>> 

# метод format

>>> print("{0} = {1}".format("Ghost in the shell", 501))
Ghost in the shell = 501
>>> 

В более сложных случаях оба способа имеют почти одинаковую сложность (сложные задачи обычно сложны сами по 
себе, независимо от используемого подхода), поэтому некоторые считают format в значительной степени
избыточным.

(я бы не сказал, как по мне так format лучше в переборе аргументов внутри скобок, но выражение % проще)

С другой стороны, метод format предлагает дополнительные потенциальные преимущества. Например, оператор % не
позволяет использовать именованные аргументы, ссылки на атрибуты и выводить числа в двоичном представлении,
хотя возможность использования словарей в операторе % помогает добиться тех же целей.

(здесь и далее Лутц вещает как решать задачи из предыдущего раздела с помощью выражения форматирования)

# Основы: с оператором % вместо метода format()

>>> anime = "%s, %s, %s"                             # %s - (s) тип объектов, строки.
>>> anime % ("Stand", "Alone", "Complex")            # в скобках позиционные параметры
'Stand, Alone, Complex'
>>> print(anime)                                     # %s, %s, %s
%s, %s, %s

>>> anime = "Major %s, Major %s, Major %s"           # %s - (s) тип объектов, строки.
>>> anime % ("Stand", "Alone", "Complex")            # в скобках позиционные параметры
'Major Stand, Major Alone, Major Complex'
>>> print(anime)
Major %s, Major %s, Major %s
>>> 

>>> anime = "Major %s, Major %s, Major %s" % ("Stand", "Alone", "Complex")
>>> anime
'Major Stand, Major Alone, Major Complex'

>>> somelist = list("SPAM")
>>> parts = somelist[0], somelist[-1], somelist[1:3]
>>> "first=%s, last=%s, middle=%s" % parts
"first=S, last=M, middle=['P', 'A']"
>>> 

Когда требуется добиться более сложного форматирования, эти два подхода становятся почти равными в смысле 
сложности, хотя, если сравнить следующие примеры использования оператора % с аналогичными примерами 
использования метода format, представленными выше, опять можно заметить, что оператор % выглядит
несколько проще и компактнее:

# Специальные приемы форматирования

>>> "%-10s = %10s" % ("spam", 123.4567)
'spam       =   123.4567'
>>> "%10s = %-10s" % ("spam", 123.4567)
'      spam = 123.4567  '
>>>

>>> import sys
>>> "%(plat)10s = %(item)-10s" % dict(plat=sys.platform, item="laptop")
'     win32 = laptop    '
>>> 

# Вещественные числа

>>> "%e, %.3e, %g" % (3.14159, 3.14159, 3.14159)
'3.141590e+00, 3.142e+00, 3.14159'
>>> "%f, %.2f, %06.2f" % (3.14159, 3.14159, 3.14159)
'3.141590, 3.14, 003.14'
>>> 

# Числа в шестнадцатеричном и восьмеричном представлениях, но не в двоичном

>>> "%x, %o" % (255, 255)
'ff, 377'
>>> 

Метод format имеет ряд дополнительных особенностей, которые не поддерживаются оператором %, но даже когда
требуется реализовать еще более сложное форматирование, оба подхода выглядят примерно одинаковыми в 
смысле сложности. Например, ниже демонстрируются два подхода к достижению одинаковых результатов – 
при использовании параметров, определяющих ширину полей и выравнивание, а также различных 
способов обращения к атрибутам: 

# В обоих случаях фактические значения определяются непосредственно в операции (одна фигня)

>>> import sys
>>> "My {1[spam]:<8} runs {0.platform:>8}".format(sys, {"spam": "laptop"})  
'My laptop   runs    win32'
>>> "My %(spam)-8s runs %(plat)8s" % dict(spam="laptop", plat=sys.platform)
'My laptop   runs    win32'
>>> 

На практике фактические значения редко определяются непосредственно в операции форматирования, как здесь. Чаще
эти значения вычисляются заранее (например, чтобы затем подставить их все сразу в шаблон разметки HTML). Когда
мы начинаем учитывать общепринятую практику в своих примерах, сравнение метода format и оператора % становится
еще более наглядным (как вы узнаете в главе 18, аргумент **data в вызове метода – это специальный синтаксис
распаковывания ключей и значений словарей в отдельные пары «name= value» именованных аргументов, благодаря
чему появляется возможность обращаться к ним по именам в строке формата):

Дзен зависит от тебя, формат немного более понятен - хоть и мение компактен.

# Хинт.

Возможность указывать символ-разделитель разрядов в десятичных числах, что позволит вставлять запятые между
трехзначными группами цифр.

>>> "{0:d}".format(999999999999)
'999999999999'
>>> "{0:,d}".format(999999999999)
'999,999,999,999'
>>> 

Кроме того имеется возможность не указывать явно порядковые номера позиционных аргументов. В этом случае
аргументы из списка будут выбираться последовательно, однако использование этой особенности может свести
к нулю основное преимущество метода format, как это описывается в следующем разделе

>>> "{:,d} {:,d}".format(9999999, 8888888)
'9,999,999 8,888,888'
>>> "{:,.2f}".format(296999.2567)
'296,999.26'

# А вообще - читай 24 главу.

# Автоматическая нумерация.

Использование возможности автоматической нумерации в версии 3.1, как в данном примере, снижает преимущества
метода format. А если сравнить операции форматирования, например, вещественных чисел, можно заметить, что
выражение с оператором % по-прежнему получается более компактным и вы-лядит менее запутанным:

>>> "{0:f}, {1:.2f}, {2:05.2f}".format(3.14159, 3.14159, 3.14159)
'3.141590, 3.14, 03.14'
>>> "{:f}, {:.2f}, {:06.2f}".format(3.14159, 3.14159, 3.14159)
'3.141590, 3.14, 003.14'
>>> "%f, %.2f, %06.2f" % (3.14159, 3.14159, 3.14159)
'3.141590, 3.14, 003.14'

# Срыв покровов - реальная и принципиальная разница метода и выражения

При использовании оператора форматирования % единственное значение можно указать непосредственно, но когда 
необходимо передать несколько значений, они должны быть заключены в кортеж:

>>> "%.2f" % 1.2345                               
'1.23'
>>> "%.2f %s" % (1.2345, 99)
'1.23 99'
>>> 

С технической точки зрения, оператор форматирования принимает один объект – либо само значение для подстановки,
либо кортеж с одним или более элементами. Фактически из-за того, что единственный элемент может передаваться 
либо сам по себе, либо внутри кортежа, когда возникает необходимость отформатировать кортеж, он должен быть
оформлен, как вложенный кортеж:

>>> "%s" % 1.23                                    
'1.23'
>>> "%s" % (1.23,)                                 
'1.23'
>>> "%s" % ((1.23,),)
'(1.23,)'

Метод format, напротив, ликвидирует различия между этими двумя случаями, принимая одни и те же аргументы:

>>> "{0:.2f}".format(1.2345)                       
'1.23'
>>> "{0:.2f} {1}".format(1.2345, 99)
'1.23 99'
>>> 

>>> "{0}".format(1.23)                             
'1.23'
>>> "{0}".format((1.23,))
'(1.23,)'
>>> 

Из всего вышесказанного можно сделать вывод, что метод format удобнее для начинающих программистов и меньше
способствует появлению ошибок программирования. Однако эту проблему нельзя признать существенной – если (!)
всегда заключать значения в кортеж и не пользоваться возможностью прямой передачи единственного значения,
оператор % по сути становится похожим на метод format. 

# лично я начинающий программист и мне нравиться метод .format

# Учитывая, что оператор форматирования широко использовался на протяжении всей истории развития Python, пока 
не ясно, насколько оправданно переводить существующий программный код на использование нового инструмента, о 
чем мы поговорим в следующем разделе. (смысл проблемы ясен - новые кодеры используют .format - старые % )

# Короче - пишем как умеем .format кмк лучше.