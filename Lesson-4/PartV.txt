С этим артефактом связан файл PyPartV.py

глава 5. Числа.

# Базовые числовые типы

• Целые и вещественные числа

• Комплексные числа

• Числа фиксированной точности

• Рациональные числа

• Множества

• Логические значения

• Целые числа неограниченной точности

• Различные встроенные функции и модули для работы с числами

Язык Python поддерживает обычные числовые типы (целые и вещественные), а также литералы – для их 
создания, и выражения – для их обработки. Помимо базовых типов данных язык Python предоставляет
самые обычные числовые типы: целые числа (положительные и отрицательные) и вещественные числа
(с дробной частью), которые иногда называют числами с плавающей точкой. Язык Python позволяет
записывать целые числа в виде шестнадцатеричных, восьмеричных и двоичных литералов.
Поддерживает комплексные числа и обеспечивает неограниченную точность представления
целых чисел (количество цифр в целых числах ограничивается лишь объемом доступной
памяти).

1234, -24, 0, 9999999999999999999 - Обычные целые числа (с неограниченной точностью представления)
0o177, 0x9ff, 0b101010 - Восьмеричные, шестнадцатеричные и двоичные литералы целых чисел
1.23, 1., 3.14e-10, 4E210, 4.0e+210 - Вещественные числа
3+4j, 3.0+4.0j, 3J - Литералы комплексных чисел

# Литералы целых и вещественных чисел

Целые числа записываются как строки, состоящие из десятичных цифр. Вещественные числа могут содержать
символ десятичной точки и/или необязательную экспоненту со знаком, которая начинается с символа e 
или E.Если в записи числа обнаруживается точка или экспонента, интерпретатор Python создает 
объект вещественного числа и использует вещественную (не целочисленную) математику, когда
такой объект участвует в выражении.

# Целые числа в Python 3.0: один тип

В Python 2.6 имеется два типа целых чисел: обычные (32-битные) и длинные (неограниченной точности).
Если числовой литерал заканчивается символом l или L, он рассматривается интерпретатором как 
длинное целоечисло. Целые числа автоматически преобразуются в длинные целые, если их значения
не умещаются в отведенные 32 бита, поэтому вам не требуется вводить символ L – интерпретатор
автоматически выполнит необходимые преобразования, когда потребуется увеличить точность
представления.

В Python 3.0 обычные и длинные целые числа были объединены в один тип целых чисел, который
автоматически поддерживает неограниченную точность, как длинные целые в Python 2.6. Для
большинства программ это изменение в языке никак не скажется на их работоспособности,
при условии, что они явно не проверяют числа на принадлежность к типу длинных целых,
имеющемуся в версии 2.6.

# Шестнадцатеричные, восьмеричные и двоичные литералы

Целые числа могут записываться как десятичные (по основанию 10), шестнадцатеричные (по основанию 16),
восьмеричные (по основанию 8) и двоичные (по основанию 2). Шестнадцатеричные литералы начинаются с
комбинации символов 0x или 0X, вслед за которыми следуют шестнадцатеричные цифры (0-9 и A-F).
Шестнадцатеричные цифры могут вводиться как в нижнем, так и в верхнем регистре.

Литералы восьмеричных чисел начинаются с комбинации символов 0o или 0O (ноль и следующий за ним
символ «o»в верхнем или нижнем регистре), вслед за которыми следуют восьмеричные цифры (0-7).
Двоичные литералы впервые появились в версиях 2.6 и 3.0, они начинаются с комбинации
символов 0b или 0B, вслед за которыми следуют двоичные цифры (0 – 1)

Примечательно, что все эти литералы создают объекты целых чисел – они являются всего лишь
альтернативными формами записи значений. Для преобразования целого числа в строку с
представлением в любой из трех систем счисления можно использовать встроенные
функции hex(I), oct(I) и bin(I), кроме того, с помощью функции int(str, base)
можно преобразовать строку в целое число с учетом указанного основания
системы счисления.

# Комплексные числа

Литералы комплексных чисел в языке Python записываются в формате: 

действительная_часть+мнимая_часть, где мнимая_часть завершается символом j или J.

С технической точки зрения, действительная_часть является необязательной, поэтому мнимая_часть
может указываться без действительной составляющей. Во внутреннем представлении комплексное
число реализовано в виде двух вещественных чисел, но при работе с числами этого типа
используется математика комплексных чисел. Комплексные числа могут также создаваться
с помощью встроенной функции complex(real, imag).

# Литералы других числовых типов

Cуществуют и другие числовые типы, не включенные в табл. 5.1. Объекты некоторых из этих типов
создаются с помощью функций, объявленных в импортируемых модулях (например, вещественные числа
с фиксированной точностью и рациональные числа), другие имеют свой синтаксис литералов (например,
множества).

# Операторы выражений ( знак + это оператор )

Пожалуй, самой фундаментальной возможностью обработки чисел являются выражения: комбинации чисел
(или других объектов) и операторов, которые возвращают значения при выполнении интерпретатором
Python. Выражения в языке Python записываются с использованием обычной математической нотации
и символов операторов. Например, сложение двух чисел X и Y записывается в виде выражения
X + Y, которое предписывает интерпретатору Python применить оператор + к значениям с
именами X и Y. Результатом выражения X + Y будет другой числовой объект.

# Список операторов (таблица с.157)

yield x Поддержка протокола send в функциях-генераторах

lambda args: expression Создает анонимную функцию

x if y else z Трехместный оператор выбора (значение x вычисляется, только если значение y истинно)

x or y Логическая операция ИЛИ (значение y вычисляется, только если значение x ложно)

x and y Логический оператор И (значение y вычисляется,только если значение x истинно)

not x Логическое отрицание

x in y, x not in y Проверка на вхождение (для итерируемых объектов и множеств)

x is y, x is not y Проверка идентичности объектов

x < y, x <= y, x > y, x >= y x == y, x != y Операторы сравнения, проверка на подмножество и надмножество, Операторы проверки на равенство

x | y Битовая операция ИЛИ, объединение множеств

x ^ y Битовая операция «исключающее ИЛИ» (XOR), симметрическая разность множеств

x & y Битовая операция И, пересечение множеств

x << y, x >> y Сдвиг значения x влево или вправо на y битов

x, + y x – y Сложение, конкатенация Вычитание, разность множеств

x * y x % y x / y, x // y Умножение, повторение Остаток, формат Деление: истинное и с округлением вниз

-x, +x Унарный знак «минус», тождественность

~x Битовая операция НЕ (инверсия)

x ** y Возведение в степень

x[i] Индексация (в последовательностях, отображениях и других объектах)

x[i:j:k] Извлечение среза

x(...) Вызов (функций, классов и других вызываемых объектов)

x.attr Обращение к атрибуту

(...) Кортеж, подвыражение, выражение-генератор

[...] Список, генератор списков

{...} Словарь, множество, генератор словарей и множеств

# Дзен

В таблице операторы расположены в порядке возрастания старшинства: Чем выше приоритет оператора,
тем ниже он находится в таблице и тем раньше он выполняется в смешанных выражениях. Вы можете
навсегда забыть о старшинстве операторов, если будете группировать части выражений с помощью
круглых скобок. Помимо смешивания операторов вы можете также смешивать различные числовые
типы. В выражениях, где участвуют значения различных типов, интерпретатор сначала 
выполняет преобразование типов операндов к типу самого сложного операнда, а потом
применяет математику, специфичную для этого типа.

40 + 3.14 = целое число + вещественное число

Интерпретатор Python ранжирует сложность числовых типов следующим образом: целые числа проще, чем
вещественные числа, которые проще комплексных чисел.Поэтому, когда в выражении участвуют целое
число и вещественное число, то целое число сначала будет преобразовано в вещественное число,
а затем будет выполнена операция из математики вещественных чисел, что дает в результате
вещественное число. Точно так же, когда один из операндов в выражении является
комплексным числом, другой операнд будет преобразован в комплексное число и 
выражение вернет в результате также комплексное число.

Существует возможность принудительного преобразования типов с помощью встроенных функций:
>>> int(3.1415) # Усекает дробную часть вещественного числа, возвращает 3
>>> float(3) # Преобразует целое число в вещественное, возвращает 3.0

# Предупреждение.

Python не выполняет автоматическое преобразование других типов. Например, попытка выполнить
операцию сложения строки и числа приведет к появлению ошибки, если вы вручную не выполните
преобразование типа одного из операндов.

# Предупреждение.

В языке Python существует возможность выполнить перегрузку любого оператора с помощью классов
Python или расширений на языке C для работы с создаваемыми объектами. Например, объекты,
реализованные в виде классов, могут участвовать в операции сложения, индексироваться
с помощью выражения [i] и так далее.

Кроме того, Python сам автоматически перегружает некоторые операторы, чтобы с их помощью можно
было выполнять различные действия, в зависимости от типа встроенных объектов. Например, 
оператор + выполняет операцию сложения, когда применяется к числам, но когда он 
применяется к последовательностям, таким как строки или списки, он выполняет
операцию конкатенации.

В действительности оператор + может выполнять любые действия, когда применяется к объектам,
которые вы определяете с помощью классов.

# Переменные и простые выражения

Переменные – это gпросто имена, создаваемые в языке Python, которые используются для обозначения
информации в программах.

• Переменные создаются с помощью операции присваивания.

• При вычислении выражений имена переменных замещаются их значениями.

• Переменные являются ссылками на объекты и никогда не объявляются за ранее.

• Прежде чем переменная сможет участвовать в выражениях, ей должно быть присвоено значение.

>>> a = 3                           # создание переменной a. значение переменно 3
>>> b = 4                           # создание переменной a. значение переменно 4
>>> a + b, a - b                    # возвращает (7, -1)
(7, -1)
>>> a + 1, a - 1                    # возвращает (4, 2)
(4, 2)
>>> b * 3, b / 3                    # возвращает (12, 1.3333333333333333)
(12, 1.3333333333333333)
>>> a * b, b / a                    # умножение и деление, возвращает (12, 1.3333333333333333)
(12, 1.3333333333333333)
>>> a % 2, b ** 2                   # деление по модулю(остаток), возведение в степень, возвращает 1, 16)
(1, 16)
>>> 2 + 4.0, 2.0 ** b               # смешивание типов, выполняет преобразование, возвращает (6.0, 16.0)
(6.0, 16.0)
>>> 

# Дзен(!)

С технической точки зрения результатами этих инструкций являются кортежи, состоящие из двух значений,
потому что вводимые строки содержат по два выражения, разделенные запятыми.

# Предупреждение

В языке Python от вас не требуется заранее объявлять переменные, но прежде чем их можно будет 
использовать, им должны быть присвоены некоторые значения. На практике это означает, что 
перед тем как к счетчикам можно будет прибавлять некоторые значения, их необходимо
инициализировать нулевым значением; прежде чем к спискам можно будет добавлять
новые элементы, их необходимо инициализировать пустыми списками, и так далее.

Форматирование строк.

>>> num = 1 / 3.0
>>> "%e" % num                      # вывод с использованием выражения форматирования строк: '3.333333e-01'
'3.333333e-01'
>>> "%4.2F" % num                   # альтернативный формат представления вещественных чисил: '0.33'
'0.33'
>>> "{0:4.2F}". format(num)         # метод форматирования строк, возвращает '0.33'
'0.33

# Фукнции repr и str

>>> repr(num)                       # судя по всему в 3.0 одна фигня, вовзаращет  '0.3333333333333333'
'0.3333333333333333'
>>> str(num)                        # судя по всему в 3.0 одна фигня, вовзаращет  '0.3333333333333333'
'0.3333333333333333'

Обе функции преобразуют произвольные объекты в их строковое представление: repr (и функция 
автоматического вывода в интерактивной оболочке) выводит результаты в том виде, в каком они
были бы указаны в программном коде; str (и операция print) обычно выполняет преобразование
значения в более дружественное представление. Некоторые объекты имеют оба варианта 
строкового представления: str – для использования в обычных случаях и repr – для
вывода в расширенном варианте. Эта идея еще всплывет далее, при обсуждении строк
и возможности перегрузки операторов в классах, и тогда вы получите более полное
представление об этих встроенных функциях.

Помимо операции получения строкового представления произвольных объектов имя str так же является
именем типа строковых данных и может вызываться с названием кодировки в качестве аргумента для
преобразования строк байтов в строки Юникода.

# Операции сравнения: простые и составные

# Дзен - смешивание разнотипных операндов допускается, только если оба они принадлежат к числовым
типам.

>>> 2.0 >= 1  # целочисленное число 1 преобразуется в вещественное 1.0 для выполнения сравнения.

Самое интересное, что Python позволяет составлять цепочки из нескольких операторов сравнения, для
выполнения проверки на принадлежность диапазону значений. Цепочка операторов сравнения является,
своего рода, сокращенной формой записи более длинных логических выражений. Проще говоря, Python
позволяет объединить несколько операций сравнения, чтобы реализовать проверку на вхождение в
диапазон значений. Выражение (A < B < C), например, проверяет, входит ли значение B в
диапазон от A до C, и является эквивалентом логическому выражению (A < B and B < C),
но выглядит гораздо понятнее (и короче).

>>> 1 == 2 < 3                      # тоже что и 1 == 2 and 2 < 3 возвращает False, потому что 1 не равно 2
False
>>> 1 == 2 and 2 < 3                # но не тоже самое что и False < 3 (что означает утверждение 0 < 3, которое истинно)
False

Интерпретатор не сравнивает значение False (результат операции 1 == 2) с числом 3 – с технической
точки зрения это соответствовало бы выражению 0 < 3,которое должно было бы вернуть True (как мы
увидим ниже, в этой же главе, True и False – это всего лишь числа 1 и 0, расширенные 
приписанными им свойствами). 

# Дзен, Лутц имеет ввиду сравнение 1 и 0 как True False по отношению к составной операции сравнения.
В теории True = 1, а False = 0 - тогда, в тоерии, операция сранвения имеет вид: False > True что 
равнозначно 0 > 1. Интерпритатор Python разбираеться в этом безумии и знает дзен True < False.

# Деление: классическое, с округлением вниз и истинное.

Оператор / всегда выполняет операцию истинного деления, возвращает вещественный (дробный) результат,
включающий дробную часть, независимо от типов операндов.

Оператор // выполняет деление с округлением вниз, усекая дробную часть и возвращая целочисленный
результат ( целое число, без дробей) ,если оба операнда являются целыми числами, и вещественный 
результат (дробный) – если хотя бы один операнд является вещественным числом.

# Дзен - оператор / не очень тру.

Поведение оператора / в версии 3.0 может отрицательно сказаться на правильной работе большого
числа программ. Судя по всему у кодеров C+ оператор / работает как оператор // в Python.

Благодаря опыту, приобретенному при работе с языком C, многие программисты интуитивно полагаются
на то, что операция деления целых чисел будет выполнена с усечением, и пройдет какое-то время,
прежде чем они научатся пользоваться оператором // в таких случаях.

>>> import math
>>> 5 / -2                          # -2.5 сохранит дробную часть
-2.5
>>> 5 // -2                         # -3 округлит результат вниз
-3
>>> math.trunc(5 / -2)              # -2 вместо округления будет выполнено усечение
-2
>>> 

/ сохраняет дробную часть
// округляет результаты винз с -2.5 до -3
trunc(x) выполняет усечение результата (округление вверх) вместо -2.5 возвращает 2
под веерх\вниз подразумевается интеграл от минус бесконечности до 0 и от нуля до плюс бесконечности.

"округлить вниз" -2.5 значит округли вниз в рамках интеграла в сторону бесконечности т.е ниже 0
"усечение" (округлить вверх) значит усечь результат в рамках интеграла в сторону 0.

доказательство

>>> 5 / 2
2.5
>>> 5 // 2
2
>>> math.trunc(5 / 2)
2
>>> 

"округлить результат 5 // 2" вниз - значит, стремиться к нулю от 2.5 где допустимый шаг интеграла 
- целочисленое число. В тоже время "округлить результат 5 // -2 вниз " - значит стремиться к 
минус бесконечности от нуля, где допустимым шагом является отрицательное целочисленное число
 - в данном случае -3.

(!) Критика 4ого издания.

Похоже что Лутц не силен в математике.

Всё вышеописанное является волным изложнием интегральному модели счсиления, в которой операторы
/ и // отвечают за представление результатов в рамках целочисленных пределов.В основе концепции
интеграл от минус бесконечности до нуля и от нуля до плюс бесконечности. 

-...-3...-2.5...-2....0....2...2.5....3....+

Резульаты деления в этом интеграле представляются операторами / и //по разному.

Оператор / представляет предел			 5 / 2, 5 / -2      # (2.5, -2.5) сохраняет дробную часть
Оператор // представляет предел			 5 // 2, 5 // -2    # (2, -3)	  округляет вниз  (влево)
Оператор math.trunc представляет предел  (5 / -2), (5 / 2)  # (-2, 2)	  округляет вверх (вправо)
Оператор math.floor представляет предел  (5 / 2, 5 / -2)	# (2, -3)	  округляет вниз  (влево)

Непонятно только зачем на 170 странице учебника по языку Python мне пришлось вспоминать ма.анализ
в части интегрального счисления в рамках интерпритации стремления к бесконечности от нуля с целью
усечения объекта в целочисленном пределе.

Дядька ЛУтц? зачем так ломать мозг из-за того что программисты С и программисты Python по разному
понимают оператор /. Я помню интегральное счисление - но я ъочу научиться кодить на языке Python.

# Точность представления целых чисел:Python 3.0 поддерживаются целые числа неограниченной точности.

# Комплексные числа

Комплексные числа состоят из двух вещественных чисел, представляющих действительную и мнимую части,
и в тексте программы отличаются наличием суффикса j, или J после мнимой части. Если действительная
часть не равнанулю, комплексное число записывается как сумма двух частей с помощью символа +.

Например, комплексное число, действительная часть которого равна 2, а мнимая часть – -3, 
записывается как 2 + -3j.

>>> 1 + 1j                          # (1+1j)
(1+1j)
>>> 1j + 1j                         # 2j
2j
>>> 1j * 1j                         # (-1+0j)
(-1+0j)
>>> 2 + 1j * 3                      # (2+3j)
(2+3j)
>>> (2 + 1j) * 3                    # (6+3j)
(6+3j)
>>> 

Rомплексные числа позволяют обращаться к своим частям как к атрибутам, поддерживают все обычные
математические операции и могут обрабатываться с помощью стандартного модуля cmath. (версия
модуля math, предназначенная для работы с комплексными числами). Комплексные числа обычно 
используются в инженерных программах. Поскольку это инструмент повышенной сложности,
ищите подробности в справочном руководстве к языку Python.

# Шестнадцатеричная, восьмеричная и двоичная формы записи чисел.

Функция oct преобразует десятичное число в восьмеричное представление,
функция hex – в шестнадцатеричное,
Функция bin – в двоичное.

>>> oct(404), hex(404), bin(404)
('0o624', '0x194', '0b110010100')
>>> 

Кроме того, существует возможность обратного преобразования – встроенная функция int преобразует
строку цифр в целое число. 

>>> int('0b110010100', 2)           # возвращает 404, что бы работало надо указывать систему счисления (2)
404
>>> int('0o624', 8 )                # возвращает 404, что бы работало надо указывать систему счисления (8)
404
>>> int('0x194', 16)                # возвращает 404, что бы работало надо указывать систему счисления (16)
404
>>> 

# Хинт

Функция eval, с которой мы встретимся далее в книге, интерпретирует строку во входном аргументе
как программный код на языке Python. Поэтому она может воспроизводить похожий эффект. Правда,
обычно она работает заметно медленнее, потому что ей приходится компилировать и выполнять 
строку как часть программы, а это предполагает, что вы должны иметь безграничное доверие
к источнику запускаемой строки, – достаточно грамотный пользователь мог бы подсунуть
вашей программе строку, которая при выполнении в функции eval удалит все файлы на
вашем компьютере!:

>>> eval('64'), eval('0o100'), eval('0x40'), eval('0b1000000')
(64, 64, 64, 64)
>>> 

Целые числа могут быть преобразованы в восьмеричное и шестнад цатеричное представления с помощью
строкового метода форматирования и оператора форматирования строк:

>>> "{0:o}, {1:x}, {2:b}".format(64, 64, 64)
'100, 40, 1000000'
>>> "%o, %x, %X" % (64, 255, 255)
'100, ff, FF'
>>> 

# Предупреждение

>>> 01, 020, 0377
  File "<stdin>", line 1
    01, 020, 0377
     ^
SyntaxError: invalid token
>>> 

В версии 3.0 попытка выполнить код пример приведет к ошибке. Хотя в версии 2.6 такой синтаксис
считается допустимым, не начинайте строки цифр с нуля, если вы не предполагаете использовать
их в качестве восьмеричных литералов.

В версии Python 2.6 такие строки будут восприниматься как числа в восьмеричной системе счисления,
что может не соответствовать вашим ожиданиям – число 010 всегда соответствует десятичному числу 8,
а не десятичному 10 (независимо от того, что вы имели в виду!). Чтобы обеспечить непротиво-
речивость по аналогии с шестнадцатеричной и двоичной формами, восьмеричный формат был
изменен в версии 3.0

 – в версии 3.0 вы должны использовать форму записи 0o010.

>>> 0o1, 0o20, 0o377
(1, 16, 255)
>>> 

# Хинт

С помощью литералов можно создавать целые числа произвольной величины. Например, ниже с помощью
шестнадцатеричного литерала создается целое число, а затем выводится его значение, сначала в
десятичном, затем в восьмеричном и, наконец, в двоичном представлениях:

>>> x = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF
>>> x
5192296858534827628530496329220095
>>> oct(x)
'0o17777777777777777777777777777777777777'
>>> hex(x)
'0xffffffffffffffffffffffffffff'
>>> bin(x)
'0b1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'
>>> 

# Битовые операции.

Python поддерживает большую часть видов числовых выражений, доступных в языке C.

>>> x = 1  # 0001
>>> x << 2 # Сдвиг влево на 2 бита: 0100
4
>>> x | 2  # Побитовое ИЛИ: 0011
3
>>> x & 1  # Побитовое И: 0001
1

В первом выражении двоичное значение 1 (по основанию 2, 0001) сдвигается влево на две позиции, в
результате получается число 4 (0100). В последних двух выражениях выполняются двоичная операция
ИЛИ (0001|0010 = 0011) и двоичная операция И (0001&0001 = 0001). Такого рода операции 
позволяют хранить сразу несколько флагов и других значений в одном целом числе.

# а вообще всё это нафиг не нужно - потому что Питон не С+.

# Встроенные фукнции и модули для работы с числами.

sum - сумма, принимает последовательность чисел,
min/max - могут принимать либо последовательность чисел, либо множество отдельных аргументов.
pow - степень
abs - абсолютное значение числа.
round - округление
format - форматирование 

Несмотря на внешнее сходство получаемых результатов, две последние инструкции имеют существенные
отличия – функция round округляет вещественное число и возвращает вещественное число, тогда как
операции форматирования строк возвращают строку, а не измененное число:

>>> (1 / 5), round(1 / 5, 2), ("%.2f" % (1/ 5))  # возвращает (0.2, 0.2, '0.20')
(0.2, 0.2, '0.20')
>>> (1 / 5), round(1 / 5, 2), ("%.2f" % (1/ 6))  # возвращает (0.2, 0.2, '0.17')
(0.2, 0.2, '0.17')
>>> 

# Дзен

Модули из стандартной библиотеки, такие как math, необходимо импортировать, а встроенные функции,
такие как abs и round, доступны всегда, без выполнения операции импорта. Говоря другими словами,
модули – это внешние компоненты, а встроенные функции постоянно располагаются в пространстве
имен, которое используется интерпретатором Python по умолчанию для поиска имен, используемых
программой. В Python 3.0 это пространство имен соответствует модулю с именем builtin 
В этой книге мы подробнее поговорим о разрешении имен, а пока всякий раз, когда 
слышите слово «модуль», думайте: «импорт».

(я уже знаю это)

Модуль random из стандартной библиотеки также необходимо импортировать. Этот модуль предоставляет
возможность получения случайных вещественных чисел в диапазоне от 0 до 1, случайных целых чисел в
заданном диапазоне, случайного выбора элементов последовательности и многое другое:

>>> import random
>>> random.choice(["Ghost in the Shell", "Stand Alone Complex", "Anime", "Solid State"])
'Solid State'
>>> random.choice(["Ghost in the Shell", "Stand Alone Complex", "Anime", "Solid State"])
'Stand Alone Complex'
>>> 

# Другие числовые типы.
# Хитрый конструктор чисел с фиксированной точностью.

>>> from decimal import Decimal                                                # в introIV 336 не так(!)
>>> data = Decimal("0.1") + Decimal("0.1") + Decimal("0.1") - Decimal("0.4")   # это конструктор: d_D
>>> data + 1                                                                   # Decimal('0.9')
Decimal('0.9')
>>> 

Числа с фиксированной точностью представления создаются вызовом функции конструктора Decimal из
модуля decimal, которому передается строка, содержащая желаемое число знаков после запятой (при
необходимости можно воспользоваться функцией str, чтобы преобразо вать вещественное число в
строку). Когда в выражении участвуют числа с различной точностью представления, Python
автоматически выбирает наибольшую точность для представления результата:

>>> anime = Decimal("0.1") + Decimal("0.101") + Decimal("0.10") - Decimal("0.00004")
>>> print(anime)
0.30096
>>> 

# Настройка параметров точности

>>> import decimal                                                # запуск модуля
>>> decimal.getcontext().prec = 4                                 # точности после запятой - (4)
>>> decimal.Decimal(1) / decimal.Decimal (3)                      # возвращает Decimal('0.3333')
Decimal('0.3333')
>>> 

>>> import decimal
>>> decimal.Decimal(1) / decimal.Decimal (7)                     # возвращает 28 знаков после запятой
Decimal('0.1428571428571428571428571429')
>>> decimal.getcontext().prec = 14
>>> decimal.Decimal(1) / decimal.Decimal (7)                     # возвращает 14 знаков после запятой
Decimal('0.14285714285714')
>>> 

Всё это особенно удобно для финансовых приложений, где в денежных суммах копейки представлены двумя
десятичными знаками. Числа с фиксированной точностью по сути представляют альтернативный способ
округления и форматирования числовых значений, например:

>>> 1999 / 1.33                                                  # разделить 1999 рублей на рубль 33 копейки
1503.0075187969924
>>> import decimal                                               # запускаем модуль
>>> decimal.getcontext().prec = 5                                # ставим точность (5 знаков в результате)
>>> pay = str(decimal.Decimal(1999) / decimal.Decimal (1.33))    # преобразуем результат в строку
>>> pay                                                          # возвращает  '2000.330000'
'1503.0'
>>> 

# Менеджер контекста объектов класса Decimal

В версиях Python имеется возможность временно переопределять точность с помощью инструкции with
менеджера контекста. После выхода за пределы инструкции настройки точности восстанавливаются:

>>> import decimal
>>> decimal.Decimal("1.0") / decimal.Decimal("3.01")
Decimal('0.3322259136212624584717607973')
>>> with decimal.localcontext() as anime:
...     anime.prec = 2
...     decimal.Decimal("1.0") / decimal.Decimal("3.01")
... 
Decimal('0.33')
>>> decimal.Decimal("1.0") / decimal.Decimal("3.01")
Decimal('0.3322259136212624584717607973')
>>> 

# Дзен чисел с фиксированной точностью: Результат выражения должен быть равен нулю, но точность
вычислений страдает из-за недостаточного xисла битов в представлении вещественных чисел:

>>> print(0.1 + 0.1 + 0.1 - 0.3)
5.551115123125783e-17

Однако при использовании чисел с фиксированной точностью результат полу чается точным:

>>> from decimal import Decimal
>>> Decimal("0.1") + Decimal("0.1") + Decimal("0.1") - Decimal("0.3")
Decimal('0.0')
>>> 

Проблему наглядно депонстрирует использование фукнций float и int.

>>> x =  0.1 + 0.1 + 0.1 - 0.3
>>> x
5.551115123125783e-17
>>> int(x)
0
>>> float(x)
5.551115123125783e-17
>>> 

Decimal объекты нужня для работы с числами, которые начинаються с 0: 0.1, 0.2 и т.д

>>> from decimal import Decimal
>>> x = Decimal("0.1") + Decimal("0.1") + Decimal("0.1") - Decimal("0.3")
>>> x
Decimal('0.0')
>>> 

Потому что вещественная арифметика это боль и унижение и ты тоже должен страдать превозмогать!

# Рациональные числа (детектирую костыль заради "не работать с decimal ")

Тип – Fraction, который реализует объекты рациональных чисел. Объекты этого типа в явном виде
хранят числитель и знаменатель рациональной дроби, что позволяет избежать неточности и 
некоторых других ограничений, присущих вещественным числам.

Тип Fraction является своего рода родственником типа Decimal и точно так же может использоваться
для управления точностью представления чисел за счет определения количества десятичных разрядов
и политики округления.

Оба типа используются похожими способами – как и класс Decimal, класс Fraction находится в модуле.
Чтобы создать объект этого типа, необходимо импортировать модуль и вызвать конструктор класса,
передав ему числитель и знаменатель. 

После создания объекты типа Fraction могут использоваться в математических выражениях как обычные
числа:

>>> from fractions import Fraction
>>> x = Fraction(1, 3)                                           # числитель 1 - знаменатель 3
>>> y = Fraction(4 , 6)                                          # Будет упрощено до 2, 3 с помощью функции gcd
>>> x                                                            # Fraction(1, 3)
Fraction(1, 3)
>>> y                                                            # Fraction(2, 3)
Fraction(2, 3)
>>> print(y)                                                     # 2/3
2/3
>>> x + y                                                        # Fraction(1, 1)
Fraction(1, 1)
>>> x - y                                                        # Fraction(-1, 3)
Fraction(-1, 3)
>>> x / y                                                        # Fraction(1, 2)
Fraction(1, 2)
>>> 

Рациональные числа могут создаваться из строк с представлением веществен ных чисел, как и числа
с фиксированной точностью:

>>> from fractions import Fraction
>>> Fraction(".25")
Fraction(1, 4)
>>> Fraction("1.25")
Fraction(5, 4)
>>> Fraction(".25") + Fraction("1.25")
Fraction(3, 2)

# Точность счисления

Оба типа, Fraction и Decimal, предоставляют возможность получить точный результат, хотя и за счет
некоторой потери производительности.Ограничения точности, свойственные вещественным числам,
становятся особенно заметны для значений, которые не могут быть представлены точно, из-за
ограниченного объема памяти, выделяемого для хранения вещественного числа.

Decimal

>>> a = 1 / 3.0
>>> b = 4 / 6.0
>>> a                                    
0.3333333333333333
>>> b                                    
0.6666666666666666
>>> a + b                                
1.0
>>> b - a                                
0.3333333333333333
>>> a * b                                
0.2222222222222222
>>> from decimal import Decimal          
>>> a = Decimal("1.0") / Decimal("3.0")  
>>> a                                    
Decimal('0.3333333333333333333333333333')
>>> b = Decimal("4.0") / Decimal("6.0")  
>>> b                                    
Decimal('0.6666666666666666666666666667')
>>> c = a + b                            
>>> c                                    
Decimal('1.000000000000000000000000000')
>>> x = b - a                            
>>> x                                    
Decimal('0.3333333333333333333333333334')
>>> y = a * b                           
>>> y                                    
Decimal('0.2222222222222222222222222222')
>>> 

Fraction

>>> from fractions import Fraction
>>> x = Fraction(1,3)
>>> y = Fraction(4,6)
>>> x + y                               # Fraction(1, 1)
Fraction(1, 1)
>>> x - y                               # Fraction(-1, 3)
Fraction(-1, 3)
>>> x * y                               # Fraction(2, 9)
Fraction(2, 9)
>>> 

# Как по мне - Decimal более тру.

>>> 0.1 + 0.1 + 0.1 - 0.3               # должен быть получен 0 - близко, но не точно
5.551115123125783e-17
>>> from decimal import Decimal
>>> x = Decimal("0.1") + Decimal("0.1") + Decimal("0.1") - Decimal("0.3")
>>> x
Decimal('0.0')
>>> from fractions import Fraction
>>> x = Fraction(1,10) + Fraction(1,10) + Fraction(1,10) - Fraction(3,10)
>>> x
Fraction(0, 1)
>>> 

Кроме того, использование рациональных чисел и чисел с фиксированной точностью позволяет получить
более понятные и точные результаты, чем использование вещественных чисел (за счет использования
представления в виде рациональной дроби и ограничения точности):

>>> 1 / 3                               # 0.3333333333333333
0.3333333333333333
>>> from fractions import Fraction
>>> Fraction(1,3)
Fraction(1, 3)
>>> import decimal
>>> decimal.getcontext().prec = 2
>>> decimal.Decimal(1) / decimal.Decimal(3)
Decimal('0.33')
>>> 

# Фактически рациональные числа сохраняют точность и автоматически упрощают результат. 

>>> 1000.0 / 1234567890
8.100000073710001e-07
>>> from fractions import Fraction
>>> Fraction(1000, 1234567890)
Fraction(100, 123456789)
>>> 

# Преобразование и смешивание в выражениях значений разных типов. (самое полезное)

Для поддержки преобразования в рациональные числа в объектах вещественных чисел был реализован
метод as_integer_ratio, возвращающий соответствующие числу числитель и знаменатель; объекты
рациональных чисел обладают методом from_float; а функция float теперь может принимать
объекты типа Fraction в качестве аргумента.

>>> (2.5).as_integer_ratio()            # метод объекта типа float, возвращает (5, 2) - тоже самое что и 2,5
(5, 2)
>>> f = 2.5                             # задаём переменную f для инструкции преобразования ниже
>>> from fractions import Fraction
>>> z = Fraction(*f.as_integer_ratio()) # преобразование float > fraction
>>> z                                   # Fraction(5, 2)
Fraction(5, 2)
>>> 

# f - это операнд, для выражения 
(F).as_integer_ratio()
F = х

инструкция преобразования float > fraction следует читать как: перемення z соотвествует выражению
- объект класса рациональное цисло(х) где х = (х).as_interger_ratio()
 
# В выражениях допускается смешивать некоторые типы, при этом иногда, чтобы сохранить точность,
необходимо вручную выполнить преобразование в тип Fraction. Взгляните на следующие примеры:

# (!)

Предупреждение: несмотря на то, что имеется возможность преобразовать ве щественное число в
рациональное, в некоторых случаях это может приводить к потере точности, потому что в своем
первоначальном виде вещественное число может быть неточным. В случае необходимости в
подобных случаях можно ограничить максимальное значение знаменателя:

>>> 4.0 / 3                             # возвращает 1.3333333333333333
1.3333333333333333
>>> (4.0 / 3).as_integer_ratio()        # потеря точности, возвращает (6004799503160661, 4503599627370496)
(6004799503160661, 4503599627370496)
>>> from fractions import Fraction
>>> x = Fraction(1,3)
>>> y = x + Fraction(*(4.0 / 3).as_integer_ratio())
>>> y                                   # Fraction(22517998136852479, 13510798882111488)
Fraction(22517998136852479, 13510798882111488)
>>> y.limit_denominator(10)             # x.limit_denominator(10) - упростить х до ближайщего рац.числа.
Fraction(5, 3)
>>> b = 22517998136852479 / 13510798882111488
>>> b                                   # возвращает 5.3 или близкое к нему 1.6666666666666665
1.6666666666666665
>>> 5.0 / 3                             # нихуя себе потеря точности, возвращает 1.6666666666666667
1.6666666666666667
>>> 

# Множества (вроде было раньше - не помню где)

Множество, неупорядоченная коллекция уникальных и неизменяемых объектов, которая поддерживает
операции, соответствующие математической теории множеств. По определению, каждый элемент 
может присутствовать в множестве в единственном экземпляре независимо от того,
сколько раз он будет добавлен.

(точно читал раньше - это словарь без ключей с ограничениями по изменяемости);>>>
# непонятно только почему всего этого нет в моих файлах, я ведь уже пользовался set.
# окей, давайте ещё раз.

Множества задаются с помощью фукнции set.

>>> set([1,2,3,4,5])                    # задать множество
{1, 2, 3, 4, 5}
>>> set("spam")                         # помимо цифр - можно использовать буквы
{'p', 's', 'a', 'm'}
>>> set("Ghost int he shell [11,501] Stand Alone Complex")  # также возможен полный хаос и ересь Хоруса
{'A', 'S', '1', 'l', 'x', 'p', 's', 'm', 'd', 't', '0', 'n', 'G', 'C', ',', 'o', ']', 'a', 'e', ' ', 'i', '[', 'h', '5'}
>>> 

И весь этот хаос как обычно весело работает через варп(переменную) которая является объектом set.

>>> x = set("Ghost int he shell [11,501] Stand Alone Complex")  # также возможен полный хаос и ересь Хоруса
>>> x
{'A', 'a', 'l', '[', 't', 'h', 'p', 'C', 'o', 'S', '5', '1', 'd', 'e', 'n', ',', ']', 'i', 'm', 'G', 's', 'x', '0', ' '}
>>> type(x)
<class 'set'>
>>> 

# (!) главное помнить, что при создании множества set будет ругаться до тех пор, пока содержимое
скобок не будет представлять для интерпретатора Python "единый объект" - смотри пример исключения.

>>> x = set("Ghost int he shell", [11,501], "Stand Alone Complex")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: set expected at most 1 arguments, got 3
>>> 

Поскольку тип set является коллекцией других объектов, он обладает неко торыми особенностями,
присущими таким объектам, как списки и словари: Например, множества поддерживают итерации,
могут изменяться в размерах при необходимости и могут содержать объекты разных типов.

Поскольку множества являются неупорядоченными коллекциями и не отображают ключи на значения,
они не могут быть отнесены ни к последовательностям, ни к отображениям.

>>> x = set("abcde")
>>> y = set("bdxyz")
>>> x                                   
{'d', 'a', 'e', 'c', 'b'}
>>> y                                   
{'d', 'y', 'z', 'b', 'x'}
>>> 

Обратно функция возвращает объект множества, который содержит все элементы объекта, переданного
функции (примечательно, что множества не предусматривают возможность определения позиций
элементов, а, кроме того, они не являются последовательностями).

Множества, созданные таким способом, поддерживают обычные математические операции над множествами
посредством операторов. Обратите внимание: эти операции не могут выполняться над простыми
последовательностями – чтобы использовать их, нам требуется создать из них множества.

>>> x = set("abcde")
>>> y = set("bdxyz")
>>> x                                   # {'c', 'e', 'a', 'd', 'b'}
{'e', 'c', 'b', 'd', 'a'}
>>> y                                   # {'z', 'y', 'd', 'x', 'b'}
{'z', 'x', 'd', 'b', 'y'}
>>> "e" in x                            # проверка вхождения в множесто, возвращает True
True
>>> "e" in y                            # проверка вхождения в множесто, возвращает False
False
>>> x - y                               # разница множеств - возвращает {'a', 'e', 'c'}
{'e', 'c', 'a'}
>>> x | y                               # объединение множеств {'y', 'c', 'd', 'b', 'x', 'a', 'e', 'z'}
{'e', 'c', 'z', 'b', 'd', 'y', 'x', 'a'}
>>> x & y                               # пересечение множеств, возвращает {'b', 'd'}
{'b', 'd'}
>>> x ^ y                               # симметрическая разность, возвращает {'y', 'z', 'x', 'e', 'a', 'c'}
{'e', 'c', 'a', 'z', 'x', 'y'}
>>> x > y                               # надмножество, возвращает
False
>>> x < y                               # подмножество, возвращает
False
>>> 

Помимо поддержки операторов выражений, объекты множеств обладают методами, которые реализуют те же
и ряд дополнительных операций и обеспечивают изменение самих множеств, – метод add вставляет новый
элемент в множество, метод update – выполняет объединение, а метод remove удаляет элемент по его
значению (вызовите функцию dir, передав ей любой экземпляр типа set, чтобы получить полный
перечень всех доступных методов). Допустим, что пе ременные x и y сохранили свои значения,
 присвоенные в предыдущем примере интерактивного сеанса:

>>> z = x.intersection(y)               # То же, что и выражение x & y
>>> z                                   # возвращает {'d', 'b'}
{'d', 'b'}
>>> b = x & y                           # всё явное - лучше не явного
>>> b                                   # всё простое - лучше сложного
{'d', 'b'}
>>> z.add("Ghost in the shell")         # добавить один элемент в множество
>>> z                                   # {'b', 'Ghost in the shell', 'd'}
{'Ghost in the shell', 'd', 'b'}
>>> z.update(set("bx"))                 # объединение множеств
>>> z                                   # {'x', 'd', 'b', 'Ghost in the shell'}
{'Ghost in the shell', 'x', 'd', 'b'}
>>> z.update(set(['X', 'Y']))
>>> z                                   # {'X', 'Ghost in the shell', 'x', 'd', 'b', 'Y'}
{'Y', 'Ghost in the shell', 'd', 'b', 'x', 'X'}
>>> z.update(set(['x', 'y']))
>>> z                                   # {'X', 'Ghost in the shell', 'x', 'd', 'b', 'Y', 'y'}
{'Y', 'Ghost in the shell', 'd', 'b', 'y', 'x', 'X'}
>>> z.remove("d")                       # удалить один элемент
>>> z                                   # {'x', 'Ghost in the shell', 'b', 'y', 'Y', 'X'}
{'Y', 'Ghost in the shell', 'b', 'y', 'x', 'X'}
>>> 

Будучи итерируемыми контейнерами, множества могут передаваться функции len, использоваться в циклах
for и в генераторах списков. Однако так как множества являются неупорядоченными коллекциями, они
не поддерживают операции над последовательностями, такие как индексирование и извлечение среза:

>>> for item in z: print(item*3)
YYY
xxx
bbb
Ghost in the shellGhost in the shellGhost in the shell
yyy
XXX
>>> len(z)
6

Наконец, операторы выражений, которые были продемонстрированы выше, обычно применяются к двум
множествам, однако родственные им методы часто способны работать с любыми объектами итерируемых
типов:


>>> anime = set([1,2,3])
>>> anime | set([3,4])                  # возвращает {1, 2, 3, 4}
{1, 2, 3, 4}
>>> anime | [11,501]                    # исключение  unsupported operand type(s) for |: 'set' and 'list'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for |: 'set' and 'list'
>>> 

# сами по себе операторы выражений не умеют работать с объектами отличных от них типов, но (!)
>>> их методы это позволяют принимать любые интерируемые объекты (например объекты типа словарь)

>>> anime = set([1,2,3])
>>> anime | set([3,4])
{1, 2, 3, 4}
>>> anime.union([11,501])              # возвращает  {11, 1, 2, 3, 501}
{11, 1, 2, 3, 501}
>>> anime.union({"Ghost":"Shell"})     # возвращает  {'Ghost', 1, 2, 3}
{1, 2, 3, 'Ghost'}
>>> type(anime)                        # <class 'set'>
<class 'set'>
>>> 

# Литералы множеств

В Python 3.0 сохранилась возможность использовать встроенную функцию set для создания объектов
множеств, но при этом появилась новая форма литералов множеств, в которых используются
фигурные скобки, прежде зарезервированные для литералов словарей.

>>> set([1,2,3,4,5])
{1, 2, 3, 4, 5}
>>> {1,2,3,4,5}
{1, 2, 3, 4, 5}
>>> 

Такой синтаксис приобретает определенный смысл, если рассматривать множества как словари, в которых
ключи не имеют соответствующих им значений. А поскольку множества являются неупорядоченными
коллекциями уникальных и неизменяемых объектов, элементы множеств близко напоминают ключи
словарей.

Сходство становится еще более явным, если учесть, что в версии 3.0 списки ключей в словарях
являются объектами представлений, поддерживающими такие операции над множествами, как 
пересечение и объединение.

Независимо от того, каким способом были созданы множества, в версии 3.0 они отображаются в новой
форме литерала. В версии 3.0 встроенная функция set все еще необходима для создания пустых
множеств и конструирования множеств на основе существующих итерируемых объектов
однако для создания множеств с известным содержимым удобнее использовать
новую форму литералов: нефига не удобнее - set рулит

# операции с множестами

>>> S1 = {1,2,3,4}
>>> S1 & {1,3}                         # объединение {1, 3}
{1, 3}
>>> {11,501} | S1                      # пересечение {1, 2, 3, 4, 501, 11}
{1, 2, 3, 4, 501, 11}
>>> S1                                 # возвращает  {1, 2, 3, 4} - ведь множества неизменяемы (наверху новое)
{1, 2, 3, 4}
>>> S1 - {1,3,4}                       # разность {2}
{2}
>>> S1 > {1,3}                         # надмножество, возвращает True
True
>>> 

Обратите внимание, что конструкция {} по-прежнему создает пустой словарь. Чтобы создать пустое
множество, следует вызвать встроенную функцию set; результат операции вывода пустого
множества выглядит несколько иначе:   

>>> S = set()
>>> type(S)
<class 'set'>
>>> type({})                           # <class 'dict'>
<class 'dict'>
>>> 

(хотя в теории и там и там фигурные скобки и звенящая пустота варпа окружающая богов хаоса)

# Предупреждение (!) Ограничения, связанные с неизменяемостью и фиксированные множества.

Множества – это гибкие и мощные объекты, но они имеют одно ограничение в обеих версиях, 3.0 и 2.6,
о котором следует помнить – из-за особенностей реализации множества могут включать объекты только
неизменяемых (или так называемых «хешируемых») типов. Отсюда следует, что списки и словари не
могут добавляться в множества, однако вы можете использовать кортежи, если появится 
необходимость сохранять составные значения. В операциях над множествами кортежи
сравниваются по своим полным значениям:  (ну - почти не могут, я добавил) 

>>> anime = set()
>>> anime.add(1.23)
>>> anime                              # {1.23}
{1.23}
>>> anime.add([1,2,3,])                # вернёт исключение - unhashable type: 'list' (объекты разных классов)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
>>> anime.add({"a":1})                 # вернёт исключение - unhashable type: 'dict' (объекты разных классов)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'dict'
>>> anime.union({"a":1})               # можно обойти через union - вернёт {1.23, 'a'}
{'a', 1.23}
>>> 

>>> type({"a":1})
<class 'dict'>

(ну да - конечно, словори НЕ могут добавляться во множества, у культистов хаоса всё работает)         

# Дзен: сами по себе множества изменямые - а вот объекты внутри них нет, налицо дуализм в модели.

# Хинт

Сами по себе множества являются изменяемыми объектами и потому не могут вкладываться в другие 
множества, однако, если вам потребуется сохранить одно множество внутри другого множества,
создайте множество с помощью встроенной функции frozenset, которая действует точно так же,
как функция set, но создает неизменяемое множество, которое невоз можно изменить и потому
можно встраивать в другие множества.

>>> anime = set("Ghost in the shell")
>>> ghost = frozenset("Stand Alone Complex")
>>> anime.update(ghost)
>>> anime
{'s', 'G', 'x', 'd', 'a', 'S', 't', 'C', 'n', 'A', ' ', 'p', 'o', 'e', 'l', 'i', 'm', 'h'}
>>> 

>>> anime = set("Ghost in the shell")
>>> ghost = frozenset("Stand Alone Complex")
>>> anime.union(ghost)
{'G', 'A', 'o', 'a', 'C', 'S', 'e', 'i', 'l', 'h', 'd', 'm', ' ', 's', 't', 'p', 'x', 'n'}
>>> 

>>> anime = set("Ghost in the shell")
>>> ghost = frozenset("Stand Alone Complex")
>>> anime.add(ghost)
>>> anime
{'n', 'e', 'o', 't', 'i', 'h', 's', 'l', ' ', 'G', frozenset({'n', 'e', 'p', 'o', 't', 'C', 'a', 'x', 'A', 'l', 'm', ' ', 'd', 'S'})}
>>> 

>>> anime = set("Ghost in the shell")
>>> ghost = frozenset("Stand Alone Complex")
>>> shell = anime & ghost
>>> shell
{'l', 't', 'o', ' ', 'n', 'e'}
>>> 

# Генераторы множеств

Генератор множеств выполняет цикл и собирает результаты выражения в каждой итерации – доступ к
значению в текущей итерации обеспечивает переменная цикла. Результатом работы генератора
является новое множество, обладающее всеми особенностями обычного множества:

{x ** 2 for x in[1,2,3,4]}		# возвращает {16, 1, 4, 9}

х - переменная цикла

Цикл, который генерирует значения, находится в этом выражении справа, а выражение, осуществляющее
формирование окончательных значений, – слева (x ** 2). Как и в случае с генераторами списков,
генератор множеств возвращает именно то, что говорит: «Вернуть новое множество, содержащее
квадраты значений X, для каждого X из списка».

{anime ** 3 for anime in[11,404,501]}		# возвращает {65939264, 1331, 125751501}

В генераторах можно также использовать другие виды итерируемых объектов, такие как строки:

{c * 4 for c in "spam"}          # - возвращает {'pppp', 'mmmm', 'aaaa', 'ssss'}

>>> anime = {x * 2 for x in "Stand alone complex"}
>>> anime | {"Ghost"}
{'aa', 'll', 'cc', 'oo', '  ', 'ee', 'Ghost', 'xx', 'mm', 'dd', 'nn', 'tt', 'pp', 'SS'}
>>> anime
{'aa', 'll', 'cc', 'oo', '  ', 'ee', 'xx', 'mm', 'dd', 'nn', 'tt', 'pp', 'SS'}
>>> 

Все генераторы, включая генераторы множеств, поддерживают дополнительный синтаксис, например
вложенные циклы и услов ные инструкции if.

>>> anime = {x * 2 for x in "Stand alone complex"}
>>> shell = anime | {"Ghost"}
>>> anime
{'pp', 'xx', '  ', 'll', 'ee', 'tt', 'aa', 'cc', 'SS', 'dd', 'nn', 'mm', 'oo'}
>>> shell
{'pp', 'xx', '  ', 'll', 'ee', 'tt', 'Ghost', 'aa', 'cc', 'SS', 'dd', 'nn', 'mm', 'oo'}
>>> if anime == shell:
...     print("Yes")
... else:
...     print("no")
no
>>> 

>>> anime = {x * 2 for x in "Stand alone complex"}
>>> shell = anime | {"Ghost"}
>>> anime
{'dd', 'cc', 'nn', 'aa', 'mm', 'ee', 'SS', 'tt', 'pp', 'll', 'oo', 'xx', '  '}
>>> shell
{'dd', 'cc', 'nn', 'aa', 'mm', 'ee', 'SS', 'tt', 'pp', 'll', 'Ghost', 'oo', 'xx', '  '}
>>> i = 0
>>> while i < 10:
...     print(anime)
...     i = i + 1
...     if i == 10:
...         print(shell)
{'dd', 'cc', 'nn', 'aa', 'mm', 'ee', 'SS', 'tt', 'pp', 'll', 'oo', 'xx', '  '}
{'dd', 'cc', 'nn', 'aa', 'mm', 'ee', 'SS', 'tt', 'pp', 'll', 'oo', 'xx', '  '}
{'dd', 'cc', 'nn', 'aa', 'mm', 'ee', 'SS', 'tt', 'pp', 'll', 'oo', 'xx', '  '}
{'dd', 'cc', 'nn', 'aa', 'mm', 'ee', 'SS', 'tt', 'pp', 'll', 'oo', 'xx', '  '}
{'dd', 'cc', 'nn', 'aa', 'mm', 'ee', 'SS', 'tt', 'pp', 'll', 'oo', 'xx', '  '}
{'dd', 'cc', 'nn', 'aa', 'mm', 'ee', 'SS', 'tt', 'pp', 'll', 'oo', 'xx', '  '}
{'dd', 'cc', 'nn', 'aa', 'mm', 'ee', 'SS', 'tt', 'pp', 'll', 'oo', 'xx', '  '}
{'dd', 'cc', 'nn', 'aa', 'mm', 'ee', 'SS', 'tt', 'pp', 'll', 'oo', 'xx', '  '}
{'dd', 'cc', 'nn', 'aa', 'mm', 'ee', 'SS', 'tt', 'pp', 'll', 'oo', 'xx', '  '}
{'dd', 'cc', 'nn', 'aa', 'mm', 'ee', 'SS', 'tt', 'pp', 'll', 'oo', 'xx', '  '}
{'dd', 'cc', 'nn', 'aa', 'mm', 'ee', 'SS', 'tt', 'pp', 'll', 'Ghost', 'oo', 'xx', '  '}
>>> 

Поскольку элементы множеств являются уникальными, множества можно использовать для фильтрации
повторяющихся значений в других коллекциях. Для этого достаточно просто преобразовать 
коллекцию в множество, а затем выполнить обратное преобразование (благодаря тому, 
что множства являются итерируемыми объектами, их можно передавать функции list):

>>> anime = [1,2,3,4,2,1,5]
>>> set(anime)                       # возвращает множество {1, 2, 3, 4, 5}
{1, 2, 3, 4, 5}
>>> anime = list(set(anime))
>>> anime                            # возвращает список [1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
>>> 

(!) годнотва в главах 24 и 30

Множества могут также использоваться для хранения пунктов, которые уже были посещены в процессе
обхода графа или другой циклической структуры. Например, транзитивный загрузчик модулей и
программа вывода дерева наследования, которые мы будем рассматривать в главах 24 и 30
соответственно, должны запоминать элементы, которые уже были посещены, чтобы избежать
зацикливания. Посещенные элементы достаточно эффективно можно запоминать в виде 
ключей словаря, однако множества предлагают еще более эффективный эквивалент
(и для многих – более простой).

Наконец, множества удобно использовать при работе с большими массивами данных (например, с
результатами запроса к базе данных) – операция пересечения двух множеств позволяет 
получить объекты, присутствующие сразу в обеих категориях, а объединение – 
все объекты, присутствующие в любомиз множеств. 

Чтобы продемонстрировать это, ниже приводится несколько практичных примеров использования операций
над множествами, которые применяются к списку людей – служащих гипотетической компании. Здесь
используются литералы множеств, появившиеся в версии 3.0 (в версии 2.6 используйте функцию set):

>>> engineers = {"Alex", "Stan", "Bato", "Ghost"}
>>> managers = {"Alex", "Ghost"}
>>> "Alex" in engineers               # Alex инженер? 
True
>>> engineers & managers              # кто одновременно является инженером и менеджером? 
{'Alex', 'Ghost'}
>>> engineers | managers              # все сотрудники обеих категорий 
{'Alex', 'Bato', 'Ghost', 'Stan'}
>>> engineers - managers              # инженеры не являющиеся менеджерами 
{'Bato', 'Stan'}
>>> {"Alex", "Ghost"} < engineers     # оба сотрудника инженеры? (используем подмножество) 
True
>>> (managers | engineers) > managers # множество всех сотрудников является надмножеством менеджеров?
True
>>> managers ^ engineers              # сотрудники принадлежащие к одной категории 
{'Bato', 'Stan'}
>>> (managers | engineers) - (managers ^ engineers)  # пересечение 
{'Alex', 'Ghost'}
>>> 

# Логические значения (true false)

В языке Python имеется самостоятельный логический тип с име нем bool, с двумя предопределенными
значениями True и False. Эти значения являются экземплярами класса bool, который в свою очередь
является всего лишь подклассом (в объектно-ориентированном смысле) встроенного целочисленного
типа int. True и False ведут себя точно так же, как и целые числа 1 и 0, за исключением того,
что для их вывода на экран используется другая логика – они выводятся как слова
True и False вместо цифр 1 и 0. 

Технически это достига ется за счет переопределения в классе bool методов str и repr.

В соответствии с интерпретацией этих значений значения выражений логи ческого типа выводятся в
интерактивной оболочке как слова True и False, а не как числа 1 и 0. Можно считать, что
логический тип делает истинные значения более явными.

Например, теперь бесконечный цикл можно оформить как while True:, а не как менее очевидный
while 1:. Точно так же более понятной становится инициализация флагов, например flag = False.

Во всех остальных практических применениях значения True и False можно интерпретировать как
предопределенные переменные с целочисленными значениями 1 и 0.

Раньше большинство программистов создавали переменные True и False, которым присваивали значения
1 и 0; таким образом, тип bool просто следует этому стандартному приему. Его реализация может
приводить к неожиданным результатам: так как True – это всего лишь целое значение 1, которое
выводится на экран особым образом, выражение True + 4 в языке Python даст результат 5:

В строке True + 4  - предопределённая переменная с целочисленным значением взаимодействует через 
операнд с объектом класса int - дальше Лутц объяснять не стал, ограничивщись (М-да) но вообще то:

Python это язык основная идея которого состоит в гибкость переменных, которые видоизменяют свой
класс в зависимости от смысла выражения, в данном случае имеет место фактическая реализация Дзена

"Всё простое - лучше сложного"

Условно "сложная переменная" складывается с простым int - отсюда и результат - простой int == 5.

# Числовые расширения

Для реализации массивных вычислений можно использовать рас ширение NumPy (Numeric Numeric Python),
предоставляющее дополнительные возможности, такие как реализация матричных и векторных операций,
и обширные библиотеки реализации численных алгоритмов. Нередко комбинацию Python и NumPy
рассматривают как свободную и более гибкую альтернативу пакету Matlab – вы получаете
производительность расширения NumPy плюс язык Python и все его библиотеки

Поддержку дополнительных возможностей численного программирования в языке Python, включая
инструменты для анализа и построения графических изображений, библиотеки реализации
статистических методов и популярный пакет SciPy, вы можете найти на сайте
PyPI или в Сети.

Расширение NumPy в на стоящее время не входит в состав стандартной библиотеки Python и должно
устанавливаться отдельно.

Закончили на странице 195.
Это было интересно.
